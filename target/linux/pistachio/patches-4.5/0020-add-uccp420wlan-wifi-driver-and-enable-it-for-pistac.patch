From 3c09b75925dbd62189390b066d6d4bbad2d0585f Mon Sep 17 00:00:00 2001
From: sridhar nuvusetty <Sridhar.Nuvusetty@imgtec.com>
Date: Fri, 5 Jun 2015 15:49:22 +0530
Subject: add uccp420wlan wifi driver and enable it for pistachio

Also add wifi_pll rate table in clk-pistachio

Change-Id: I3e8acc22dedfab6752c281bd641dbc2f418859f0
Signed-off-by: Sridhar Nuvusetty <Sridhar.Nuvusetty@imgtec.com>
---
 arch/mips/boot/dts/pistachio/pistachio.dtsi        |   55 +
 arch/mips/boot/dts/pistachio/pistachio_marduk.dts  |    9 +
 arch/mips/configs/pistachio_defconfig              |   15 +
 drivers/clk/pistachio/clk-pistachio.c              |   15 +-
 drivers/net/wireless/Kconfig                       |    1 +
 drivers/net/wireless/Makefile                      |    1 +
 drivers/net/wireless/uccp420wlan/COPYING           |  356 ++
 drivers/net/wireless/uccp420wlan/Kconfig           |   10 +
 drivers/net/wireless/uccp420wlan/Makefile          |    5 +
 drivers/net/wireless/uccp420wlan/inc/core.h        |  593 ++++
 drivers/net/wireless/uccp420wlan/inc/descriptors.h |   49 +
 drivers/net/wireless/uccp420wlan/inc/fwldr.h       |  351 ++
 drivers/net/wireless/uccp420wlan/inc/hal.h         |   58 +
 .../net/wireless/uccp420wlan/inc/host_umac_if.h    | 1054 ++++++
 drivers/net/wireless/uccp420wlan/inc/umac_if.h     |  286 ++
 drivers/net/wireless/uccp420wlan/inc/utils.h       |   46 +
 drivers/net/wireless/uccp420wlan/inc/version.h     |   31 +
 drivers/net/wireless/uccp420wlan/src/80211_if.c    | 3702 ++++++++++++++++++++
 drivers/net/wireless/uccp420wlan/src/core.c        | 1225 +++++++
 drivers/net/wireless/uccp420wlan/src/fwldr.c       | 1201 +++++++
 .../net/wireless/uccp420wlan/src/hal_hostport.c    | 1858 ++++++++++
 .../net/wireless/uccp420wlan/src/hal_hostport.h    |  255 ++
 drivers/net/wireless/uccp420wlan/src/tx.c          |  931 +++++
 drivers/net/wireless/uccp420wlan/src/umac_if.c     | 2121 +++++++++++
 24 files changed, 14227 insertions(+), 1 deletion(-)
 create mode 100755 drivers/net/wireless/uccp420wlan/COPYING
 create mode 100644 drivers/net/wireless/uccp420wlan/Kconfig
 create mode 100644 drivers/net/wireless/uccp420wlan/Makefile
 create mode 100644 drivers/net/wireless/uccp420wlan/inc/core.h
 create mode 100644 drivers/net/wireless/uccp420wlan/inc/descriptors.h
 create mode 100644 drivers/net/wireless/uccp420wlan/inc/fwldr.h
 create mode 100644 drivers/net/wireless/uccp420wlan/inc/hal.h
 create mode 100644 drivers/net/wireless/uccp420wlan/inc/host_umac_if.h
 create mode 100644 drivers/net/wireless/uccp420wlan/inc/umac_if.h
 create mode 100644 drivers/net/wireless/uccp420wlan/inc/utils.h
 create mode 100644 drivers/net/wireless/uccp420wlan/inc/version.h
 create mode 100644 drivers/net/wireless/uccp420wlan/src/80211_if.c
 create mode 100644 drivers/net/wireless/uccp420wlan/src/core.c
 create mode 100644 drivers/net/wireless/uccp420wlan/src/fwldr.c
 create mode 100644 drivers/net/wireless/uccp420wlan/src/hal_hostport.c
 create mode 100644 drivers/net/wireless/uccp420wlan/src/hal_hostport.h
 create mode 100644 drivers/net/wireless/uccp420wlan/src/tx.c
 create mode 100644 drivers/net/wireless/uccp420wlan/src/umac_if.c

diff --git a/arch/mips/boot/dts/pistachio/pistachio.dtsi b/arch/mips/boot/dts/pistachio/pistachio.dtsi
index ee7f61f..40eb931 100644
--- a/arch/mips/boot/dts/pistachio/pistachio.dtsi
+++ b/arch/mips/boot/dts/pistachio/pistachio.dtsi
@@ -853,4 +853,59 @@
 		clock-frequency = <52000000>;
 		clock-output-names = "xtal";
 	};
+
+	wifi: uccp@18480000 {
+		status = "disabled";
+		compatible = "img,pistachio-uccp";
+		reg = <0x18480000 0x38000>, <0x184BC000 0x2800>, <0x1a000000 0x00066cc0>;
+		reg-names = "uccp_core_base", "uccp_slave_base" , "uccp_pkd_gram_base";
+		interrupts = <GIC_SHARED 67 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "uccpirq";
+		clocks = <&clk_core CLK_RPU_CORE>,
+			<&clk_core CLK_RPU_CORE_DIV>,
+			<&clk_core CLK_RPU_V>,
+			<&clk_core CLK_RPU_L>,
+			<&clk_core CLK_RPU_SLEEP>,
+			<&clk_core CLK_WIFI_PLL>,
+			<&clk_core CLK_WIFI_ADC>,
+			<&clk_core CLK_WIFI_DAC>,
+			<&clk_core CLK_EVENT_TIMER>,
+			<&cr_periph SYS_CLK_EVENT_TIMER>,
+			<&clk_core CLK_AUX_ADC>,
+			<&clk_core CLK_AUX_ADC_INTERNAL>;
+		clock-names = "rpu_core", "rpu_core_div", "rpu_v", "rpu_l", "rpu_sleep",
+			"wifi_pll", "wifi_adc", "wifi_dac", "event_timer",
+			"sys_event_timer", "aux_adc", "aux_adc_internal";
+		assigned-clocks = <&clk_core CLK_RPU_L_DIV>,
+			<&clk_core CLK_RPU_L_MUX>,
+			<&clk_core CLK_RPU_L_PLL_MUX>,
+			<&clk_core CLK_RPU_V_DIV>,
+			<&clk_core CLK_RPU_V_PLL_MUX>,
+			<&clk_core CLK_RPU_CORE_DIV>,
+			<&clk_core CLK_WIFI_PLL_MUX>,
+			<&clk_core CLK_WIFI_DIV4_MUX>,
+			<&clk_core CLK_WIFI_DIV8_MUX>,
+			<&clk_core CLK_RPU_SLEEP_DIV>;
+		assigned-clock-parents = <0>,
+			<&clk_core CLK_RPU_L_PLL_MUX>,
+			<&clk_core CLK_RPU_L_PLL>,
+			<0>,
+			<&clk_core CLK_RPU_V_PLL>,
+			<0>,
+			<&clk_core CLK_WIFI_PLL>,
+			<&clk_core CLK_WIFI_DIV4>,
+			<&clk_core CLK_WIFI_DIV8>,
+			<0>;
+		assigned-clock-rates = <559000000>,
+			<0>,
+			<0>,
+			<598000000>,
+			<0>,
+			<320000000>,
+			<0>,
+			<0>,
+			<0>,
+			<52000>;
+		io-channels = <&adc 4>, <&adc 5>;
+	};
 };
diff --git a/arch/mips/boot/dts/pistachio/pistachio_marduk.dts b/arch/mips/boot/dts/pistachio/pistachio_marduk.dts
index bd15b68..793c86b 100644
--- a/arch/mips/boot/dts/pistachio/pistachio_marduk.dts
+++ b/arch/mips/boot/dts/pistachio/pistachio_marduk.dts
@@ -121,3 +121,12 @@
 	status = "okay";
 	clock-frequency = <400000>;
 };
+
+&wifi {
+       status = "okay";
+       mac-address0 = [0123456789AC];
+       mac-address1 = [0123456789AD];
+       rf-params = [1E00000000002426292A2C2E3237393F454A52576066000000002B2C3033373A3D44474D51575A61656B6F000000002B2C3033373A3D44474D51575A61656B6F000000002B2C3033373A3D44474D51575A61656B6F000000002B2C3033373A3D44474D51575A61656B6F00000000002426292A2C2E3237393F454A52576066000000002B2C3033373A3D44474D51575A61656B6F000000002B2C3033373A3D44474D51575A61656B6F000000002B2C3033373A3D44474D51575A61656B6F000000002B2C3033373A3D44474D51575A61656B6F0808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808];
+       num_streams = [02];
+};
+
diff --git a/arch/mips/configs/pistachio_defconfig b/arch/mips/configs/pistachio_defconfig
index 18f02f1..b53cbce 100644
--- a/arch/mips/configs/pistachio_defconfig
+++ b/arch/mips/configs/pistachio_defconfig
@@ -349,3 +349,18 @@ CONFIG_CRC_T10DIF=m
 CONFIG_CRC7=m
 CONFIG_LIBCRC32C=m
 # CONFIG_XZ_DEC_X86 is not set
+CONFIG_NET_PKTGEN=y
+CONFIG_BT=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HCIBFUSB=y
+CONFIG_BT_HCIBTSDIO=y
+CONFIG_BT_HCIBTUSB=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIVHCI=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_UCCP420WLAN=m
diff --git a/drivers/clk/pistachio/clk-pistachio.c b/drivers/clk/pistachio/clk-pistachio.c
index 05222fd..4f1f755 100644
--- a/drivers/clk/pistachio/clk-pistachio.c
+++ b/drivers/clk/pistachio/clk-pistachio.c
@@ -162,6 +162,18 @@ static struct pistachio_pll_rate_table mips_pll_rates[] = {
 	INT_PLL_RATES(52000000, 546000000, 5, 105, 2, 1),
 };
 
+static struct pistachio_pll_rate_table wifi_pll_rates[] = {
+	{
+		.fref		= 52000000,
+		.fout		= 320000000,
+		.refdiv		= 0x1,
+		.fbdiv		= 0x18,
+		.frac		= 0x9d89d9,
+		.postdiv1	= 0x4,
+		.postdiv2	= 0x1,
+	},
+};
+
 static struct pistachio_pll pistachio_plls[] __initdata = {
 	PLL(CLK_MIPS_PLL, "mips_pll", "xtal", PLL_GF40LP_LAINT, 0x0,
 	    mips_pll_rates),
@@ -170,7 +182,8 @@ static struct pistachio_pll pistachio_plls[] __initdata = {
 	PLL_FIXED(CLK_RPU_V_PLL, "rpu_v_pll", "xtal", PLL_GF40LP_LAINT, 0x20),
 	PLL_FIXED(CLK_RPU_L_PLL, "rpu_l_pll", "xtal", PLL_GF40LP_LAINT, 0x2c),
 	PLL_FIXED(CLK_SYS_PLL, "sys_pll", "xtal", PLL_GF40LP_FRAC, 0x38),
-	PLL_FIXED(CLK_WIFI_PLL, "wifi_pll", "xtal", PLL_GF40LP_FRAC, 0x4c),
+	PLL(CLK_WIFI_PLL, "wifi_pll", "xtal", PLL_GF40LP_FRAC,
+	    0x4c, wifi_pll_rates),
 	PLL_FIXED(CLK_BT_PLL, "bt_pll", "xtal", PLL_GF40LP_LAINT, 0x60),
 };
 
diff --git a/drivers/net/wireless/Kconfig b/drivers/net/wireless/Kconfig
index 16604bd..8791e05 100644
--- a/drivers/net/wireless/Kconfig
+++ b/drivers/net/wireless/Kconfig
@@ -283,5 +283,6 @@ source "drivers/net/wireless/zd1211rw/Kconfig"
 source "drivers/net/wireless/mwifiex/Kconfig"
 source "drivers/net/wireless/cw1200/Kconfig"
 source "drivers/net/wireless/rsi/Kconfig"
+source "drivers/net/wireless/uccp420wlan/Kconfig"
 
 endif # WLAN
diff --git a/drivers/net/wireless/Makefile b/drivers/net/wireless/Makefile
index 0c88916..2fd06c6 100644
--- a/drivers/net/wireless/Makefile
+++ b/drivers/net/wireless/Makefile
@@ -60,3 +60,4 @@ obj-$(CONFIG_BRCMSMAC)	+= brcm80211/
 
 obj-$(CONFIG_CW1200)	+= cw1200/
 obj-$(CONFIG_RSI_91X)	+= rsi/
+obj-$(CONFIG_UCCP420WLAN)	+= uccp420wlan/
diff --git a/drivers/net/wireless/uccp420wlan/COPYING b/drivers/net/wireless/uccp420wlan/COPYING
new file mode 100755
index 0000000..ca442d3
--- /dev/null
+++ b/drivers/net/wireless/uccp420wlan/COPYING
@@ -0,0 +1,356 @@
+
+   NOTE! This copyright does *not* cover user programs that use kernel
+ services by normal system calls - this is merely considered normal use
+ of the kernel, and does *not* fall under the heading of "derived work".
+ Also note that the GPL below is copyrighted by the Free Software
+ Foundation, but the instance of code that it refers to (the Linux
+ kernel) is copyrighted by me and others who actually wrote it.
+
+ Also note that the only valid version of the GPL as far as the kernel
+ is concerned is _this_ particular version of the license (ie v2, not
+ v2.2 or v3.x or whatever), unless explicitly otherwise stated.
+
+			Linus Torvalds
+
+----------------------------------------
+
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/drivers/net/wireless/uccp420wlan/Kconfig b/drivers/net/wireless/uccp420wlan/Kconfig
new file mode 100644
index 0000000..b82304f
--- /dev/null
+++ b/drivers/net/wireless/uccp420wlan/Kconfig
@@ -0,0 +1,10 @@
+#
+# Imagination Wireless drivers
+#
+
+config UCCP420WLAN
+	tristate "Imagination UCCP420 WLAN"
+	depends on MAC80211 && CFG80211
+
+	---help---
+          Imagination technologies UCCP420 WLAN driver
diff --git a/drivers/net/wireless/uccp420wlan/Makefile b/drivers/net/wireless/uccp420wlan/Makefile
new file mode 100644
index 0000000..e142a9b
--- /dev/null
+++ b/drivers/net/wireless/uccp420wlan/Makefile
@@ -0,0 +1,5 @@
+uccp420wlan-objs		:= src/80211_if.o src/core.o src/umac_if.o src/tx.o src/hal_hostport.o src/fwldr.o
+obj-$(CONFIG_UCCP420WLAN)	+= uccp420wlan.o
+ccflags-y += -I$(src)/inc
+
+
diff --git a/drivers/net/wireless/uccp420wlan/inc/core.h b/drivers/net/wireless/uccp420wlan/inc/core.h
new file mode 100644
index 0000000..82bb9ef
--- /dev/null
+++ b/drivers/net/wireless/uccp420wlan/inc/core.h
@@ -0,0 +1,593 @@
+/*
+ * File Name  : core.h
+ *
+ * This file contains the declarations of structures that will
+ * be used by core, tx and rx code
+ *
+ * Copyright (c) 2011, 2012, 2013, 2014 Imagination Technologies Ltd.
+ * All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#ifndef _UCCP420WLAN_CORE_H_
+#define _UCCP420WLAN_CORE_H_
+
+#include <linux/version.h>
+#include <linux/spinlock.h>
+#include <linux/skbuff.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/wireless.h>
+#include <linux/sched.h>
+#include <linux/jiffies.h>
+
+#include <linux/interrupt.h>
+#include <net/mac80211.h>
+
+#include <linux/dma-mapping.h>
+#include <linux/atomic.h>
+#include <linux/etherdevice.h>
+
+#include "umac_if.h"
+#include "descriptors.h"
+
+extern unsigned int vht_support;
+extern struct cmd_send_recv_cnt cmd_info;
+
+extern unsigned int system_rev;
+
+#ifdef PERF_PROFILING
+extern unsigned long irq_timestamp[20];
+extern unsigned int irq_ts_index;
+extern spinlock_t timing_lock;
+#endif
+
+extern struct platform_driver img_uccp_driver;
+extern unsigned char vif_macs[2][ETH_ALEN];
+
+extern spinlock_t tsf_lock;
+
+#ifdef DRIVER_DEBUG
+#define DEBUG_LOG(fmt, args...) pr_debug(fmt, ##args)
+#else
+#define DEBUG_LOG(...) do { } while (0)
+#endif
+
+#define MAX_OUTSTANDING_CTRL_REQ 2
+#define RESET_TIMEOUT 5000   /* In milli-seconds*/
+#define RESET_TIMEOUT_TICKS msecs_to_jiffies(RESET_TIMEOUT)
+/*100: For ROC, 500: For initial*/
+#define CH_PROG_TIMEOUT 500   /* In milli-seconds*/
+#define CH_PROG_TIMEOUT_TICKS msecs_to_jiffies(CH_PROG_TIMEOUT)
+
+#ifdef CONFIG_PM
+#define PS_ECON_CFG_TIMEOUT 1000
+#define PS_ECON_CFG_TIMEOUT_TICKS msecs_to_jiffies(PS_ECON_CFG_TIMEOUT)
+#endif
+
+#define TX_COMPLETE_TIMEOUT 1000  /* In milli-seconds*/
+#define TX_COMPLETE_TIMEOUT_TICKS msecs_to_jiffies(TX_COMPLETE_TIMEOUT)
+#define SCAN_ABORT_TIMEOUT 1000
+#define SCAN_ABORT_TIMEOUT_TICKS msecs_to_jiffies(SCAN_ABORT_TIMEOUT)
+
+
+#define MAX_VIFS 2
+#define DEFAULT_TX_ANT_SELECT 3 /* bitmap of antennas for tx, 3=> both first and
+				 * second antenna to be used
+				 */
+#define DEFAULT_TX_POWER 15
+#define DEFAULT_RTS_THRESHOLD 2347
+#define SUPPORTED_FILTERS (FIF_ALLMULTI | FIF_BCN_PRBRESP_PROMISC)
+#define TX_DESC_BUCKET_BOUND 32
+
+#define MAX_DATA_SIZE (0) /* Defined in HAL (or) can be configured from proc */
+#define MAX_TX_QUEUE_LEN 192
+#define MAX_AUX_ADC_SAMPLES 10
+
+#define MAX_TX_STREAMS 2 /* Maximum number of Tx streams supported */
+#define MAX_RX_STREAMS 2 /* Maximum number of RX streams supported */
+
+#define   MAX_RSSI_SAMPLES 10
+
+#define CLOCK_MASK 0x3FFFFFFF
+#define TICK_NUMRATOR 1000 /* 1 MHz */
+#define TICK_DENOMINATOR 12288 /* 12288000 Hz */
+
+
+enum noa_triggers {
+	FROM_TX = 0,
+	FROM_TX_DONE,
+	FROM_EVENT_NOA
+};
+
+enum uccp420_hw_scan_status {
+	HW_SCAN_STATUS_NONE,
+	HW_SCAN_STATUS_PROGRESS
+};
+
+struct wifi_sync {
+	unsigned int  status;
+	unsigned char ts1[8];
+	unsigned long long atu;
+	unsigned char  bssid[8];
+	unsigned char  name[10];
+	unsigned int  ts2;
+};
+
+struct wifi_params {
+	int ed_sensitivity;
+	int num_vifs;
+	int tx_fixed_rate;
+	int tx_fixed_mcs_indx;
+	int mgd_mode_tx_fixed_rate;
+	int mgd_mode_tx_fixed_mcs_indx;
+	unsigned int peer_ampdu_factor;
+	unsigned char is_associated;
+	unsigned char rate_protection_type;
+	unsigned char num_spatial_streams;
+	unsigned char uccp_num_spatial_streams;
+	unsigned char auto_sensitivity;
+	/*RF Params: Input to the RF for operation*/
+	unsigned char  rf_params[RF_PARAMS_SIZE];
+	unsigned char  rf_params_vpd[RF_PARAMS_SIZE];
+	/*Calibration Params: Input for different calibrations in RF*/
+	unsigned char production_test;
+	unsigned int dot11a_support;
+	unsigned int dot11g_support;
+	unsigned int chnl_bw;
+	unsigned int prod_mode_chnl_bw_40_mhz;
+	unsigned int sec_ch_offset_40_plus;
+	unsigned int sec_ch_offset_40_minus;
+	unsigned int prod_mode_rate_flag;
+	unsigned int prod_mode_rate_preamble_type;
+	unsigned int prod_mode_stbc_enabled;
+	unsigned int prod_mode_bcc_or_ldpc;
+	unsigned int max_tx_streams;
+	unsigned int max_rx_streams;
+	unsigned int max_data_size;
+	unsigned int disable_power_save;
+	unsigned int disable_sm_power_save;
+	unsigned int max_tx_cmds;
+	unsigned int prod_mode_chnl_bw_80_mhz;
+	unsigned int sec_40_ch_offset_80_plus;
+	unsigned int sec_40_ch_offset_80_minus;
+#ifdef PERF_PROFILING
+	unsigned int driver_tput;
+#endif
+	unsigned int disable_beacon_ibss;
+	unsigned int vht_beamform_enable;
+	unsigned int vht_beamform_period;
+	unsigned int vht_beamform_support;
+	unsigned char bg_scan_channel_list[50];
+	unsigned char bg_scan_channel_flags[50];
+	unsigned int bg_scan_enable;
+	unsigned int bg_scan_intval;
+	unsigned int bg_scan_chan_dur;
+	unsigned int bg_scan_serv_chan_dur;
+	unsigned int bg_scan_num_channels;
+	unsigned int nw_selection;
+	unsigned int hw_scan_status;
+	unsigned int scan_type;
+	unsigned int set_tx_power;
+	unsigned int aux_adc_chain_id;
+	unsigned char pdout_voltage[MAX_AUX_ADC_SAMPLES];
+	char rssi_average[MAX_RSSI_SAMPLES];
+	unsigned int extra_scan_ies;
+	unsigned int fw_loading;
+	struct wifi_sync sync[MAX_VIFS];
+	unsigned int bt_state;
+	unsigned int antenna_sel;
+	int pkt_gen_val;
+	int payload_length;
+	int start_prod_mode;
+	int init_prod;
+};
+
+struct cmd_send_recv_cnt {
+	int tx_cmd_send_count;
+	int tx_done_recv_count;
+	int total_cmd_send_count;
+	unsigned int outstanding_ctrl_req;
+	unsigned long control_path_flags;
+	spinlock_t control_path_lock;
+	struct sk_buff_head outstanding_cmd;
+};
+
+struct wifi_stats {
+	unsigned int ht_tx_mcs0_packet_count;
+	unsigned int ht_tx_mcs1_packet_count;
+	unsigned int ht_tx_mcs2_packet_count;
+	unsigned int ht_tx_mcs3_packet_count;
+	unsigned int ht_tx_mcs4_packet_count;
+	unsigned int ht_tx_mcs5_packet_count;
+	unsigned int ht_tx_mcs6_packet_count;
+	unsigned int ht_tx_mcs7_packet_count;
+	unsigned int ht_tx_mcs8_packet_count;
+	unsigned int ht_tx_mcs9_packet_count;
+	unsigned int ht_tx_mcs10_packet_count;
+	unsigned int ht_tx_mcs11_packet_count;
+	unsigned int ht_tx_mcs12_packet_count;
+	unsigned int ht_tx_mcs13_packet_count;
+	unsigned int ht_tx_mcs14_packet_count;
+	unsigned int ht_tx_mcs15_packet_count;
+	unsigned int vht_tx_mcs0_packet_count;
+	unsigned int vht_tx_mcs1_packet_count;
+	unsigned int vht_tx_mcs2_packet_count;
+	unsigned int vht_tx_mcs3_packet_count;
+	unsigned int vht_tx_mcs4_packet_count;
+	unsigned int vht_tx_mcs5_packet_count;
+	unsigned int vht_tx_mcs6_packet_count;
+	unsigned int vht_tx_mcs7_packet_count;
+	unsigned int vht_tx_mcs8_packet_count;
+	unsigned int vht_tx_mcs9_packet_count;
+	unsigned int tx_cmds_from_stack;
+	unsigned int tx_dones_to_stack;
+	unsigned int system_rev;
+	unsigned int outstanding_cmd_cnt;
+	unsigned int pending_tx_cnt;
+	unsigned int umac_scan_req;
+	unsigned int umac_scan_complete;
+	unsigned int gen_cmd_send_count;
+	unsigned int tx_cmd_send_count_single;
+	unsigned int tx_cmd_send_count_multi;
+	unsigned int tx_done_recv_count;
+	unsigned int rx_packet_mgmt_count;
+	unsigned int rx_packet_data_count;
+	unsigned int ed_cnt;
+	unsigned int mpdu_cnt;
+	unsigned int ofdm_crc32_pass_cnt;
+	unsigned int ofdm_crc32_fail_cnt;
+	unsigned int dsss_crc32_pass_cnt;
+	unsigned int dsss_crc32_fail_cnt;
+	unsigned int mac_id_pass_cnt;
+	unsigned int mac_id_fail_cnt;
+	unsigned int ofdm_corr_pass_cnt;
+	unsigned int ofdm_corr_fail_cnt;
+	unsigned int dsss_corr_pass_cnt;
+	unsigned int dsss_corr_fail_cnt;
+	unsigned int ofdm_s2l_fail_cnt;
+	unsigned int lsig_fail_cnt;
+	unsigned int htsig_fail_cnt;
+	unsigned int vhtsiga_fail_cnt;
+	unsigned int vhtsigb_fail_cnt;
+	unsigned int nonht_ofdm_cnt;
+	unsigned int nonht_dsss_cnt;
+	unsigned int mm_cnt;
+	unsigned int gf_cnt;
+	unsigned int vht_cnt;
+	unsigned int aggregation_cnt;
+	unsigned int non_aggregation_cnt;
+	unsigned int ndp_cnt;
+	unsigned int ofdm_ldpc_cnt;
+	unsigned int ofdm_bcc_cnt;
+	unsigned int midpacket_cnt;
+	unsigned int dsss_sfd_fail_cnt;
+	unsigned int dsss_hdr_fail_cnt;
+	unsigned int dsss_short_preamble_cnt;
+	unsigned int dsss_long_preamble_cnt;
+	unsigned int sifs_event_cnt;
+	unsigned int cts_cnt;
+	unsigned int ack_cnt;
+	unsigned int sifs_no_resp_cnt;
+	unsigned int unsupported_cnt;
+	unsigned int l1_corr_fail_cnt;
+	unsigned int phy_stats_reserved22;
+	unsigned int phy_stats_reserved23;
+	unsigned int phy_stats_reserved24;
+	unsigned int phy_stats_reserved25;
+	unsigned int phy_stats_reserved26;
+	unsigned int phy_stats_reserved27;
+	unsigned int phy_stats_reserved28;
+	unsigned int phy_stats_reserved29;
+	unsigned int phy_stats_reserved30;
+	unsigned int pdout_val;
+	unsigned char uccp420_lmac_version[8];
+	/* TX related */
+	unsigned int tx_pkts_from_lmac;
+	unsigned int tx_pkts_tx2tx;
+	unsigned int tx_pkts_from_rx;
+	unsigned int tx_pkts_ofdm;
+
+	unsigned int tx_pkts_dsss;
+	unsigned int tx_pkts_reached_end_of_fsm;
+	unsigned int tx_unsupported_modulation;
+	unsigned int tx_latest_pkt_from_lmac_or_sifs;
+
+	unsigned int tx_abort_bt_confirm_cnt;       /* Tx abort due to BT
+						     * confirm at the start of
+						     * Txn
+						     */
+	unsigned int tx_abort_txstart_timeout_cnt;  /* Tx abort due to Tx start
+						     * time-out
+						     */
+	unsigned int tx_abort_mid_bt_cnt;           /* Tx abort due to BT during
+						     * WLAN txn
+						     */
+	unsigned int tx_abort_dac_underrun_cnt;     /* Tx abort due to DAC
+						     * under-run only
+						     */
+	unsigned int tx_ofdm_symbols_master;
+	unsigned int tx_ofdm_symbols_slave1;
+	unsigned int tx_ofdm_symbols_slave2;
+	unsigned int tx_dsss_symbols;
+	unsigned int cts_received_mcp_cnt;
+
+	/*MAC Stats*/
+	/* TX related */
+	unsigned int tx_cmd_cnt; /* Num of TX commands received from host */
+	unsigned int tx_done_cnt; /* Num of Tx done events sent to host */
+	unsigned int tx_edca_trigger_cnt; /* Num times EDCA engine was
+					   * triggered
+					   */
+	unsigned int tx_edca_isr_cnt; /* Num of times EDCA ISR was generated */
+	unsigned int tx_start_cnt; /* Num of TX starts to MCP */
+	unsigned int tx_abort_cnt; /* Num of TX aborts detected */
+	unsigned int tx_abort_isr_cnt; /* Num of TX aborts received from MCP */
+	unsigned int tx_underrun_cnt; /* Num of under-runs */
+	unsigned int tx_rts_cnt; /* Num of RTS frames Txd */
+	unsigned int tx_ampdu_cnt; /* Num of AMPDUs txd incremented by 1 for
+				    * each A-MPDU (consisting of one or more
+				    * MPDUs)
+				    */
+	unsigned int tx_mpdu_cnt; /* Num of MPDUs txd  incremented by 1 for
+				   * MPDU (1 for each A-MPDU subframe)
+				   */
+
+	/* RX related */
+	unsigned int rx_isr_cnt; /* Num of RX ISRs */
+	unsigned int rx_ack_cts_to_cnt; /* Num of timeouts ACK */
+	unsigned int rx_cts_cnt; /* Num of CTS frames received */
+	unsigned int rx_ack_resp_cnt; /* Num of Ack frames received */
+	unsigned int rx_ba_resp_cnt; /* Num of BA frames received */
+	unsigned int rx_fail_in_ba_bitmap_cnt; /* Num of BA frames indicating at
+						* least one failure in the BA
+						* bitmap
+						*/
+	unsigned int rx_circular_buffer_free_cnt; /* Num of entries returned to
+						   * RX circular buffers
+						   */
+	unsigned int rx_mic_fail_cnt; /* Num of MIC failures */
+
+	/* HAL related */
+	unsigned int hal_cmd_cnt; /* Num of commands received by HAL from the
+				   * host
+				   */
+	unsigned int hal_event_cnt; /* Num of events sent by HAL to the host */
+	unsigned int hal_ext_ptr_null_cnt; /* Num of packets dropped due to lack
+					    * of Ext Ram buffers from host
+					    */
+
+	/*RF Calibration Data*/
+	unsigned int rf_calib_data_length;
+	unsigned char rf_calib_data[MAX_RF_CALIB_DATA];
+};
+
+struct tx_config {
+	/* Used to protect the TX pool */
+	spinlock_t lock;
+
+#ifdef PERF_PROFILING
+	 struct timer_list persec_timer;
+#endif
+	/* Used to store tx tokens(buff pool ids) */
+	unsigned long buf_pool_bmp[(NUM_TX_DESCS/TX_DESC_BUCKET_BOUND) + 1];
+
+	unsigned int outstanding_tokens[NUM_ACS];
+	unsigned int next_spare_token_ac;
+
+	/* Used to store the address of pending skbs per ac */
+	struct sk_buff_head pending_pkt[NUM_ACS];
+
+	/* Used to store the address of tx'ed skb and len of 802.11 hdr
+	 * it will be used in tx complete.
+	 */
+	struct sk_buff_head tx_pkt[NUM_TX_DESCS];
+	unsigned int tx_pkt_hdr_len[NUM_TX_DESCS];
+
+	unsigned int queue_stopped_bmp;
+	struct sk_buff_head proc_tx_list[NUM_TX_DESCS];
+};
+
+enum device_state {
+	STOPPED = 0,
+	STARTED
+};
+
+enum tid_aggr_state {
+	TID_STATE_INVALID = 0,
+	TID_STATE_AGGR_START,
+	TID_STATE_AGGR_STOP,
+	TID_STATE_AGGR_OPERATIONAL
+};
+
+#define TID_INITIATOR_STA 0x0000
+#define TID_INITIATOR_AP 0x0010
+
+struct sta_tid_info {
+	unsigned short ssn;
+	enum tid_aggr_state tid_state;
+};
+
+#ifdef CONFIG_PM
+struct econ_ps_cfg_status {
+	unsigned char completed;
+	unsigned char result;
+	int wake_trig;
+};
+#endif
+
+struct current_channel {
+	unsigned int pri_chnl_num;
+	unsigned int chnl_num1;
+	unsigned int chnl_num2;
+	unsigned int freq_band;
+	unsigned int ch_width;
+};
+
+struct roc_params {
+	unsigned char roc_in_progress;
+	unsigned char roc_ps_changed;
+	unsigned char roc_chan_changed;
+	atomic_t roc_mgmt_tx_count;
+};
+struct mac80211_dev {
+	struct proc_dir_entry *umac_proc_dir_entry;
+	struct device *dev;
+	struct mac_address if_mac_addresses[MAX_VIFS];
+	unsigned int active_vifs;
+	struct mutex mutex;
+	int state;
+	int txpower;
+	unsigned char	mc_filters[MCST_ADDR_LIMIT][6];
+	int mc_filter_count;
+
+	struct tasklet_struct proc_tx_tasklet;
+	/*ROC Work*/
+	struct delayed_work roc_complete_work;
+	struct roc_params roc_params;
+	struct current_channel cur_chan;
+	struct tx_config tx;
+	struct sk_buff_head pending_pkt[NUM_ACS];
+
+	/* Regulatory stuff */
+	char alpha2[2]; /* alpha2 country code */
+#ifdef CONFIG_PM
+	struct econ_ps_cfg_status econ_ps_cfg_stats;
+#endif
+	struct wifi_params *params;
+	struct wifi_stats  *stats;
+	char name[20];
+	char scan_abort_done;
+	char chan_prog_done;
+	char reset_complete;
+	int power_save; /* Will be set only when a single VIF in
+			 * STA mode is active
+			 */
+	struct ieee80211_vif *vifs[MAX_VIFS];
+	struct ieee80211_hw *hw;
+	struct sta_tid_info  tid_info[32];
+	spinlock_t bcast_lock; /* Used to ensure more_frames bit is set properly
+				* when transmitting bcast frames in AP in IBSS
+				* modes
+				*/
+	unsigned char tx_antenna;
+	unsigned char tx_last_beacon;
+	unsigned int rts_threshold;
+};
+
+struct edca_params {
+	unsigned short txop; /* units of 32us */
+	unsigned short cwmin;/* units of 2^n-1 */
+	unsigned short cwmax;/* units of 2^n-1 */
+	unsigned char aifs;
+	unsigned char uapsd;
+};
+
+struct umac_vif {
+	struct timer_list bcn_timer;
+#ifdef PERF_PROFILING
+	struct timer_list driver_tput_timer;
+#endif
+	struct uvif_config {
+		unsigned int atim_window;
+		unsigned int aid;
+		unsigned int bcn_lost_cnt;
+		struct edca_params edca_params[NUM_ACS];
+	} config;
+
+	unsigned int noa_active;
+	struct sk_buff_head noa_que;
+	unsigned int noa_tx_allowed;
+
+	int vif_index;
+	struct ieee80211_vif *vif;
+	struct mac80211_dev *dev;
+	unsigned char bssid[ETH_ALEN];
+	unsigned int peer_ampdu_factor;
+
+	/*Global Sequence no for non-qos and mgmt frames/vif*/
+	__u16 seq_no;
+};
+
+
+extern int wait_for_scan_abort(struct mac80211_dev *dev);
+extern int wait_for_channel_prog_complete(struct mac80211_dev *dev);
+extern int uccp420wlan_prog_nw_selection(unsigned int nw_select_enabled,
+					 unsigned char *mac_addr);
+extern int  uccp420wlan_core_init(struct mac80211_dev *dev, unsigned int ftm);
+extern void uccp420wlan_core_deinit(struct mac80211_dev *dev, unsigned int ftm);
+extern void uccp420wlan_vif_add(struct umac_vif  *uvif);
+extern void uccp420wlan_vif_remove(struct umac_vif *uvif);
+extern void uccp420wlan_vif_set_edca_params(unsigned short queue,
+					    struct umac_vif *uvif,
+					    struct edca_params *params,
+					    unsigned int vif_active);
+extern void uccp420wlan_vif_bss_info_changed(struct umac_vif *uvif,
+					     struct ieee80211_bss_conf
+					     *bss_conf, unsigned int changed);
+extern int  uccp420wlan_tx_frame(struct sk_buff *skb, struct ieee80211_sta *sta,
+				 struct mac80211_dev *dev, bool bcast);
+extern void uccp420wlan_tx_init(struct mac80211_dev *dev);
+extern void uccp420wlan_tx_deinit(struct mac80211_dev *dev);
+
+extern void proc_bss_info_changed(unsigned char *mac_addr, int value);
+extern void packet_generation(unsigned long data);
+extern int wait_for_reset_complete(struct mac80211_dev *dev);
+
+/* Beacon TimeStamp */
+__s32 __attribute__((weak)) frc_to_atu(__u32 frccnt, __u64 *patu, s32 dir);
+int __attribute__((weak)) get_evt_timer_freq(unsigned int *mask,
+						unsigned int *num,
+						unsigned int *denom);
+
+extern unsigned char *rf_params_vpd;
+extern int num_streams_vpd;
+
+static inline int vif_addr_to_index(unsigned char *addr,
+				    struct mac80211_dev *dev)
+{
+	int i;
+	for (i = 0; i < MAX_VIFS; i++)
+		if (ether_addr_equal(addr, dev->if_mac_addresses[i].addr))
+			break;
+	if ((i < MAX_VIFS) && (dev->active_vifs & (1 << i)))
+		return i;
+	else
+		return -1;
+}
+
+static inline int ieee80211_is_unicast_robust_mgmt_frame(struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+
+	if (skb->len < 24 || is_multicast_ether_addr(hdr->addr1))
+		return 0;
+
+	return ieee80211_is_robust_mgmt_frame(skb);
+}
+static inline bool is_bufferable_mgmt_frame(struct ieee80211_hdr *hdr)
+{
+	__u16 fc = hdr->frame_control;
+	/*TODO: Handle Individual Probe Response frame in IBSS*/
+	if (ieee80211_is_action(fc) ||
+		ieee80211_is_disassoc(fc) ||
+		ieee80211_is_deauth(fc))
+		return	true;
+
+	return false;
+}
+#endif /* _UCCP420WLAN_CORE_H_ */
diff --git a/drivers/net/wireless/uccp420wlan/inc/descriptors.h b/drivers/net/wireless/uccp420wlan/inc/descriptors.h
new file mode 100644
index 0000000..9ac47a7
--- /dev/null
+++ b/drivers/net/wireless/uccp420wlan/inc/descriptors.h
@@ -0,0 +1,49 @@
+/*
+ * File Name  : descriptor.h
+ *
+ * File Description: This file contains information about TX and RX descriptors
+ * This file contains Intermodule communication APIs
+ *
+ * Copyright (c) 2011, 2012, 2013, 2014 Imagination Technologies Ltd.
+ * All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#ifndef _UCCP420WLAN_DESCRIPTOR_H_
+#define _UCCP420WLAN_DESCRIPTOR_H_
+
+#define NUM_ACS			5
+
+#define NUM_TX_DESCS_PER_AC	2	/* reserved TX descriptors per AC
+					 * (must be multiple of 2, minimum of 2
+					 * and maximum of 4)
+					 */
+#define NUM_SPARE_TX_DESCS	2	/* Descriptors shared between ACs
+					 * (at least 1 and maximum of 2)
+					 */
+
+#define NUM_TX_DESCS    ((NUM_ACS *  NUM_TX_DESCS_PER_AC) + NUM_SPARE_TX_DESCS)
+#define MAX_AMPDU_SUBFRAME_SIZE	1500	/*max size of a sub-frame in an AMPDU*/
+#define MAX_SUBFRAMES_IN_AMPDU	24	/*max no of sub frames in an AMPDU*/
+
+#define NUM_CTRL_DESCS		2
+
+#define NUM_RX_BUFS_2K		64
+#define NUM_RX_BUFS_12K		16
+
+#endif /* _UCCP420WLAN_DESCRIPTOR_H_ */
+/* EOF */
diff --git a/drivers/net/wireless/uccp420wlan/inc/fwldr.h b/drivers/net/wireless/uccp420wlan/inc/fwldr.h
new file mode 100644
index 0000000..2ebd0c0
--- /dev/null
+++ b/drivers/net/wireless/uccp420wlan/inc/fwldr.h
@@ -0,0 +1,351 @@
+/*
+ * File Name  : fwldr.h
+ *
+ * File Description: This file contains definitions used for firmware loader
+ *
+ * Copyright (c) 2011, 2012, 2013, 2014 Imagination Technologies Ltd.
+ * All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#ifndef _FWLDR_H_
+#define _FWLDR_H_
+
+#include <linux/skbuff.h>
+#include <linux/interrupt.h>
+#include "hal.h"
+#include "version.h"
+
+#ifdef DRIVER_DEBUG
+
+#define fwldr_dbg_err(...) pr_err(__VA_ARGS__)
+#define fwldr_dbg_info(...) pr_info(__VA_ARGS__)
+#define fwldr_dbg_dump(...) pr_info(__VA_ARGS__)
+
+#else
+#define fwldr_dbg_err(...) do { } while (0)
+#define fwldr_dbg_info(...) do { } while (0)
+#define fwldr_dbg_dump(...) do { } while (0)
+
+#endif
+
+#define FWLDR_NUM_BINS 2
+#define FWLDR_HW_BIN "img/uccp420wlan/MCP_LOADER.ldr"
+#define FWLDR_FW_BIN "img/uccp420wlan/MAC_LOADER.ldr"
+
+#define FWLDR_PLRCRD_WORDS 16  /* 64-bit WORDS */
+#define FWLDR_PLRCRD_BYTES (FWLDR_PLRCRD_WORDS * 8)
+#define FWLDR_PLRCRD_TRAIL_BYTES 8
+#define FWLDR_PLRCRD_DATA_BYTES (FWLDR_PLRCRD_BYTES - FWLDR_PLRCRD_TRAIL_BYTES)
+
+
+/******************************************************************************
+* These constants are used to access various fields within an L1 record as well
+* as other constants that are used.
+******************************************************************************/
+
+/* The maximum number of bytes in an L1 record. */
+#define FWLDR_L1_MAXSIZE 32
+
+/* The maximum number of bytes in an L2 record. */
+#define FWLDR_L2_MAXSIZE 4096
+
+/* The size in bytes of the 'cmd' field in an L1 Record. */
+#define FWLDR_L1_CMD_SIZE 2
+
+/* The size in bytes of the 'length' field in an L1 Record. */
+#define FWLDR_L1_LEN_SIZE 2
+
+/* The size in bytes of the 'next' field in an L1 Record. */
+#define FWLDR_L1_NXT_SIZE 4
+
+/* The size in bytes of the 'arg1' field in an L1 Record. */
+#define FWLDR_L1_ARG1_SIZE 4
+
+/* The size in bytes of the 'arg2' field in an L1 Record. */
+#define FWLDR_L1_ARG2_SIZE 4
+
+/* The size in bytes of the 'l2offset' field in an L1 Record. */
+#define FWLDR_L1_L2OFF_SIZE 4
+
+/* The size in bytes of the 'xsum' field in an L1 Record. */
+#define FWLDR_L1_XSUM_SIZE 2
+
+/* The offset in bytes of the 'cmd' field in an L1 record. */
+#define FWLDR_L1_CMD_OFF 0
+
+/* The offset in bytes of the 'length' field in an L1 record. */
+#define FWLDR_L1_LEN_OFF (FWLDR_L1_CMD_OFF + FWLDR_L1_CMD_SIZE)
+
+/* The offset in bytes of the 'next' field in an L1 record. */
+#define FWLDR_L1_NXT_OFF (FWLDR_L1_LEN_OFF + FWLDR_L1_LEN_SIZE)
+
+/* The offset in bytes of the 'arg1' field in an L1 record. */
+#define FWLDR_L1_ARG1_OFF (FWLDR_L1_NXT_OFF + FWLDR_L1_NXT_SIZE)
+
+/* The offset in bytes of the 'arg2' field in an L1 record. */
+#define FWLDR_L1_ARG2_OFF (FWLDR_L1_ARG1_OFF + FWLDR_L1_ARG1_SIZE)
+
+/* The following is the value used to terminate a chain of L1 records */
+#define FWLDR_L1_TERMINATE 0xffffffff
+
+
+/******************************************************************************
+* These constants are used to access various fields within an L2 record as well
+* as other constants that are used.
+******************************************************************************/
+
+/* The size in bytes of the 'cmd' field in an L2 Record. */
+#define FWLDR_L2_CMD_SIZE 2
+
+/* The size in bytes of the 'length' field in an L2 Record. */
+#define FWLDR_L2_LEN_SIZE 2
+
+/* The size in bytes of the 'xsum' field in an L2 Record. */
+#define FWLDR_L2_XSUM_SIZE 2
+
+/* The offset in bytes from the beginning of an L2 record to the data
+ * payload
+ */
+#define FWLDR_L2_DATA (FWLDR_L2_CMD_SIZE + FWLDR_L2_LEN_SIZE)
+
+
+/******************************************************************************
+* Various combined values...
+******************************************************************************/
+
+/* Sizes of common items between L1 and L2 records */
+#define FWLDR_L1_L2LEN_SIZE FWLDR_L2_LEN_SIZE
+
+/* The size in bytes of an L1 record when it contains no data */
+#define FWLDR_L1_BASIC_SIZE (FWLDR_L1_CMD_SIZE + \
+			     FWLDR_L1_LEN_SIZE + \
+			     FWLDR_L1_NXT_SIZE + \
+			     FWLDR_L1_L2OFF_SIZE + \
+			     FWLDR_L1_L2LEN_SIZE + \
+			     FWLDR_L1_XSUM_SIZE)
+
+/* The size in bytes of an L2 record when it contains no data */
+#define FWLDR_L2_BASIC_SIZE (FWLDR_L2_CMD_SIZE + \
+			     FWLDR_L2_LEN_SIZE + \
+			     FWLDR_L2_XSUM_SIZE)
+
+
+/* Offsets in bytes from the end of an L1 record for various fields */
+#define FWLDR_L1_L2LEN_OFF (FWLDR_L1_XSUM_SIZE + FWLDR_L1_L2LEN_SIZE)
+#define FWLDR_L1_L2OFF_OFF (FWLDR_L1_L2LEN_OFF + FWLDR_L1_L2OFF_SIZE)
+
+#define UCCP_GRAM_BASE	    0xB7000000
+
+#define UCCP_SLAVE_PORT_OFFSET 0x3C000
+#define UCCP_OFFSET_MASK    0x00FFFFFF
+#define UCCP_BASE_MASK      0xFF000000
+#define UCCP_SYSBUS_REG     0x02
+#define UCCP_GRAM_PACKED    0xB7
+#define UCCP_GRAM_MSB       0xB4
+
+
+#define MTX_REG_INDIRECT(unit, reg) (((reg & 0x7) << 4) | (unit & 0xF))
+
+#define MTX_PC_REG_IND_ADDR        MTX_REG_INDIRECT(5, 0)
+#define MTX_A0STP_REG_IND_ADDR     MTX_REG_INDIRECT(3, 0)
+
+#define MTX_PCX_REG_IND_ADDR MTX_REG_INDIRECT(5, 1)
+#define MTX_TXMASK_REG_IND_ADDR MTX_REG_INDIRECT(7, 1)
+#define MTX_TXMASKI_REG_IND_ADDR MTX_REG_INDIRECT(7, 3)
+#define MTX_TXPOLL_REG_IND_ADDR MTX_REG_INDIRECT(7, 4)
+#define MTX_TXPOLLI_REG_IND_ADDR MTX_REG_INDIRECT(7, 6)
+#define MTX_TXSTAT_REG_IND_ADDR MTX_REG_INDIRECT(7, 0)
+#define MTX_TXSTATI_REG_IND_ADDR MTX_REG_INDIRECT(7, 2)
+
+#define REG_IND_READ_FLAG (1 << 16)
+
+#define MTX_TXPRIVEXT_ADDR 0x048000E8
+#define MTX_TXSTATUS_ADDR 0x48000010
+#define	MTX_TXENABLE_ADDR 0x04800000
+#define	MTX_START_EXECUTION 1
+#define	MTX_STOP_EXECUTION 0
+
+#define MTX_TXUXXRXDT 0x0480FFF0
+#define MTX_TXUXXRXRQ 0x0480FFF8
+
+#define MSLV_BASE_ADDR 0x0203C000
+
+/* DATA Exchange Register */
+#define MSLVDATAX (MSLV_BASE_ADDR + 0x2000)
+
+/* DATA Transfer Register */
+#define MSLVDATAT (MSLV_BASE_ADDR + 0x2040)
+
+/* Control Register 0 */
+#define MSLVCTRL0 (MSLV_BASE_ADDR + 0x2080)
+
+/* Soft Reset register */
+#define MSLVSRST (MSLV_BASE_ADDR + 0x2600)
+
+#define SLAVE_ADDR_MODE_MASK 0xFFFFFFFC
+#define SLAVE_SINGLE_WRITE 0x00
+#define SLAVE_SINGLE_READ 0x01
+#define SLAVE_BLOCK_WRITE 0x02
+#define SLAVE_BLOCK_READ 0x03
+
+/* Control Register 1 */
+#define MSLVCTRL1 (MSLV_BASE_ADDR + 0x20c0)
+
+#define MSLVCTRL1_POLL_MASK 0x07000000
+#define MSLAVE_READY(v) ((v & MSLVCTRL1_POLL_MASK) == MSLVCTRL1_POLL_MASK)
+#define LTP_THREAD_NUM 0 /* Since, only one thread exists */
+
+/* Thread completion signature */
+#define UCCP_THRD_EXEC_SIG_OFFSET 0x00066CBC
+#define UCCP_THRD_EXEC_SIG 0x5A5A5A5A
+
+#define MAX_LOAD_MEM_LEN 4096
+
+
+enum fwldr_status {
+	FWLDR_SUCCESS,
+	FWLDR_FAIL
+};
+
+/* Cmd or Tag values used in the L1/L2 records */
+enum fwldr_cmd_tag_l1_l2 {
+	FWLDR_L1_CMD_LOAD_MEM = 0x0000, /* Command - L1 LoadMem. */
+	FWLDR_L1_CMD_START_THRDS = 0x0003, /* Command - L1 StartThrds. */
+	FWLDR_L1_CMD_ZERO_MEM = 0x0004, /* Command - L1 ZeroMem. */
+	FWLDR_L1_CMD_CONFIG = 0x0005, /* Command - L1 Config. */
+	FWLDR_L1_CMD_FILENAME = 0x0010, /* Command - L1 FileName. */
+};
+
+/* Enumerates all possible types of configuration commands */
+enum fwldr_conf_cmd {
+	FWLDR_CONF_CMD_PAUSE = 0x0000, /* Pause */
+	FWLDR_CONF_CMD_READ, /* Read */
+	FWLDR_CONF_CMD_WRITE, /* Write */
+	FWLDR_CONF_CMD_MEMSET, /* MemSet */
+	FWLDR_CONF_CMD_MEMCHK, /* MemChk */
+	FWLDR_CONF_CMD_USER, /* User */
+};
+
+/* Information contained within an .ldr file */
+enum fwldr_ldr_sec {
+	FWLDR_SEC_NONE = 0, /* Element is undefined */
+	FWLDR_SEC_BOOT_HEADER, /* Boot header */
+	FWLDR_LDR_CODE, /* Secondary loader executable */
+	FWLDR_SEC_DATA_L1, /* Secondary loader top level data stream */
+	FWLDR_SEC_DATA_L2 /* Secondary loader raw data stream */
+};
+
+enum uccp_mem_region {
+	UCCP_MEM_CORE,
+	UCCP_MEM_DIRECT,
+	UCCP_MEM_ERR
+};
+
+struct fwldr_bootdevhdr {
+	unsigned int  dev_id; /* Value used to verify access to boot device */
+	unsigned int  sl_code; /* Offset to secondary loader code */
+#define BOOTDEV_SLCSECURE_BIT 0x80000000
+#define BOOTDEV_SLCCRITICAL_BIT 0x40000000
+
+	unsigned int  sl_data; /* Offset to data used by secondary loader */
+	unsigned short pl_ctrl; /* Primary loader control */
+#define BOOTDEV_PLCREMAP_BITS 0x00FF
+#define BOOTDEV_PLCREMAP_S 0
+
+	unsigned short CRC; /* CRC value */
+};
+
+struct fwldr_load_mem_info {
+	unsigned int dst_addr;
+	unsigned int len;
+	unsigned char *src_buf;
+};
+
+struct fwldr_thrd_info {
+	unsigned int thrd_num;
+	unsigned int stack_ptr;
+	unsigned int prog_ctr;
+	unsigned int catch_state_addr;
+};
+
+struct fwldr_cfg_rw {
+	unsigned int addr;
+	unsigned int val;
+};
+
+/*  Represents a secondary loader top level data stream record. */
+struct fwldr_sec_ldr_l1_record {
+	unsigned short cmd_tag; /* Command TagMember comment goes here */
+	unsigned short len; /* Total length os this record */
+	unsigned short crc; /* X25 CRC checksum for this record (including the
+			     * checksum itself)
+			     */
+	unsigned int nxt; /* Offset within the .ldr to the next L1RECORD */
+	unsigned int arg1; /* The first command argument for the command */
+	unsigned int arg2; /* The second command argument for the command */
+	unsigned int l2_offset; /* Offset within the .ldr to the corresponding
+				 * raw data record
+				 */
+	unsigned int l2_len; /* The expected length of the raw data record */
+};
+
+struct fwldr_memhdr_tag {
+	struct fwldr_memhdr_tag *p_next;
+	unsigned int addr; /* Target byte address */
+	unsigned char *data; /* Data block pointer */
+	unsigned int len; /* Len in bytes of data block */
+
+};
+
+struct fwload_priv {
+	unsigned char           *gram_addr;
+	unsigned char           *core_addr;
+	unsigned char           *gram_b4_addr;
+};
+
+int fwldr_load_fw(const unsigned char *fw_data, int i);
+
+static inline void fwload_uccp_read(struct fwload_priv *fpriv,
+				    unsigned long base,
+				    unsigned long offset,
+				    unsigned int *data)
+{
+	if (base == UCCP_SYSBUS_REG)
+		*data = readl((void __iomem *)fpriv->core_addr +
+			  (offset - UCCP_SLAVE_PORT_OFFSET));
+	else if (base == UCCP_GRAM_PACKED)
+		*data = readl((void __iomem *)fpriv->gram_addr + (offset));
+	else if (base == UCCP_GRAM_MSB)
+		*data = readl((void __iomem *)fpriv->gram_b4_addr + (offset));
+}
+
+static inline void fwload_uccp_write(struct fwload_priv *fpriv,
+				     unsigned long base,
+				     unsigned long offset,
+				     unsigned int data)
+{
+	if (base == UCCP_SYSBUS_REG)
+		writel(data, (void __iomem *)(fpriv->core_addr +
+					  (offset - UCCP_SLAVE_PORT_OFFSET)));
+	else if (base == UCCP_GRAM_PACKED)
+		writel(data, (void __iomem *)(fpriv->gram_addr + (offset)));
+	else if (base == UCCP_GRAM_MSB)
+		writel(data, (void __iomem *)(fpriv->gram_b4_addr + (offset)));
+}
+
+#endif /* _FWLDR_H_ */
diff --git a/drivers/net/wireless/uccp420wlan/inc/hal.h b/drivers/net/wireless/uccp420wlan/inc/hal.h
new file mode 100644
index 0000000..4b850e2
--- /dev/null
+++ b/drivers/net/wireless/uccp420wlan/inc/hal.h
@@ -0,0 +1,58 @@
+/*
+ * File Name  : hal.h
+ *
+ * This file contains Intermodule communication APIs
+ *
+ * Copyright (c) 2011, 2012, 2013, 2014 Imagination Technologies Ltd.
+ * All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#ifndef _UCCP420WLAN_HAL_H_
+#define _UCCP420WLAN_HAL_H_
+
+#define HOST_MOD_ID 0
+#define UMAC_MOD_ID 1
+#define LMAC_MOD_ID 2
+#define MODULE_MAX 3
+
+#define HAL_PRIV_DATA_SIZE 8
+
+typedef int (*msg_handler)(void *, unsigned char);
+
+struct hal_ops_tag {
+	int (*init)(void *);
+	int (*deinit)(void *);
+	int (*start)(struct proc_dir_entry *);
+	int (*stop)(struct proc_dir_entry *);
+	void (*register_callback)(msg_handler, unsigned char);
+	void (*send)(void*, unsigned char, unsigned char, void*);
+	int (*init_bufs)(unsigned int, unsigned int, unsigned int,
+			 unsigned int);
+	void (*deinit_bufs)(void);
+	int (*map_tx_buf)(int, int, unsigned char *, int);
+	int (*unmap_tx_buf)(int, int);
+	int (*reset_hal_params)(void);
+	void (*set_mem_region)(unsigned int);
+	void (*request_mem_regions)(unsigned char **, unsigned char **,
+				    unsigned char **);
+};
+
+extern struct hal_ops_tag hal_ops;
+#endif /* _UCCP420WLAN_HAL_H_ */
+
+/* EOF */
diff --git a/drivers/net/wireless/uccp420wlan/inc/host_umac_if.h b/drivers/net/wireless/uccp420wlan/inc/host_umac_if.h
new file mode 100644
index 0000000..86343fe
--- /dev/null
+++ b/drivers/net/wireless/uccp420wlan/inc/host_umac_if.h
@@ -0,0 +1,1054 @@
+/*
+ * File Name  : host_umac_if.h
+ *
+ * This file contains the UMAC<-->HOST comms data structures
+ *
+ * Copyright (c) 2011, 2012, 2013, 2014 Imagination Technologies Ltd.
+ * All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#ifndef _UCCP420HOST_UMAC_IF_H_
+#define _UCCP420HOST_UMAC_IF_H_
+
+#include "hal.h"
+#define MCST_ADDR_LIMIT	48
+#define WLAN_ADDR_LEN 6
+#define TKIP_MIC_LEN 8
+#define MICHAEL_LEN 16
+#define MAX_KEY_LEN 16
+
+#define WEP40_KEYLEN 5
+#define WEP104_KEYLEN 13
+#define MAX_WEP_KEY_LEN 13
+
+#define WLAN_20MHZ_OPERATION 0
+#define WLAN_40MHZ_OPERATION 1
+#define WLAN_80MHZ_OPERATION 2
+#define WLAN_SEC_UPPER 0
+#define WLAN_SEC_LOWER 1
+
+/* TEMPdec */
+#define PWRSAVE_STATE_AWAKE 1
+#define PWRSAVE_STATE_DOZE 0
+/* TEMPDEC */
+#define MAX_SSID_LEN 32
+#define MAX_NUM_SSIDS 4
+#define TOTAL_KEY_LEN 32
+#define RX_SEQ_SIZE 6
+#define MAX_IE_LEN 100
+#define ETH_ALEN 6
+
+#define MAX_TX_CMDS 32
+#define MAX_GRAM_PAYLOAD_LEN 52
+
+#define RF_PARAMS_SIZE	369
+#define MAX_RF_CALIB_DATA 900
+struct hal_data {
+	unsigned char hal_data[HAL_PRIV_DATA_SIZE];
+} __packed;
+
+struct host_mac_msg_hdr {
+	struct hal_data hal_data;
+	unsigned int descriptor_id; /* LSB 2 bytes as pool id, MSB 2 bytes
+				     * queue num, pool ID of 0xFFFF indicates
+				     * no payload
+				     */
+	unsigned int payload_length;
+	unsigned int id;
+	unsigned int length;
+	unsigned int more_cmd_data; /* used for fragmenting commands */
+} __packed;
+
+
+enum UMAC_QUEUE_NUM {
+	WLAN_AC_BK = 0,
+	WLAN_AC_BE,
+	WLAN_AC_VI,
+	WLAN_AC_VO,
+	WLAN_AC_BCN,
+	WLAN_AC_MAX_CNT
+};
+
+struct umac_event_tx_done {
+	struct host_mac_msg_hdr hdr;
+
+	unsigned char pdout_voltage;
+	/* frame_status -
+	 * 0 - success
+	 * 1 - discarded due to retry limit exceeded
+	 * 2 - discarded due to msdu lifetime expiry
+	 * 3 - discarded due to encryption key not available
+	 */
+#define TX_DONE_STAT_SUCCESS (0)
+#define TX_DONE_STAT_ERR_RETRY_LIM (1)
+#define TX_DONE_STAT_MSDU_LIFETIME (2)
+#define TX_DONE_STAT_KEY_NOT_FOUND (3)
+#define TX_DONE_STAT_DISCARD (4)
+#define TX_DONE_STAT_DISCARD_BCN (5)
+	unsigned char frm_status[MAX_TX_CMDS];
+	unsigned char retries_num[MAX_TX_CMDS];
+	/* rate = Units of 500 Kbps or mcs index = 0 to 7*/
+	unsigned char rate[MAX_TX_CMDS];
+	unsigned char queue;
+	unsigned int descriptor_id;
+	unsigned char reserved[12];
+} __packed;
+
+struct umac_event_ch_prog_complete {
+	struct host_mac_msg_hdr hdr;
+} __packed;
+
+struct umac_event_noa {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+	unsigned char vif_addr[ETH_ALEN];
+
+	/* 1 indicates NoA feature is active
+	 * 0 indicates NoA feature is not active
+	 */
+	unsigned int noa_active;
+#define ABSENCE_START 0 /* Indicates AP is absent */
+#define ABSENCE_STOP 1 /* Indicates AP is present */
+	unsigned int ap_present;
+} __packed;
+
+struct umac_event_mib_stats {
+	struct host_mac_msg_hdr hdr;
+	unsigned int ed_cnt;
+	unsigned int mpdu_cnt;
+	unsigned int ofdm_crc32_pass_cnt;
+	unsigned int ofdm_crc32_fail_cnt;
+	unsigned int dsss_crc32_pass_cnt;
+	unsigned int dsss_crc32_fail_cnt;
+	unsigned int mac_id_pass_cnt;
+	unsigned int mac_id_fail_cnt;
+	unsigned int ofdm_corr_pass_cnt;
+	unsigned int ofdm_corr_fail_cnt;
+	unsigned int dsss_corr_pass_cnt;
+	unsigned int dsss_corr_fail_cnt;
+	unsigned int ofdm_s2l_fail_cnt;
+	unsigned int lsig_fail_cnt;
+	unsigned int htsig_fail_cnt;
+	unsigned int vhtsiga_fail_cnt;
+	unsigned int vhtsigb_fail_cnt;
+	unsigned int nonht_ofdm_cnt;
+	unsigned int nonht_dsss_cnt;
+	unsigned int mm_cnt;
+	unsigned int gf_cnt;
+	unsigned int vht_cnt;
+	unsigned int aggregation_cnt;
+	unsigned int non_aggregation_cnt;
+	unsigned int ndp_cnt;
+	unsigned int ofdm_ldpc_cnt;
+	unsigned int ofdm_bcc_cnt;
+	unsigned int midpacket_cnt;
+	unsigned int dsss_sfd_fail_cnt;
+	unsigned int dsss_hdr_fail_cnt;
+	unsigned int dsss_short_preamble_cnt;
+	unsigned int dsss_long_preamble_cnt;
+	unsigned int sifs_event_cnt;
+	unsigned int cts_cnt;
+	unsigned int ack_cnt;
+	unsigned int sifs_no_resp_cnt;
+	unsigned int unsupported_cnt;
+	unsigned int l1_corr_fail_cnt;
+	unsigned int phy_stats_reserved22;
+	unsigned int phy_stats_reserved23;
+	unsigned int phy_stats_reserved24;
+	unsigned int phy_stats_reserved25;
+	unsigned int phy_stats_reserved26;
+	unsigned int phy_stats_reserved27;
+	unsigned int phy_stats_reserved28;
+	unsigned int phy_stats_reserved29;
+	unsigned int phy_stats_reserved30;
+	/*Tx Stats*/
+	unsigned int tx_pkts_from_lmac;
+	unsigned int tx_pkts_tx2tx;
+	unsigned int tx_pkts_from_rx;
+	unsigned int tx_pkts_ofdm;
+
+	unsigned int tx_pkts_dsss;
+	unsigned int tx_pkts_reached_end_of_fsm;
+	unsigned int tx_unsupported_modulation;
+	unsigned int tx_latest_pkt_from_lmac_or_sifs;
+
+	unsigned int tx_abort_bt_confirm_cnt;       /* Tx abort due to BT
+						     * confirm at the start of
+						     * Txn
+						     */
+	unsigned int tx_abort_txstart_timeout_cnt;  /* Tx abort due to Tx start
+						     * time-out
+						     */
+	unsigned int tx_abort_mid_bt_cnt;           /* Tx abort due to BT during
+						     * WLAN txn
+						     */
+	unsigned int tx_abort_dac_underrun_cnt;     /* Tx abort due to DAC
+						     * under-run only
+						     */
+	unsigned int tx_ofdm_symbols_master;
+	unsigned int tx_ofdm_symbols_slave1;
+	unsigned int tx_ofdm_symbols_slave2;
+	unsigned int tx_dsss_symbols;
+	unsigned int cts_received_mcp_cnt;
+} __packed;
+
+
+struct umac_event_mac_stats {
+	struct host_mac_msg_hdr hdr;
+	/* TX related */
+	unsigned int tx_cmd_cnt; /* Num of TX commands received from host */
+	unsigned int tx_done_cnt; /* Num of Tx done events sent to host */
+	unsigned int tx_edca_trigger_cnt; /* Num of times EDCA engine was
+					   * triggered
+					   */
+	unsigned int tx_edca_isr_cnt; /* Num of times EDCA ISR was generated */
+	unsigned int tx_start_cnt; /* Num of TX starts to MCP */
+	unsigned int tx_abort_cnt; /* Num of TX aborts detected */
+	unsigned int tx_abort_isr_cnt;/* Num of TX aborts received from MCP */
+	unsigned int tx_underrun_cnt; /* Num of under-runs */
+	unsigned int tx_rts_cnt; /* Num of RTS frames Tx’d */
+	unsigned int tx_ampdu_cnt; /* Num of AMPDU’s tx’d –incremented by
+				    * 1 for each A-MPDU (consisting of one or
+				    * more MPDUs)
+				    */
+	unsigned int tx_mpdu_cnt; /* Num of MPDU’s tx’d – incremented by 1
+				   * for MPDU (1 for each A-MPDU subframe)
+				   */
+	/* RX related */
+	unsigned int rx_isr_cnt; /* Num of RX ISRs */
+	unsigned int rx_ack_cts_to_cnt; /* Num of timeouts ACK */
+	unsigned int rx_cts_cnt; /* Num of CTS frames received */
+	unsigned int rx_ack_resp_cnt; /* Num of Ack frames received */
+	unsigned int rx_ba_resp_cnt; /* Num of BA frames received */
+	unsigned int rx_fail_in_ba_bitmap_cnt; /* Num of BA frames indicating at
+						* least one failure in the
+						* BA bitmap
+						*/
+	unsigned int rx_circular_buffer_free_cnt; /* Num of entries returned to
+						   * RX circular buffers
+						   */
+	unsigned int rx_mic_fail_cnt; /* Num of MIC failures */
+	/* HAL related */
+	unsigned int hal_cmd_cnt; /* Num of commands received by HAL from the
+				   * host
+				   */
+	unsigned int hal_event_cnt; /* Num of events sent by HAL to the host */
+	unsigned int hal_ext_ptr_null_cnt; /* Num of packets dropped due to lack
+					    * of Ext Ram buffers from host
+					    */
+
+} __packed;
+
+
+struct wlan_rx_pkt {
+	struct host_mac_msg_hdr hdr;
+	/* MPDU/MSDU payload in bytes */
+	unsigned int pkt_length;
+	/* bit[8] = 0 - legacy data rate
+	 *	  = 1 - MCS index
+	 */
+	unsigned char rate_or_mcs;
+	/* RSSI in dbm */
+	unsigned char rssi;
+	/* packet status
+	 * 1 - mic failed
+	 * 0 - mic succes reserved for non encryped packet\
+	 */
+#define RX_MIC_SUCCESS 0 /* No MIC error in frame */
+#define RX_MIC_FAILURE_TKIP 1 /* TKIP MIC error in frame */
+#define RX_MIC_FAILURE_CCMP 2 /* CCMP MIC error in frame */
+	unsigned char rx_pkt_status;
+
+#define ENABLE_GREEN_FIELD 0x01
+#define ENABLE_CHNL_WIDTH_40MHZ 0x02
+#define ENABLE_SGI 0x04
+#define ENABLE_11N_FORMAT 0x08
+#define ENABLE_VHT_FORMAT 0x10
+#define ENABLE_CHNL_WIDTH_80MHZ 0x20
+
+	unsigned char rate_flags;
+	unsigned char nss;
+	unsigned char num_sts;
+	unsigned char timestamp[8];
+	unsigned char stbc_enabled;
+	unsigned char ldpc_enabled;
+	unsigned char link_margin;
+	unsigned char channel;
+	unsigned char reserved[14];
+	/*payload bytes */
+	unsigned char payload[0];
+} __packed;
+
+#ifdef CONFIG_PM
+enum UMAC_PS_ECON_WAKE_TRIG {
+	TRIG_PKT_RCV,
+	TRIG_DISCONNECT
+};
+
+struct umac_event_ps_econ_wake {
+	struct host_mac_msg_hdr hdr;
+	enum UMAC_PS_ECON_WAKE_TRIG trigger;
+} __packed;
+
+struct umac_event_ps_econ_cfg_complete {
+	struct host_mac_msg_hdr hdr;
+	unsigned char status; /* SUCCESS/FAILURE */
+} __packed;
+#endif
+
+
+
+enum UMAC_CMD_TAG {
+	UMAC_CMD_RESET = 0,
+	UMAC_CMD_SCAN,
+	UMAC_CMD_SCAN_ABORT,
+	UMAC_CMD_CONNECT,
+	UMAC_CMD_SETKEY,
+	UMAC_CMD_SET_DEFAULTKEY,
+	UMAC_CMD_REKEY_DATA,
+	UMAC_CMD_TX,
+	UMAC_CMD_MGMT_TX,
+	UMAC_CMD_FRAG,
+	UMAC_CMD_TX_POWER,
+	UMAC_CMD_RATE,
+	UMAC_CMD_DISCONNECT,
+	UMAC_CMD_PS,
+	UMAC_CMD_PS_ECON_CFG,
+	UMAC_CMD_VIF_CTRL,
+	UMAC_CMD_SET_BEACON,
+	UMAC_CMD_SET_MODE,
+	UMAC_CMD_BA_SESSION_INFO,
+	UMAC_CMD_MCST_ADDR_CFG,
+	UMAC_CMD_MCST_FLTR_CTRL,
+	UMAC_CMD_VHT_BEAMFORM_CTRL,
+	UMAC_CMD_ROC_CTRL,
+	UMAC_CMD_CHANNEL,
+	UMAC_CMD_VIF_CFG,
+	UMAC_CMD_STA,
+	UMAC_CMD_TXQ_PARAMS,
+	UMAC_CMD_MIB_STATS,
+	UMAC_CMD_PHY_STATS,
+	UMAC_CMD_NW_SELECTION,
+	UMAC_CMD_AUX_ADC_CHAIN_SEL,
+	UMAC_CMD_DETECT_RADAR,
+	UMAC_CMD_ENABLE_TX,
+	UMAC_CMD_DISCARD_PKTS,
+	UMAC_CMD_MEASURE,
+	UMAC_CMD_BT_INFO,
+	UMAC_CMD_CLEAR_STATS
+};
+
+enum UMAC_EVENT_TAG {
+	UMAC_EVENT_RX = 0,
+	UMAC_EVENT_TX_DONE,
+	UMAC_EVENT_DISCONNECTED,
+	UMAC_EVENT_CONNECT_RESULT,
+	UMAC_EVENT_MIC_FAIL,
+	UMAC_EVENT_SCAN_COMPLETE,
+	UMAC_EVENT_SCAN_ABORT_COMPLETE,
+	UMAC_EVENT_MGMT_FRAME,
+	UMAC_EVENT_RESET_COMPLETE,
+	UMAC_EVENT_RSSI,
+	UMAC_EVENT_STA_INFO,
+	UMAC_EVENT_REKEY_DATA,
+	UMAC_EVENT_MIB_STAT,
+	UMAC_EVENT_PHY_STAT,
+	UMAC_EVENT_NW_FOUND,
+	UMAC_EVENT_NOA,
+	UMAC_EVENT_CTRL_POOL_ACK,
+	UMAC_EVENT_COMMAND_PROC_DONE,
+	UMAC_EVENT_CH_PROG_DONE,
+	UMAC_EVENT_PS_ECON_CFG_DONE,
+	UMAC_EVENT_PS_ECON_WAKE,
+	UMAC_EVENT_MAC_STATS,
+	UMAC_EVENT_RF_CALIB_DATA,
+	UMAC_EVENT_RADAR_DETECTED,
+	UMAC_EVENT_MSRMNT_COMPLETE,
+};
+
+enum CONNECT_RESULT_TAG {
+	CONNECT_SUCCESS = 0,
+	CONNECT_UNSPECIFIED_FAILURE,
+	CONNECT_AUTH_FAILURE,
+	CONNECT_AUTH_TIMEOUT,
+	CONNECT_ASSOC_TIMEOUT,
+	CONNECT_ASSOC_FAILURE,
+	CONNECT_START_IBSS
+};
+
+
+/* Commands */
+struct cmd_tx_ctrl {
+	struct host_mac_msg_hdr hdr;
+	/* VIF nuber this packet belongs to */
+	unsigned char if_index;
+	/* Queue no will be VO, VI, BE, BK and BCN */
+	unsigned char queue_num;
+
+	unsigned int descriptor_id;
+
+	/* number of frames in tx descriptors */
+	unsigned int num_frames_per_desc;
+
+	/*packet lengths of frames*/
+	unsigned int pkt_length[MAX_TX_CMDS];
+
+	/* If more number of frames buffered at UMAC */
+	unsigned char more_frms;
+
+	/* If this field is set for any packet,
+	 * need to be transmit even though TX has been disabled
+	 */
+	unsigned int force_tx;
+
+	unsigned char num_rates;
+
+#define USE_PROTECTION_NONE 0
+#define USE_PROTECTION_RTS 1
+#define USE_PROTECTION_CTS2SELF 2
+	unsigned char rate_protection_type[4];
+
+#define USE_SHORT_PREAMBLE 0
+#define DONT_USE_SHORT_PREAMBLE 1
+	unsigned char rate_preamble_type[4];
+
+	unsigned char rate_retries[4];
+
+#define MARK_RATE_AS_MCS_INDEX 0x80
+#define MARK_RATE_AS_RATE 0x00
+	unsigned char rate[4];
+
+#define ENABLE_GREEN_FIELD 0x01
+#define ENABLE_CHNL_WIDTH_40MHZ 0x02
+#define ENABLE_SGI 0x04
+#define ENABLE_11N_FORMAT 0x08
+#define ENABLE_VHT_FORMAT 0x10
+#define ENABLE_CHNL_WIDTH_80MHZ 0x20
+
+	unsigned char rate_flags[4];
+	unsigned char num_spatial_streams[4];
+	unsigned char stbc_enabled;
+	unsigned char bcc_or_ldpc;
+
+#define AMPDU_AGGR_ENABLED 0x00000001
+#define AMPDU_AGGR_DISABLED 0x00000000
+	unsigned char aggregate_mpdu;
+
+	unsigned char force_encrypt;
+
+#define MAC_HDR_SIZE 52
+	unsigned int pkt_gram_payload_len;
+	/* It will be of the form It [MAX_TX_CMDS][54]
+	 * using dynamic because max stack size is 1024 bytes
+	 */
+	unsigned char gram_payload[0];
+} __packed;
+
+struct bgscan_params {
+	unsigned int enabled;
+	unsigned char channel_list[50];
+	unsigned char channel_flags[50];
+	unsigned int scan_intval;
+	unsigned int channel_dur;
+	unsigned int serv_channel_dur;
+	unsigned int num_channels;
+} __packed;
+
+struct cmd_reset {
+	struct host_mac_msg_hdr hdr;
+	#define LMAC_ENABLE 0
+	#define LMAC_DISABLE 1
+	unsigned int type;
+	int ed_sensitivity;
+	unsigned int auto_sensitivity;
+	unsigned char rf_params[RF_PARAMS_SIZE];
+	unsigned int include_rxmac_hdr;
+	struct bgscan_params bg_scan;
+	unsigned char num_spatial_streams;
+	unsigned int system_rev;
+	#define LMAC_MODE_NORMAL 0
+	#define LMAC_MODE_FTM 1
+	unsigned int lmac_mode;
+	unsigned int antenna_sel;
+} __packed;
+
+enum SCAN_TYPE_TAG {
+	PASSIVE = 0,
+	ACTIVE
+};
+
+struct ssid {
+	unsigned int len;
+	unsigned char ssid[MAX_SSID_LEN];
+} __packed;
+
+struct cmd_scan {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+	enum SCAN_TYPE_TAG type;
+
+	/* Total number of channels to scan; channel numbers will be
+	 * informed in channel array. if n_channel value is zero,
+	 * UMAC scans all possible channels.
+	 */
+	unsigned int n_channel;
+
+	/* Number of SSIDs to scan; ssid information will be in ssid array.
+	 * This is always >= 1. In case of wild card SSID, this value is 1 and
+	 * the ssid_len of the first entry in the SSID list should be specifie
+	 * as 0
+	 */
+	unsigned int n_ssids;
+	unsigned char channel_list[50];
+	unsigned char chan_max_power[50];
+	unsigned char chan_flags[50];
+	struct ssid ssids[MAX_NUM_SSIDS];
+	unsigned int p2p_probe;
+	unsigned int extra_ies_len;
+	unsigned char extra_ies[0];
+} __packed;
+
+struct cmd_scan_abort {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+} __packed;
+
+struct cmd_nw_selection {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+	unsigned int p2p_selection;
+	struct ssid ssid;
+	unsigned int scan_req_ie_len;
+	unsigned int scan_resp_ie_len;
+	unsigned char scan_req_ie[200];
+	unsigned char scan_resp_ie[200];
+} __packed;
+
+struct cmd_set_mode {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+	unsigned int type;
+} __packed;
+
+struct cmd_setkey {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+#define KEY_CTRL_ADD 0
+#define KEY_CTRL_DEL 1
+	unsigned int ctrl;
+#define KEY_TYPE_UCAST 0
+#define KEY_TYPE_BCAST 1
+	unsigned int key_type;
+
+#define CIPHER_TYPE_WEP40 0
+#define CIPHER_TYPE_WEP104 1
+#define CIPHER_TYPE_TKIP 2
+#define CIPHER_TYPE_CCMP 3
+#define CIPHER_TYPE_WAPI 4
+	unsigned int cipher_type;
+	unsigned int key_id;
+	int key_len;
+	int rsc_len;
+	unsigned char mac_addr[ETH_ALEN];
+	unsigned char key[TOTAL_KEY_LEN];
+	unsigned char rsc[RX_SEQ_SIZE];
+} __packed;
+
+
+struct cmd_set_defaultkey {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+	unsigned int key_id;
+} __packed;
+
+struct cmd_set_rekey {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+	unsigned char kek[16];
+	unsigned char kck[16];
+	unsigned char replay_ctr[8];
+} __packed;
+
+struct cmd_frag_tag {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+	unsigned int frag_threshold;
+} __packed;
+
+struct cmd_tx_pwr {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+	int tx_pwr;
+} __packed;
+
+struct cmd_disconnect {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+	int reason_code;
+} __packed;
+
+struct cmd_rate {
+	struct host_mac_msg_hdr hdr;
+	int is_mcs;
+	int rate;
+} __packed;
+
+struct cmd_mcst_addr_cfg {
+	struct host_mac_msg_hdr hdr;
+	/* mcst_ctrl -
+	 * 0 -- ADD multicast address
+	 * 1 -- Remove multicast address
+	 */
+#define WLAN_MCAST_ADDR_ADD 0
+#define WLAN_MCAST_ADDR_REM 1
+	unsigned int op;
+	/* addr to add or delete..
+	 */
+	unsigned char mac_addr[6];
+} __packed;
+
+struct cmd_mcst_filter_ctrl {
+	struct host_mac_msg_hdr hdr;
+	/* ctrl -
+	 * 0 - disable multicast filtering in LMAC
+	 * 1 - enable multicast filtering in LMAC
+	 */
+#define MCAST_FILTER_DISABLE 0
+#define MCAST_FILTER_ENABLE 1
+	unsigned int ctrl;
+} __packed;
+
+struct cmd_vht_beamform {
+	struct host_mac_msg_hdr hdr;
+#define VHT_BEAMFORM_DISABLE 0
+#define VHT_BEAMFORM_ENABLE 1
+	unsigned int vht_beamform_status;
+	unsigned int vht_beamform_period;
+} __packed;
+
+struct cmd_roc {
+	struct host_mac_msg_hdr hdr;
+#define ROC_STOP 0
+#define ROC_START 1
+	unsigned int roc_status;
+	unsigned int roc_channel;
+	unsigned int roc_duration;
+
+} __packed;
+
+enum POWER_SAVE_TAG {
+	AWAKE = 0,
+	SLEEP
+};
+
+struct cmd_ps {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+	enum POWER_SAVE_TAG mode;
+} __packed;
+
+struct cmd_vifctrl {
+	struct host_mac_msg_hdr hdr;
+	/* if_ctrl -
+	 * 0 - add interface address
+	 * 1 - remove interface address
+	 */
+#define IF_ADD 1
+#define IF_REM 2
+
+	unsigned int if_ctrl;
+	unsigned int if_index;
+	/* Interface mode -
+	 * 0 - STA in infrastucture mode
+	 * 1 - STA in AD-HOC mode
+	 * 2 - AP
+	 */
+#define IF_MODE_STA_BSS 0
+#define IF_MODE_STA_IBSS 1
+#define IF_MODE_AP 2
+#define IF_MODE_INVALID 3
+
+	unsigned int mode;
+	unsigned char mac_addr[ETH_ALEN];
+} __packed;
+
+struct cmd_set_beacon {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+	unsigned int interval;
+	unsigned int dtim_period;
+	unsigned int len;
+	unsigned char mac_addr[6];
+	unsigned int channel;
+	unsigned char beacon_buf[0];
+} __packed;
+
+struct cmd_ht_ba {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+#define BLOCK_ACK_SESSION_STOP 0
+#define BLOCK_ACK_SESSION_START 1
+	unsigned int op;
+	unsigned int tid;
+	unsigned int ssn;
+	unsigned int policy;
+	/* vif address */
+	unsigned char vif_addr[ETH_ALEN];
+	/* peer address */
+	unsigned char peer_addr[ETH_ALEN];
+} __packed;
+
+struct cmd_channel {
+	struct host_mac_msg_hdr hdr;
+	/* channel bw
+	 * 0 - 20
+	 * 1 - 40
+	 * 2 - 80
+	 * 3 - 160
+	 */
+	unsigned int channel_bw;
+	unsigned int primary_ch_number;
+	/* center frequecny of total band, if toal band is contiguous.
+	 * First band center frequency For non contiguous bands,
+	 */
+	unsigned int channel_number1;
+	/* center frequecny of secondary band.
+	 * This is valid in 80+80 band set to zero for other cases
+	 */
+	unsigned int channel_number2;
+	/* 0 - 2.4ghz
+	 * 1 - 5ghz
+	 */
+	unsigned int freq_band;
+} __packed;
+
+struct cmd_vif_cfg {
+	struct host_mac_msg_hdr hdr;
+
+	/* Bitmap indicating whether value is changed or not */
+#define BASICRATES_CHANGED (1<<0)
+#define SHORTSLOT_CHANGED (1<<1)
+#define POWERSAVE_CHANGED (1<<2) /* to be removed */
+#define UAPSDTYPE_CHANGED (1<<3) /* to be removed */
+#define ATIMWINDOW_CHANGED (1<<4)
+#define AID_CHANGED (1<<5)
+#define CAPABILITY_CHANGED (1<<6)
+#define SHORTRETRY_CHANGED (1<<7)
+#define LONGRETRY_CHANGED (1<<8)
+#define BSSID_CHANGED (1<<9)
+#define RCV_BCN_MODE_CHANGED (1<<10)
+#define BCN_INT_CHANGED (1<<11)
+#define DTIM_PERIOD_CHANGED (1<<12)
+#define SMPS_CHANGED (1<<13)
+#define CONNECT_STATE_CHANGED (1<<14)
+#define OP_CHAN_CHANGED (1<<15)
+
+	unsigned int changed_bitmap;
+
+	/* bitmap of supported basic rates
+	 */
+	unsigned int basic_rate_set;
+
+	/* slot type -
+	 * 0 - long slot
+	 * 1 - short slot
+	 */
+	unsigned int use_short_slot;
+
+	/* ATIM window */
+	unsigned int atim_window;
+
+	unsigned int aid;
+
+	unsigned int capability;
+
+	unsigned int short_retry;
+
+	unsigned int long_retry;
+
+#define RCV_ALL_BCNS 0
+#define RCV_ALL_NETWORK_ONLY 1
+#define RCV_NO_BCNS 2
+
+	unsigned int bcn_mode;
+
+	unsigned char dtim_period;
+
+	unsigned int beacon_interval;
+
+	/* index of the intended interface */
+	unsigned int if_index;
+	unsigned char vif_addr[ETH_ALEN];
+
+	/* bssid of interface */
+	unsigned char bssid[ETH_ALEN];
+
+	/* SMPS Info
+	 *
+	 * bit0 - 0 - Disabled, 1 - Enabled
+	 * bit1 - 0 - Static,   1 - Dynamic
+	 *
+	 */
+#define SMPS_ENABLED BIT(0)
+#define SMPS_MODE BIT(1)
+	unsigned char smps_info;
+
+#define STA_CONN 0
+#define STA_DISCONN 1
+	unsigned char connect_state;
+	unsigned char op_channel;
+} __packed;
+
+struct cmd_sta {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+#define ADD 0
+#define REM 1
+	unsigned int op;
+#define STA_NUM_BANDS 2
+	unsigned int supp_rates[STA_NUM_BANDS];
+/*HT Info */
+	unsigned int ht_cap; /* use IEEE80211_HT_CAP_ */
+	unsigned int ht_supported;
+	unsigned int vht_cap; /* use IEEE80211_VHT_CAP_ */
+	unsigned int vht_supported;
+	unsigned int ampdu_factor;
+	unsigned int ampdu_density;
+	unsigned int rx_highest;
+	unsigned int tx_params;
+#define HT_MCS_MASK_LEN 10
+	unsigned char rx_mask[HT_MCS_MASK_LEN];
+	unsigned char addr[ETH_ALEN];
+	unsigned char dot11_mode;
+	unsigned char no_of_streams;
+	unsigned char preamble;
+	unsigned char stbc_enable;
+	unsigned char ldpc_enable;
+	unsigned char guard_interval;
+	unsigned char aggregation;
+	unsigned char tid;
+	unsigned char band_width;
+} __packed;
+
+struct cmd_txq_params {
+	struct host_mac_msg_hdr hdr;
+	unsigned int queue_num;
+	unsigned int aifsn;
+	unsigned int txop;
+	unsigned int cwmin;
+	unsigned int cwmax;
+	/* power save mode -
+	 * 0 - indicates legacy mode powersave, 1 - indicates UAPSD for the
+	 * corresponding AC.
+	 */
+	unsigned int uapsd;
+	unsigned int if_index;
+	unsigned char vif_addr[ETH_ALEN];
+} __packed;
+
+struct cmd_aux_adc_chain_sel {
+	struct host_mac_msg_hdr hdr;
+#define AUX_ADC_CHAIN1	1
+#define AUX_ADC_CHAIN2	2
+	unsigned int chain_id;
+} __packed;
+
+
+/* DFS SUPPORT */
+/* Command to start/stop Radar detection operation */
+struct cmd_detect_radar {
+	struct host_mac_msg_hdr hdr;
+	/* 1 - Radar detection operation to be started
+	 * 0 - Radar detection operation to be stopped
+	 */
+#define RADAR_DETECT_OP_START 1
+#define RADAR_DETECT_OP_STOP 0
+	unsigned int radar_detect_op;
+} __packed;
+
+/* Command to enable TX.which would have been disabled previously.*/
+struct umac_cmd_tx_enable {
+	struct host_mac_msg_hdr hdr;
+} __packed;
+
+/* Command to discard all packets in TX queue */
+struct cmd_discard_pkts {
+	struct host_mac_msg_hdr hdr;
+} __packed;
+
+/* Command to do measurement on a channel
+ * start_time	: when to start the measurement.
+ * msr_dur	: How long measurement to be carried out.
+ */
+struct cmd_msrmnt_start {
+	struct host_mac_msg_hdr hdr;
+	unsigned char start_time[8];
+	unsigned short msr_dur;
+} __packed;
+
+
+/* Events */
+
+struct nw_found_event {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+	struct ssid ssid;
+} __packed;
+
+struct host_event_mgmt_rx {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+	int rssi;
+	unsigned int rate;
+	unsigned int padding;
+} __packed;
+
+struct host_event_command_complete {
+	struct host_mac_msg_hdr hdr;
+} __packed;
+
+struct bssres {
+	unsigned int channel;
+	int rssi;
+	unsigned int frame_len;
+	unsigned char frame_buf[0];
+} __packed;
+
+struct host_event_scanres {
+	struct host_mac_msg_hdr hdr;
+	int if_index;
+	unsigned int scanres_len; /* This will include total length of
+				   * scanresult, including it's own length
+				   */
+	unsigned int status_code;
+	unsigned int no_of_bss;
+	unsigned int more_results; /* 0 - No more results, 1- Moreresults */
+	unsigned char bss_res[0]; /* One or more elements of type bssres_t */
+} __packed;
+
+struct host_event_connect_result {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+	enum CONNECT_RESULT_TAG result_code;
+	unsigned int aid;
+	unsigned int cap_info;
+	int ht_supported;
+	unsigned short ht_cap_info;
+	int vht_supported;
+	unsigned short vht_cap_info;
+	unsigned int qos_capability;
+	unsigned int wmm_acm;
+	unsigned int channel;
+	unsigned char bssid[ETH_ALEN];
+	unsigned int ie_len;
+	unsigned char ie[MAX_IE_LEN];
+	struct bssres bss_frame;
+} __packed;
+
+struct host_event_rssi {
+	struct host_mac_msg_hdr hdr;
+	int if_index;
+	int rssi;
+} __packed;
+
+struct host_event_disconnect {
+	struct host_mac_msg_hdr hdr;
+	int if_index;
+#define REASON_DEAUTH 1
+#define REASON_AUTH_FAILURE 2
+#define REASON_NW_LOST 3
+#define REASON_AUTH_TIMEOUT 4
+#define REASON_TX_TOKEN_NOTAVAIL 5
+#define REASON_ASSOC_TIMEOUT 6
+	unsigned int reason_code;
+	unsigned char mac_addr[ETH_ALEN];
+} __packed;
+
+struct host_event_reset_complete {
+	struct host_mac_msg_hdr hdr;
+	unsigned int cap;
+	unsigned int ht_supported;
+	unsigned int ampdu_factor;
+	unsigned int ampdu_density;
+#define HT_MCS_MASK_LEN 10
+	unsigned int rx_mask[HT_MCS_MASK_LEN];
+	unsigned int rx_highest;
+	unsigned int tx_params;
+	char version[6];
+} __packed;
+
+struct host_event_rekey_data {
+	struct host_mac_msg_hdr hdr;
+	unsigned int if_index;
+	unsigned int cipher;
+	unsigned int key_idx;
+	unsigned int key_len;
+	unsigned int rsc_len;
+	unsigned char rsc[8];
+	unsigned char key[MAX_KEY_LEN];
+} __packed;
+
+struct host_event_phy_stats {
+	struct host_mac_msg_hdr hdr;
+	unsigned int phy_stats[64];
+} __packed;
+
+/* DFS SUPPORT*/
+/* Event to be generated on radar detection */
+struct host_event_radar_detected {
+	struct host_mac_msg_hdr hdr;
+	int freq;
+} __packed;
+
+/* Event generated on measurement completion with measurement status */
+struct host_event_msrmnt_complete {
+	struct host_mac_msg_hdr hdr;
+	/* MSR MNT STAUTS -
+	 * For bit representation Refer 7.3.2.22.1 of Std 802.11h-2003
+	 */
+#define UMAC_EVENT_MSRMNT_STATUS_BSS (0x01)
+#define UMAC_EVENT_MSRMNT_STATUS_OFDM_PREAMBLE (0x02)
+#define UMAC_EVENT_MSRMNT_STATUS_UNIDENTIFIED_SIGNAL (0x04)
+#define UMAC_EVENT_MSRMNT_STATUS_RADAR_SIGNAL (0x08)
+#define UMAC_EVENT_MSRMNT_STATUS_NO_MSRMNT (0x10)
+#define UMAC_EVENT_MSRMNT_STATUS_LATE (0x20)
+#define UMAC_EVENT_MSRMNT_STATUS_INCAPABLE (0x40)
+#define UMAC_EVENT_MSRMNT_STATUS_REFUSE (0x80)
+	unsigned int msrmnt_status;
+} __packed;
+
+
+struct umac_event_ch_switch_complete {
+	struct host_mac_msg_hdr hdr;
+	int status;
+} __packed;
+
+struct umac_event_rf_calib_data {
+	struct host_mac_msg_hdr hdr;
+	unsigned int  rf_calib_data_length;
+	unsigned char rf_calib_data[0];
+} __packed;
+
+struct cmd_bt_info {
+	struct host_mac_msg_hdr hdr;
+#define BT_STATE_OFF 0
+#define BT_STATE_ON  1
+	unsigned int bt_state;
+} __packed;
+
+#endif /*_UCCP420HOST_UMAC_IF_H_*/
diff --git a/drivers/net/wireless/uccp420wlan/inc/umac_if.h b/drivers/net/wireless/uccp420wlan/inc/umac_if.h
new file mode 100644
index 0000000..3676c63
--- /dev/null
+++ b/drivers/net/wireless/uccp420wlan/inc/umac_if.h
@@ -0,0 +1,286 @@
+/*HEADER**********************************************************************
+******************************************************************************
+***
+*** Copyright (c) 2011, 2012, 2013, 2014 Imagination Technologies Ltd.
+*** All rights reserved
+***
+*** This program is free software; you can redistribute it and/or
+*** modify it under the terms of the GNU General Public License
+*** as published by the Free Software Foundation; either version 2
+*** of the License, or (at your option) any later version.
+***
+*** This program is distributed in the hope that it will be useful,
+*** but WITHOUT ANY WARRANTY; without even the implied warranty of
+*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*** GNU General Public License for more details.
+***
+*** You should have received a copy of the GNU General Public License
+*** along with this program; if not, write to the Free Software
+*** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+*** USA.
+***
+*** File Name  : lmac_if.h
+***
+*** File Description:
+*** This file contains the helper functions exported by LMAC interface module
+*** for sending commands and receiving events from the LMAC
+*****************************************************************************
+*END**************************************************************************/
+
+#ifndef _UCCP420WLAN_UMAC_IF_H_
+#define _UCCP420WLAN_UMAC_IF_H_
+#include <linux/skbuff.h>
+#include "hal.h"
+#include "host_umac_if.h"
+
+struct umac_key {
+	unsigned char *peer_mac;
+	unsigned char *tx_mic;
+	unsigned char *rx_mic;
+	unsigned char *key;
+};
+
+struct ssid_desc {
+	unsigned char ssid[MAX_SSID_LEN];
+	unsigned char ssid_len;
+};
+
+struct scan_req {
+	unsigned int n_channels;
+	int n_ssids;
+	unsigned int ie_len;
+	unsigned char ie[256];
+	unsigned int p2p_probe;
+	/*TODO: Make this a structure*/
+	unsigned short center_freq[50];
+	unsigned char freq_max_power[50];
+	unsigned char chan_flags[50];
+	struct ssid_desc ssids[MAX_NUM_SSIDS];
+};
+
+struct peer_sta_info {
+	unsigned int ht_cap;
+	unsigned int ht_supported;
+	unsigned int ampdu_factor;
+	unsigned int ampdu_density;
+	unsigned int vht_cap;
+	unsigned int vht_supported;
+	unsigned int rx_highest;
+	unsigned int tx_params;
+	unsigned int supp_rates[STA_NUM_BANDS];
+	unsigned char addr[ETH_ALEN];
+	unsigned char rx_mask[HT_MCS_MASK_LEN];
+	unsigned char uapsd_queues;
+};
+
+/*commands*/
+extern int uccp420wlan_scan(int index,
+			    struct scan_req *req);
+
+extern int uccp420wlan_scan_abort(int index);
+
+extern int uccp420wlan_proc_tx(void);
+
+extern int uccp420wlan_prog_tx(unsigned int queue,
+			       unsigned int more_data,
+			       unsigned int tokenid);
+
+extern int uccp420wlan_sta_add(int index,
+			       struct peer_sta_info *sta);
+
+extern int uccp420wlan_sta_remove(int index,
+				  struct peer_sta_info *sta);
+
+extern int uccp420wlan_set_rate(int rate,
+				int mcs);
+
+extern int uccp420wlan_prog_reset(unsigned int reset_type,
+				  unsigned int lmac_mode);
+
+extern int uccp420wlan_prog_vif_ctrl(int index,
+				     unsigned char *vif_addr,
+				     unsigned int  vif_type,
+				     unsigned int  add_vif);
+
+extern int uccp420wlan_prog_vif_basic_rates(int index,
+					    unsigned char *vif_addr,
+					    unsigned int basic_rate_set);
+
+extern int uccp420wlan_prog_vif_short_slot(int index,
+					   unsigned char *vif_addr,
+					   unsigned int use_short_slot);
+
+extern int uccp420wlan_prog_vif_atim_window(int index,
+					    unsigned char *vif_addr,
+					    unsigned int atim_window);
+
+extern int uccp420wlan_prog_vif_aid(int index,
+				    unsigned char *vif_addr,
+				    unsigned int aid);
+
+extern int uccp420wlan_prog_vif_op_channel(int index,
+					   unsigned char *vif_addr,
+					   unsigned char op_channel);
+
+extern int uccp420wlan_prog_vif_conn_state(int index,
+					      unsigned char *vif_addr,
+					      unsigned int state);
+
+extern int uccp420wlan_prog_vif_assoc_cap(int index,
+					  unsigned char *vif_addr,
+					  unsigned int caps);
+
+extern int uccp420wlan_prog_vif_beacon_int(int index,
+					   unsigned char *vif_addr,
+					   unsigned int bcn_int);
+
+extern int uccp420wlan_prog_vif_dtim_period(int index,
+					    unsigned char *vif_addr,
+					    unsigned int dtim_period);
+
+extern int uccp420wlan_prog_vif_apsd_type(int index,
+					  unsigned char *vif_addr,
+					  unsigned int uapsd_type);
+
+extern int uccp420wlan_prog_long_retry(int index,
+				       unsigned char *vif_addr,
+				       unsigned int long_retry);
+
+extern int uccp420wlan_prog_short_retry(int index,
+					unsigned char *vif_addr,
+					unsigned int short_retry);
+
+extern int uccp420wlan_prog_vif_bssid(int index,
+				      unsigned char *vif_addr,
+				      unsigned char *bssid);
+
+extern int uccp420wlan_prog_vif_smps(int index,
+				     unsigned char *vif_addr,
+				     unsigned char smps_mode);
+
+extern int uccp420wlan_prog_ps_state(int index,
+				     unsigned char *vif_addr,
+				     unsigned int powersave_state);
+
+extern int uccp420wlan_prog_global_cfg(unsigned int rx_msdu_lifetime,
+				       unsigned int tx_msdu_lifetime,
+				       unsigned int sensitivity,
+				       unsigned int dyn_ed_enabled,
+				       unsigned char *rf_params);
+
+extern int uccp420wlan_prog_txpower(unsigned int txpower);
+
+extern int uccp420wlan_prog_btinfo(unsigned int bt_state);
+
+extern int uccp420wlan_prog_mcast_addr_cfg(unsigned char  *mcast_addr,
+					   unsigned int add_filter);
+
+extern int uccp420wlan_prog_mcast_filter_control(unsigned int
+						 enable_mcast_filtering);
+
+extern int uccp420wlan_prog_rcv_bcn_mode(unsigned int  bcn_rcv_mode);
+extern int uccp420wlan_prog_aux_adc_chain(unsigned int chain_id);
+extern int uccp420wlan_prog_txq_params(int index,
+				       unsigned char *vif_addr,
+				       unsigned int queue,
+				       unsigned int aifs,
+				       unsigned int txop,
+				       unsigned int cwmin,
+				       unsigned int cwmax,
+				       unsigned int uapsd);
+
+extern int uccp420wlan_prog_channel(unsigned int prim_ch,
+				    unsigned int ch_no1,
+				    unsigned int ch_no2,
+				    unsigned int ch_width,
+				    unsigned int freq_band);
+
+extern int uccp420wlan_prog_peer_key(int index,
+				     unsigned char *vif_addr,
+				     unsigned int op,
+				     unsigned int key_id,
+				     unsigned int key_type,
+				     unsigned int cipher_type,
+				     struct umac_key *key);
+
+extern int uccp420wlan_prog_if_key(int   index,
+				   unsigned char *vif_addr,
+				   unsigned int op,
+				   unsigned int key_id,
+				   unsigned int cipher_type,
+				   struct umac_key *key);
+
+extern int uccp420wlan_prog_mib_stats(void);
+
+extern int uccp420wlan_prog_clear_stats(void);
+
+extern int uccp420wlan_prog_phy_stats(void);
+
+extern int uccp420wlan_prog_ba_session_data(unsigned int op,
+					    unsigned short tid,
+					    unsigned short *ssn,
+					    unsigned short ba_policy,
+					    unsigned char *sta_addr,
+					    unsigned char *peer_add);
+
+extern int uccp420wlan_prog_vht_bform(unsigned int vht_beamform_status,
+					 unsigned int vht_beamform_period);
+
+extern int uccp420wlan_prog_roc(unsigned int roc_status,
+				unsigned int roc_channel,
+				unsigned int roc_duration);
+
+#ifdef CONFIG_PM
+extern int uccp420wlan_prog_econ_ps_state(int if_index,
+					  unsigned int ps_state);
+#endif
+
+/* Events  */
+extern void uccp420wlan_scan_complete(void *context,
+				      struct host_event_scanres *scan_res,
+				      unsigned char *skb,
+				      unsigned int len);
+
+extern void uccp420wlan_reset_complete(char *lmac_version,
+				       void *context);
+
+extern void uccp420wlan_rf_calib_data(struct umac_event_rf_calib_data *rf_data,
+				      void *context);
+
+extern void uccp420wlan_proc_tx_complete(struct umac_event_tx_done *txdone,
+				    void *context);
+
+extern void uccp420wlan_tx_complete(struct umac_event_tx_done *txdone,
+				    void *context);
+
+extern void uccp420wlan_rx_frame(struct sk_buff *skb,
+				 void *context);
+
+extern void uccp420wlan_mib_stats(struct umac_event_mib_stats *mib_stats,
+				  void *context);
+
+extern void uccp420wlan_mac_stats(struct umac_event_mac_stats *mac_stats,
+				  void *context);
+
+extern void uccp420wlan_noa_event(int event,
+				  struct umac_event_noa *noa_event,
+				  void *context,
+				  struct sk_buff *skb);
+
+extern void uccp420wlan_ch_prog_complete(int event,
+					 struct umac_event_ch_prog_complete *ch,
+					 void *context);
+
+/* Init/Deinit */
+
+extern int uccp420wlan_lmac_if_init(void *context,
+				    const char *name);
+
+extern void uccp420wlan_lmac_if_deinit(void);
+
+extern void uccp420_lmac_if_free_outstnding(void);
+
+#endif /* _UCCP420WLAN_UMAC_IF_H_ */
+
+/* EOF */
+
diff --git a/drivers/net/wireless/uccp420wlan/inc/utils.h b/drivers/net/wireless/uccp420wlan/inc/utils.h
new file mode 100644
index 0000000..f5fb5e6
--- /dev/null
+++ b/drivers/net/wireless/uccp420wlan/inc/utils.h
@@ -0,0 +1,46 @@
+/*
+ * File Name  : utils.h
+ *
+ * This file contains helper macros and data structures used across the code
+ *
+ * Copyright (c) 2011, 2012, 2013, 2014 Imagination Technologies Ltd.
+ * All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#ifndef _UCCP420WLAN_UTILS_H
+#define _UCCP420WLAN_UTILS_H
+
+
+#define MASK_BITS(msb, lsb) (((1U << ((msb) - (lsb) + 1)) - 1) \
+			     << (lsb))
+
+#define EXTRACT_BITS(arg, msb, lsb) ((arg & MASK_BITS(msb, lsb)) >> (lsb))
+
+#define INSERT_BITS(arg, msb, lsb, value) ((arg) = ((arg) &		     \
+						    ~MASK_BITS(msb, lsb)) |  \
+						    (((value) << (lsb)) &    \
+						     MASK_BITS(msb, lsb)))
+
+#define FRAME_CTRL_TYPE(arg) EXTRACT_BITS(arg, 3, 2)
+#define FRAME_CTRL_STYPE(arg) EXTRACT_BITS(arg, 7, 4)
+#define FTYPE_DATA 0x02
+#define FSTYPE_QOS_DATA 0x08
+
+#endif /* _UCCP420WLAN_UTILS_H */
+
+/* EOF */
diff --git a/drivers/net/wireless/uccp420wlan/inc/version.h b/drivers/net/wireless/uccp420wlan/inc/version.h
new file mode 100644
index 0000000..53a92ff
--- /dev/null
+++ b/drivers/net/wireless/uccp420wlan/inc/version.h
@@ -0,0 +1,31 @@
+/*
+ * File Name  : version.h
+ *
+ * This file contains the UMAC version string
+ *
+ * Copyright (c) 2011, 2012, 2013, 2014 Imagination Technologies Ltd.
+ * All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+#ifndef _UCCP420WLAN_VERSION_H
+#define _UCCP420WLAN_VERSION_H
+#define UCCP_DRIVER_VERSION "4_5_4"
+#define UCCP_DRIVER_NAME "UCCP420WIFI"
+#endif /* _UCCP420WLAN_VERSION_H */
+
+/* EOF */
+
diff --git a/drivers/net/wireless/uccp420wlan/src/80211_if.c b/drivers/net/wireless/uccp420wlan/src/80211_if.c
new file mode 100644
index 0000000..e04367c
--- /dev/null
+++ b/drivers/net/wireless/uccp420wlan/src/80211_if.c
@@ -0,0 +1,3702 @@
+/*
+ * File Name  : 80211_if.c
+ *
+ * This file is the glue layer between net/mac80211 and UMAC
+ *
+ * Copyright (c) 2011, 2012, 2013, 2014 Imagination Technologies Ltd.
+ * All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <linux/proc_fs.h>
+#include <linux/version.h>
+#include <linux/device.h>
+
+#include <net/mac80211.h>
+#include <net/cfg80211.h>
+#include <net/ieee80211_radiotap.h>
+
+#include <linux/udp.h>
+#include <linux/ip.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+
+#include "version.h"
+#include "core.h"
+#include "utils.h"
+
+#include <linux/firmware.h>
+
+#include <fwldr.h>
+
+/* Its value will be the default mac address and it can only be updated with the
+ * command line arguments
+ */
+unsigned int vht_support = 1;
+module_param(vht_support, int, 0);
+MODULE_PARM_DESC(vht_support, "Configure the 11ac support for this device");
+
+static unsigned int ftm;
+module_param(ftm, int, 0);
+MODULE_PARM_DESC(ftm, "Factory Test Mode, should be used only for calibrations.");
+
+unsigned int system_rev = 0x494D47; /*ASCII: IMG*/
+
+static void uccp420_roc_complete_work(struct work_struct *work);
+static void uccp420wlan_exit(void);
+static int load_fw(struct ieee80211_hw *hw);
+
+#define CHAN2G(_freq, _idx)  {		\
+	.band = IEEE80211_BAND_2GHZ,	\
+	.center_freq = (_freq),		\
+	.hw_value = (_idx),		\
+	.max_power = 20,		\
+}
+
+#define CHAN5G(_freq, _idx, _flags) {	\
+	.band = IEEE80211_BAND_5GHZ,	\
+	.center_freq = (_freq),		\
+	.hw_value = (_idx),		\
+	.max_power = 20,		\
+	.flags = (_flags),		\
+}
+
+struct wifi_dev {
+	struct proc_dir_entry *umac_proc_dir_entry;
+	struct wifi_params params;
+	struct wifi_stats stats;
+	struct ieee80211_hw *hw;
+};
+
+static struct wifi_dev *wifi;
+
+static struct ieee80211_channel dsss_chantable[] = {
+	CHAN2G(2412, 0),  /* Channel 1 */
+	CHAN2G(2417, 1),  /* Channel 2 */
+	CHAN2G(2422, 2),  /* Channel 3 */
+	CHAN2G(2427, 3),  /* Channel 4 */
+	CHAN2G(2432, 4),  /* Channel 5 */
+	CHAN2G(2437, 5),  /* Channel 6 */
+	CHAN2G(2442, 6),  /* Channel 7 */
+	CHAN2G(2447, 7),  /* Channel 8 */
+	CHAN2G(2452, 8),  /* Channel 9 */
+	CHAN2G(2457, 9),  /* Channel 10 */
+	CHAN2G(2462, 10), /* Channel 11 */
+	CHAN2G(2467, 11), /* Channel 12 */
+	CHAN2G(2472, 12), /* Channel 13 */
+	CHAN2G(2484, 13), /* Channel 14 */
+};
+
+static struct ieee80211_channel ofdm_chantable[] = {
+	CHAN5G(5180, 14, 0), /* Channel 36 */
+	CHAN5G(5200, 15, 0), /* Channel 40 */
+	CHAN5G(5220, 16, 0), /* Channel 44 */
+	CHAN5G(5240, 17, 0), /* Channel 48 */
+	CHAN5G(5260, 18, IEEE80211_CHAN_RADAR), /* Channel 52 */
+	CHAN5G(5280, 19, IEEE80211_CHAN_RADAR), /* Channel 56 */
+	CHAN5G(5300, 20, IEEE80211_CHAN_RADAR), /* Channel 60 */
+	CHAN5G(5320, 21, IEEE80211_CHAN_RADAR), /* Channel 64 */
+	CHAN5G(5500, 22, IEEE80211_CHAN_RADAR), /* Channel 100 */
+	CHAN5G(5520, 23, IEEE80211_CHAN_RADAR), /* Channel 104 */
+	CHAN5G(5540, 24, IEEE80211_CHAN_RADAR), /* Channel 108 */
+	CHAN5G(5560, 25, IEEE80211_CHAN_RADAR), /* Channel 112 */
+	CHAN5G(5580, 26, IEEE80211_CHAN_RADAR), /* Channel 116 */
+	CHAN5G(5600, 27, IEEE80211_CHAN_RADAR), /* Channel 120 */
+	CHAN5G(5620, 28, IEEE80211_CHAN_RADAR), /* Channel 124 */
+	CHAN5G(5640, 29, IEEE80211_CHAN_RADAR), /* Channel 128 */
+	CHAN5G(5660, 30, IEEE80211_CHAN_RADAR), /* Channel 132 */
+	CHAN5G(5680, 31, IEEE80211_CHAN_RADAR), /* Channel 136 */
+	CHAN5G(5700, 32, IEEE80211_CHAN_RADAR), /* Channel 140 */
+	CHAN5G(5720, 33, IEEE80211_CHAN_RADAR), /* Channel 144 */
+	CHAN5G(5745, 34, 0), /* Channel 149 */
+	CHAN5G(5765, 35, 0), /* Channel 153 */
+	CHAN5G(5785, 36, 0), /* Channel 157 */
+	CHAN5G(5805, 37, 0), /* Channel 161 */
+	CHAN5G(5825, 38, 0), /* Channel 165 */
+};
+
+static struct ieee80211_rate dsss_rates[] = {
+	{ .bitrate = 10, .hw_value = 2},
+	{ .bitrate = 20, .hw_value = 4,
+	.flags = IEEE80211_RATE_SHORT_PREAMBLE},
+	{ .bitrate = 55, .hw_value = 11,
+	.flags = IEEE80211_RATE_SHORT_PREAMBLE},
+	{ .bitrate = 110, .hw_value = 22,
+	.flags = IEEE80211_RATE_SHORT_PREAMBLE},
+	{ .bitrate = 60, .hw_value = 12},
+	{ .bitrate = 90, .hw_value = 18},
+	{ .bitrate = 120, .hw_value = 24},
+	{ .bitrate = 180, .hw_value = 36},
+	{ .bitrate = 240, .hw_value = 48},
+	{ .bitrate = 360, .hw_value = 72},
+	{ .bitrate = 480, .hw_value = 96},
+	{ .bitrate = 540, .hw_value = 108}
+};
+
+static struct ieee80211_rate ofdm_rates[] = {
+	{ .bitrate = 60, .hw_value = 12},
+	{ .bitrate = 90, .hw_value = 18},
+	{ .bitrate = 120, .hw_value = 24},
+	{ .bitrate = 180, .hw_value = 36},
+	{ .bitrate = 240, .hw_value = 48},
+	{ .bitrate = 360, .hw_value = 72},
+	{ .bitrate = 480, .hw_value = 96},
+	{ .bitrate = 540, .hw_value = 108}
+};
+
+static struct ieee80211_supported_band band_2ghz = {
+	.channels = dsss_chantable,
+	.n_channels = ARRAY_SIZE(dsss_chantable),
+	.band = IEEE80211_BAND_2GHZ,
+	.bitrates = dsss_rates,
+	.n_bitrates = ARRAY_SIZE(dsss_rates),
+};
+
+static struct ieee80211_supported_band band_5ghz = {
+	.channels = ofdm_chantable,
+	.n_channels = ARRAY_SIZE(ofdm_chantable),
+	.band = IEEE80211_BAND_5GHZ,
+	.bitrates = ofdm_rates,
+	.n_bitrates = ARRAY_SIZE(ofdm_rates),
+};
+
+
+/* Interface combinations for Virtual interfaces*/
+static const struct ieee80211_iface_limit if_limit1[] = {
+		{ .max = 2, .types = BIT(NL80211_IFTYPE_STATION)}
+};
+
+static const struct ieee80211_iface_limit if_limit2[] = {
+		{ .max = 1, .types = BIT(NL80211_IFTYPE_STATION)},
+		{ .max = 1, .types = BIT(NL80211_IFTYPE_AP) |
+				     BIT(NL80211_IFTYPE_P2P_CLIENT) |
+				     BIT(NL80211_IFTYPE_ADHOC) |
+				     BIT(NL80211_IFTYPE_P2P_GO)}
+};
+
+static const struct ieee80211_iface_limit if_limit3[] = {
+		{ .max = 2, .types = BIT(NL80211_IFTYPE_P2P_CLIENT)}
+};
+
+static const struct ieee80211_iface_limit if_limit4[] = {
+		{ .max = 1, .types = BIT(NL80211_IFTYPE_ADHOC)},
+		{ .max = 1, .types = BIT(NL80211_IFTYPE_P2P_CLIENT)}
+};
+
+
+static const struct ieee80211_iface_combination if_comb[] = {
+	{ .limits = if_limit1,
+	  .n_limits = ARRAY_SIZE(if_limit1),
+	  .max_interfaces = 2,
+	  .num_different_channels = 1},
+	{ .limits = if_limit2,
+	  .n_limits = ARRAY_SIZE(if_limit2),
+	  .max_interfaces = 2,
+	  .num_different_channels = 1},
+	{ .limits = if_limit3,
+	  .n_limits = ARRAY_SIZE(if_limit3),
+	  .max_interfaces = 2,
+	  .num_different_channels = 1},
+	{ .limits = if_limit4,
+	  .n_limits = ARRAY_SIZE(if_limit4),
+	  .max_interfaces = 2,
+	  .num_different_channels = 1}
+};
+
+
+/* For getting the dev pointer */
+static struct class *hwsim_class;
+
+static const struct wiphy_wowlan_support uccp_wowlan_support = {
+	.flags = WIPHY_WOWLAN_ANY,
+};
+
+static int conv_str_to_byte(unsigned char *byte,
+		     unsigned char *str,
+		     int len)
+{
+	int  i, j = 0;
+	unsigned char ch, val = 0;
+
+	for (i = 0; i < (len * 2); i++) {
+		/*convert to lower*/
+		ch = ((str[i] >= 'A' && str[i] <= 'Z') ? str[i] + 32 : str[i]);
+
+		if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f'))
+			return -1;
+
+		if (ch >= '0' && ch <= '9')  /*check is digit*/
+			ch = ch - '0';
+		else
+			ch = ch - 'a' + 10;
+
+		val += ch;
+
+		if (!(i%2))
+			val <<= 4;
+		else {
+			byte[j] = val;
+			j++;
+			val = 0;
+		}
+	}
+
+	return 0;
+}
+
+
+static void tx(struct ieee80211_hw *hw,
+	       struct ieee80211_tx_control *txctl,
+	       struct sk_buff *skb)
+{
+	struct mac80211_dev *dev = hw->priv;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
+	struct umac_vif *uvif;
+	unsigned char null_bssid[6] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+	struct iphdr *iphdr;
+	unsigned char *pktgen_magic;
+	unsigned int orig_pktgen_magic = 0x55e99bbe; /*Endianness 0xbe9be955*/
+	struct umac_event_noa noa_event;
+
+	if (tx_info->control.vif == NULL) {
+		pr_debug("%s: Dropping injected TX frame\n",
+			 dev->name);
+		dev_kfree_skb_any(skb);
+		return;
+	}
+
+	uvif = (struct umac_vif *)(tx_info->control.vif->drv_priv);
+
+	if (wifi->params.production_test) {
+		if (((hdr->frame_control &
+		      IEEE80211_FCTL_FTYPE) != IEEE80211_FTYPE_DATA) ||
+		    (tx_info->control.vif == NULL))
+			goto tx_status;
+
+		iphdr = (struct iphdr *) skb_network_header(skb);
+		if (iphdr->protocol == IPPROTO_UDP) {
+			pktgen_magic = skb_transport_header(skb);
+			pktgen_magic += sizeof(struct udphdr);
+			/*If not PKTGEN, then drop it*/
+			if (memcmp(pktgen_magic, &orig_pktgen_magic, 4) != 0) {
+				pr_debug("%s:%d prod_mode: The pkt is NOT PKTGEN so dropping it\n",
+					 __func__, __LINE__);
+				goto tx_status;
+			}
+		} else {
+			pr_debug("%s:%d prod_mode: The pkt is NOT PKTGEN so dropping it.\n",
+				 __func__, __LINE__);
+			goto tx_status;
+		}
+	}
+	if (!memcmp(hdr->addr3, null_bssid, ETH_ALEN))
+		goto tx_status;
+
+	if ((dev->power_save == PWRSAVE_STATE_DOZE) &&
+	    (((hdr->frame_control &
+	      IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_DATA) ||
+		 is_bufferable_mgmt_frame(hdr)))
+		hdr->frame_control |= IEEE80211_FCTL_PM;
+
+	if (uvif->noa_active) {
+		memset(&noa_event, 0, sizeof(noa_event));
+		noa_event.if_index = uvif->vif_index;
+		uccp420wlan_noa_event(FROM_TX, &noa_event, dev, skb);
+		return;
+	}
+
+	uccp420wlan_tx_frame(skb, txctl->sta, dev, false);
+	return;
+
+tx_status:
+	tx_info->flags |= IEEE80211_TX_STAT_ACK;
+	tx_info->status.rates[0].count = 1;
+	ieee80211_tx_status(hw, skb);
+	return;
+}
+
+static int start(struct ieee80211_hw *hw)
+{
+	struct mac80211_dev *dev = (struct mac80211_dev *)hw->priv;
+
+	if ((wifi->params.fw_loading == 1) && load_fw(hw)) {
+		DEBUG_LOG("%s-80211IF: FW load failed\n", dev->name);
+		return -ENODEV;
+	}
+
+	DEBUG_LOG("%s-80211IF: In start\n", dev->name);
+
+	mutex_lock(&dev->mutex);
+	if ((uccp420wlan_core_init(dev, ftm)) < 0) {
+		DEBUG_LOG("%s-80211IF: umac init failed\n", dev->name);
+		mutex_unlock(&dev->mutex);
+		return -ENODEV;
+	}
+	INIT_DELAYED_WORK(&dev->roc_complete_work, uccp420_roc_complete_work);
+	dev->state = STARTED;
+	memset(dev->params->pdout_voltage, 0 ,
+	       sizeof(char) * MAX_AUX_ADC_SAMPLES);
+	mutex_unlock(&dev->mutex);
+
+	return 0;
+}
+
+static void stop(struct ieee80211_hw *hw)
+{
+	struct mac80211_dev    *dev = (struct mac80211_dev *)hw->priv;
+
+	DEBUG_LOG("%s-80211IF:In stop\n", dev->name);
+	mutex_lock(&dev->mutex);
+	uccp420wlan_core_deinit(dev, ftm);
+	dev->state = STOPPED;
+	mutex_unlock(&dev->mutex);
+
+	hal_ops.reset_hal_params();
+
+}
+
+static int add_interface(struct ieee80211_hw *hw,
+		struct ieee80211_vif *vif)
+{
+	struct mac80211_dev    *dev = hw->priv;
+	struct ieee80211_vif *v;
+	struct umac_vif   *uvif;
+	int vif_index, iftype;
+
+	iftype = vif->type;
+	v = vif;
+	vif->driver_flags |= IEEE80211_VIF_BEACON_FILTER;
+	vif->driver_flags |= IEEE80211_VIF_SUPPORTS_UAPSD;
+
+	if (!(iftype == NL80211_IFTYPE_STATION ||
+				iftype == NL80211_IFTYPE_ADHOC ||
+				iftype == NL80211_IFTYPE_AP)) {
+		pr_err("Invalid Interface type\n");
+		return -ENOTSUPP;
+	}
+
+	mutex_lock(&dev->mutex);
+
+	if (wifi->params.production_test) {
+		if (dev->active_vifs || iftype != NL80211_IFTYPE_ADHOC) {
+			mutex_unlock(&dev->mutex);
+			return -EBUSY;
+		}
+	}
+	for (vif_index = 0; vif_index < wifi->params.num_vifs; vif_index++)
+		if (dev->if_mac_addresses[vif_index].addr[5] == vif->addr[5])
+			break;
+	uvif = (struct umac_vif *)&v->drv_priv;
+	uvif->vif_index = vif_index;
+	uvif->vif = v;
+	uvif->dev = dev;
+	uvif->seq_no = 0;
+	uccp420wlan_vif_add(uvif);
+	dev->active_vifs |= (1 << vif_index);
+
+	if (iftype == NL80211_IFTYPE_ADHOC)
+		dev->tx_last_beacon = 0;
+
+	rcu_assign_pointer(dev->vifs[vif_index], v);
+	synchronize_rcu();
+
+	mutex_unlock(&dev->mutex);
+
+	return 0;
+}
+
+static void remove_interface(struct ieee80211_hw *hw,
+		struct ieee80211_vif *vif)
+{
+	struct mac80211_dev    *dev = hw->priv;
+	struct ieee80211_vif *v;
+	int vif_index;
+	v = vif;
+	vif_index = ((struct umac_vif *)&v->drv_priv)->vif_index;
+
+	mutex_lock(&dev->mutex);
+
+	uccp420wlan_vif_remove((struct umac_vif *)&v->drv_priv);
+	dev->active_vifs &= ~(1 << vif_index);
+	rcu_assign_pointer(dev->vifs[vif_index], NULL);
+	synchronize_rcu();
+
+	mutex_unlock(&dev->mutex);
+
+}
+
+
+static int config(struct ieee80211_hw *hw,
+		unsigned int changed)
+{
+	struct mac80211_dev *dev = hw->priv;
+	struct ieee80211_conf *conf = &hw->conf;
+	unsigned int pri_chnl_num;
+	unsigned int chnl_num1;
+	unsigned int chnl_num2;
+	unsigned int freq_band;
+	unsigned int ch_width;
+	int center_freq = 0;
+	int center_freq1 = 0;
+	int i;
+	int cf_offset;
+	int is_vht_bw80;
+	int is_vht_bw80_sec_40minus;
+	int is_vht_bw80_sec_40plus;
+
+	DEBUG_LOG("%s-80211IF:In config\n", dev->name);
+
+	mutex_lock(&dev->mutex);
+
+	if (changed & IEEE80211_CONF_CHANGE_POWER) {
+		dev->txpower = conf->power_level;
+		uccp420wlan_prog_txpower(dev->txpower);
+	}
+
+	/* Check for change in channel */
+	if (changed & IEEE80211_CONF_CHANGE_CHANNEL) {
+		center_freq = conf->chandef.chan->center_freq;
+		center_freq1 = conf->chandef.center_freq1;
+		cf_offset = center_freq1;
+
+		pri_chnl_num = ieee80211_frequency_to_channel(center_freq);
+		freq_band = conf->chandef.chan->band;
+
+		ch_width = conf->chandef.width;
+
+		DEBUG_LOG("%s-80211IF:Primary Channel is %d\n",
+			       dev->name,
+			       pri_chnl_num);
+
+		if (wifi->params.production_test == 1) {
+
+			if ((wifi->params.prod_mode_chnl_bw_40_mhz == 1) &&
+			    (wifi->params.sec_ch_offset_40_minus == 1)) {
+				/*  NL80211_CHAN_HT40MINUS */
+				ch_width = 2;
+				cf_offset = center_freq - 10;
+			} else if (wifi->params.prod_mode_chnl_bw_40_mhz == 1) {
+				/* NL80211_CHAN_HT40PLUS */
+				ch_width = 2;
+				cf_offset = center_freq + 10;
+			}
+
+			is_vht_bw80 = vht_support &&
+				(wifi->params.prod_mode_chnl_bw_80_mhz == 1);
+
+			is_vht_bw80_sec_40minus = is_vht_bw80 &&
+				(wifi->params.sec_ch_offset_40_minus == 1);
+
+			is_vht_bw80_sec_40plus = is_vht_bw80 &&
+				(wifi->params.sec_ch_offset_40_plus == 1);
+
+			if (is_vht_bw80)
+				ch_width = 3;
+
+			if (is_vht_bw80_sec_40minus &&
+			    (wifi->params.sec_40_ch_offset_80_minus == 1))
+				cf_offset = center_freq - 30;
+			else if (is_vht_bw80_sec_40minus &&
+				 (wifi->params.sec_40_ch_offset_80_plus == 1))
+				cf_offset = center_freq + 10;
+			else if (is_vht_bw80_sec_40minus)/* default */
+				cf_offset = center_freq - 30;
+
+			if (is_vht_bw80_sec_40plus &&
+			    (wifi->params.sec_40_ch_offset_80_minus == 1))
+				cf_offset = center_freq - 10;
+			else if (is_vht_bw80_sec_40plus &&
+				 (wifi->params.sec_40_ch_offset_80_plus == 1))
+				cf_offset = center_freq + 30;
+			else if (is_vht_bw80_sec_40plus)/* default */
+				cf_offset = center_freq - 10;
+		}
+
+		chnl_num1 = ieee80211_frequency_to_channel(cf_offset);
+		chnl_num2 = 0;
+
+		/*Store the currrent Channel*/
+		dev->cur_chan.pri_chnl_num = pri_chnl_num;
+		dev->cur_chan.chnl_num1 = chnl_num1;
+		dev->cur_chan.chnl_num2 = chnl_num2;
+		dev->cur_chan.ch_width  = ch_width;
+		dev->cur_chan.freq_band = freq_band;
+
+		dev->chan_prog_done = 0;
+		uccp420wlan_prog_channel(pri_chnl_num, chnl_num1, chnl_num2,
+					 ch_width, freq_band);
+	}
+
+	/* Check for change in Power save state */
+
+	for (i = 0; i < MAX_VIFS; i++) {
+
+		if (!(changed & IEEE80211_CONF_CHANGE_PS))
+			break;
+
+		if (!(dev->active_vifs & (1 << i)))
+			continue;
+
+		/* When ROC is in progress, do not mess with
+		 * PS state
+		 */
+		if (dev->roc_params.roc_in_progress)
+			continue;
+
+		if (wifi->params.disable_power_save)
+			continue;
+
+		if (conf->flags & IEEE80211_CONF_PS)
+			dev->power_save = PWRSAVE_STATE_DOZE;
+		else
+			dev->power_save = PWRSAVE_STATE_AWAKE;
+
+		DEBUG_LOG("%s-80211IF:PS state of VIF %d changed to %d\n",
+			       dev->name,
+			       i,
+			       dev->power_save);
+
+		uccp420wlan_prog_ps_state(i,
+					  dev->if_mac_addresses[i].addr,
+					  dev->power_save);
+	}
+
+	/* TODO: Make this global config as it effects all VIF's */
+	for (i = 0; i < MAX_VIFS; i++) {
+
+		if (!(changed & IEEE80211_CONF_CHANGE_SMPS))
+			break;
+
+		if (wifi->params.production_test == 1)
+			break;
+
+		if (!(dev->active_vifs & (1 << i)))
+			continue;
+
+		DEBUG_LOG("%s-80211IF:MIMO PS state of VIF %d -> %d\n",
+			       dev->name,
+			       i,
+			       conf->smps_mode);
+
+		uccp420wlan_prog_vif_smps(i,
+					  dev->if_mac_addresses[i].addr,
+					  conf->smps_mode);
+	}
+
+	/* Check for change in Retry Limits */
+	if (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS) {
+
+		DEBUG_LOG("%s-80211IF:Retry Limits changed to %d and %d\n",
+			       dev->name,
+			       conf->short_frame_max_tx_count,
+			       conf->long_frame_max_tx_count);
+	}
+
+	for (i = 0; i < MAX_VIFS; i++) {
+
+		if (!(changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS))
+			break;
+
+		if (!(dev->active_vifs & (1 << i)))
+			continue;
+
+		uccp420wlan_prog_short_retry(i,
+					     dev->if_mac_addresses[i].addr,
+					     conf->short_frame_max_tx_count);
+		uccp420wlan_prog_long_retry(i,
+					    dev->if_mac_addresses[i].addr,
+					    conf->long_frame_max_tx_count);
+	}
+
+	mutex_unlock(&dev->mutex);
+	return 0;
+}
+
+
+static u64 prepare_multicast(struct ieee80211_hw *hw,
+			     struct netdev_hw_addr_list *mc_list)
+{
+	struct mac80211_dev *dev = hw->priv;
+	int i;
+	struct netdev_hw_addr *ha;
+	int mc_count = 0;
+
+	if (dev->state != STARTED)
+		return 0;
+
+	mc_count = netdev_hw_addr_list_count(mc_list);
+	{
+		if (mc_count > MCST_ADDR_LIMIT) {
+			mc_count = 0;
+			pr_warn("%s-80211IF:Disabling MCAST filter (cnt=%d)\n",
+				dev->name, mc_count);
+			goto out;
+		}
+	}
+	DEBUG_LOG("%s-80211IF:M-cast filter cnt adding:%d removing: %d\n",
+			dev->name, mc_count, dev->mc_filter_count);
+
+	if (dev->mc_filter_count > 0) {
+		/* Remove all previous multicast addresses from the LMAC */
+		for (i = 0; i < dev->mc_filter_count; i++)
+			uccp420wlan_prog_mcast_addr_cfg(dev->mc_filters[i],
+							WLAN_MCAST_ADDR_REM);
+	}
+
+	i = 0;
+
+	netdev_hw_addr_list_for_each(ha, mc_list) {
+		/* Prog the multicast address into the LMAC */
+		uccp420wlan_prog_mcast_addr_cfg(ha->addr, WLAN_MCAST_ADDR_ADD);
+		memcpy(dev->mc_filters[i], ha->addr, 6);
+		i++;
+	}
+
+	dev->mc_filter_count = mc_count;
+out:
+	return mc_count;
+}
+
+
+static void configure_filter(struct ieee80211_hw *hw,
+		unsigned int changed_flags,
+		unsigned int *new_flags,
+		u64 mc_count)
+{
+	struct mac80211_dev *dev = hw->priv;
+	mutex_lock(&dev->mutex);
+
+	changed_flags &= SUPPORTED_FILTERS;
+	*new_flags &= SUPPORTED_FILTERS;
+
+	if (dev->state != STARTED) {
+		mutex_unlock(&dev->mutex);
+		return;
+	}
+
+	if ((*new_flags & FIF_ALLMULTI) || (mc_count == 0)) {
+		/* Disable the multicast filter in LMAC */
+		DEBUG_LOG("%s-80211IF: Multicast filters disabled\n",
+			       dev->name);
+		uccp420wlan_prog_mcast_filter_control(MCAST_FILTER_DISABLE);
+	} else if (mc_count) {
+		/* Enable the multicast filter in LMAC */
+		DEBUG_LOG("%s-80211IF: Multicast filters enabled\n",
+			       dev->name);
+		uccp420wlan_prog_mcast_filter_control(MCAST_FILTER_ENABLE);
+	}
+
+	if (changed_flags == 0)
+		/* No filters which we support changed */
+		goto out;
+
+	if (wifi->params.production_test == 0) {
+		if (*new_flags & FIF_BCN_PRBRESP_PROMISC) {
+			/* Receive all beacons and probe responses */
+			DEBUG_LOG("%s-80211IF: RCV ALL bcns\n",
+				       dev->name);
+			uccp420wlan_prog_rcv_bcn_mode(RCV_ALL_BCNS);
+		} else {
+			/* Receive only network beacons and probe responses */
+			DEBUG_LOG("%s-80211IF: RCV NW bcns\n",
+				       dev->name);
+			uccp420wlan_prog_rcv_bcn_mode(RCV_ALL_NETWORK_ONLY);
+		}
+	}
+out:
+	if (wifi->params.production_test == 1) {
+		DEBUG_LOG("%s-80211IF: RCV ALL bcns\n", dev->name);
+		uccp420wlan_prog_rcv_bcn_mode(RCV_ALL_BCNS);
+	}
+
+	mutex_unlock(&dev->mutex);
+	return;
+}
+
+
+static int conf_vif_tx(struct ieee80211_hw  *hw,
+		struct ieee80211_vif *vif,
+		unsigned short queue,
+		const struct ieee80211_tx_queue_params *txq_params)
+{
+	struct mac80211_dev *dev = hw->priv;
+	int vif_index, vif_active;
+	struct edca_params params;
+
+	for (vif_index = 0; vif_index < wifi->params.num_vifs; vif_index++)
+		if (dev->if_mac_addresses[vif_index].addr[5] == vif->addr[5])
+			break;
+
+	vif_active = 0;
+
+	if ((dev->active_vifs & (1 << vif_index)))
+		vif_active = 1;
+
+	memset(&params, 0, sizeof(params));
+	params.aifs = txq_params->aifs;
+	params.txop = txq_params->txop;
+	params.cwmin = txq_params->cw_min;
+	params.cwmax = txq_params->cw_max;
+	params.uapsd = txq_params->uapsd;
+
+	mutex_lock(&dev->mutex);
+	uccp420wlan_vif_set_edca_params(queue,
+					(struct umac_vif *)&vif->drv_priv,
+					&params,
+					vif_active);
+	mutex_unlock(&dev->mutex);
+	return 0;
+}
+
+
+static int set_key(struct ieee80211_hw *hw,
+		   enum set_key_cmd cmd,
+		   struct ieee80211_vif *vif,
+		   struct ieee80211_sta *sta,
+		   struct ieee80211_key_conf *key_conf)
+{
+
+	struct umac_key sec_key;
+	unsigned int result = 0;
+	struct mac80211_dev *dev = hw->priv;
+	unsigned int cipher_type, key_type;
+	int vif_index;
+	struct umac_vif *uvif;
+	uvif = ((struct umac_vif *)&vif->drv_priv);
+
+	memset(&sec_key, 0, sizeof(struct umac_key));
+
+	switch (key_conf->cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+		sec_key.key = key_conf->key;
+		cipher_type = CIPHER_TYPE_WEP40;
+		break;
+	case WLAN_CIPHER_SUITE_WEP104:
+		sec_key.key = key_conf->key;
+		cipher_type = CIPHER_TYPE_WEP104;
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		key_conf->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;
+		/* We get the key in the following form:
+		 * KEY (16 bytes) - TX MIC (8 bytes) - RX MIC (8 bytes)
+		 */
+		sec_key.key = key_conf->key;
+		sec_key.tx_mic = key_conf->key + 16;
+		sec_key.rx_mic = key_conf->key + 24;
+		cipher_type = CIPHER_TYPE_TKIP;
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		sec_key.key = key_conf->key;
+		cipher_type = CIPHER_TYPE_CCMP;
+		break;
+	default:
+		result = -EOPNOTSUPP;
+		mutex_unlock(&dev->mutex);
+		goto out;
+	}
+
+	vif_index = ((struct umac_vif *)&vif->drv_priv)->vif_index;
+
+	mutex_lock(&dev->mutex);
+
+	if (cmd == SET_KEY) {
+		key_conf->hw_key_idx = 0; /* Don't really use this */
+
+		/* This flag indicate that it requires IV generation */
+		key_conf->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;
+
+
+		if (cipher_type == CIPHER_TYPE_WEP40 ||
+		    cipher_type == CIPHER_TYPE_WEP104) {
+			DEBUG_LOG("%s-80211IF:ADD IF KEY.vif_index = %d\n",
+				       dev->name,
+				       vif_index);
+			DEBUG_LOG("	keyidx = %d\n",
+				       key_conf->keyidx);
+			DEBUG_LOG("	cipher_type = %d\n",
+				       cipher_type);
+
+			uccp420wlan_prog_if_key(vif_index,
+						vif->addr,
+						KEY_CTRL_ADD,
+						key_conf->keyidx,
+						cipher_type,
+						&sec_key);
+		} else if (sta) {
+			sec_key.peer_mac = sta->addr;
+
+			if (key_conf->flags & IEEE80211_KEY_FLAG_PAIRWISE)
+				key_type = KEY_TYPE_UCAST;
+			else
+				key_type = KEY_TYPE_BCAST;
+
+			DEBUG_LOG("%s-80211IF:ADD PEER KEY.vif_index = %d",
+				       dev->name, vif_index);
+			DEBUG_LOG("	keyidx = %d, keytype = %d\n",
+				       key_conf->keyidx, key_type);
+			DEBUG_LOG("	cipher_type = %d\n",
+				       cipher_type);
+
+			uccp420wlan_prog_peer_key(vif_index,
+						  vif->addr,
+						  KEY_CTRL_ADD,
+						  key_conf->keyidx,
+						  key_type,
+						  cipher_type,
+						  &sec_key);
+		} else {
+			key_type = KEY_TYPE_BCAST;
+
+			if (vif->type == NL80211_IFTYPE_STATION) {
+				sec_key.peer_mac =
+					(unsigned char *)vif->bss_conf.bssid;
+
+				memcpy(uvif->bssid,
+				       (vif->bss_conf.bssid),
+				       ETH_ALEN);
+
+				DEBUG_LOG("%s-80211IF: ADD PEER KEY\n",
+					       dev->name);
+				DEBUG_LOG("	vif_index = %d\n",
+					       vif_index);
+				DEBUG_LOG("	keyidx = %d\n",
+					       key_conf->keyidx);
+				DEBUG_LOG("	keytype = %d\n",
+					       key_type);
+				DEBUG_LOG("	cipher = %d\n",
+					       cipher_type);
+
+				uccp420wlan_prog_peer_key(vif_index,
+							  vif->addr,
+							  KEY_CTRL_ADD,
+							  key_conf->keyidx,
+							  key_type, cipher_type,
+							  &sec_key);
+
+			} else if (vif->type == NL80211_IFTYPE_AP) {
+				DEBUG_LOG("%s-80211IF: ADD IF KEY.\n",
+					       dev->name);
+				DEBUG_LOG("	vif_index = %d\n",
+					       vif_index);
+				DEBUG_LOG("	keyidx = %d\n",
+					       key_conf->keyidx);
+				DEBUG_LOG("	cipher_type = %d\n",
+					       cipher_type);
+
+				uccp420wlan_prog_if_key(vif_index,
+							vif->addr,
+							KEY_CTRL_ADD,
+							key_conf->keyidx,
+							cipher_type,
+							&sec_key);
+			} else {
+				/* ADHOC */
+				DEBUG_LOG("%s-80211IF: ADD IF KEY.\n",
+					       dev->name);
+				DEBUG_LOG("	vif_index = %d\n",
+					       vif_index);
+				DEBUG_LOG("	keyidx = %d\n",
+					       key_conf->keyidx);
+				DEBUG_LOG("	cipher_type = %d\n",
+					       cipher_type);
+
+				uccp420wlan_prog_if_key(vif_index,
+							vif->addr,
+							KEY_CTRL_ADD,
+							key_conf->keyidx,
+							cipher_type,
+							&sec_key);
+			}
+			}
+	} else if (cmd == DISABLE_KEY) {
+		if ((cipher_type == CIPHER_TYPE_WEP40) ||
+		    (cipher_type == CIPHER_TYPE_WEP104)) {
+			uccp420wlan_prog_if_key(vif_index,
+						vif->addr,
+						KEY_CTRL_DEL,
+						key_conf->keyidx,
+						cipher_type,
+						&sec_key);
+		} else if (sta) {
+			sec_key.peer_mac = sta->addr;
+
+			if (key_conf->flags & IEEE80211_KEY_FLAG_PAIRWISE)
+				key_type = KEY_TYPE_UCAST;
+			else
+				key_type = KEY_TYPE_BCAST;
+
+			uccp420wlan_prog_peer_key(vif_index,
+						  vif->addr,
+						  KEY_CTRL_DEL,
+						  key_conf->keyidx,
+						  key_type,
+						  cipher_type,
+						  &sec_key);
+		} else {
+			if (vif->type == NL80211_IFTYPE_STATION) {
+				sec_key.peer_mac = uvif->bssid;
+
+				uccp420wlan_prog_peer_key(vif_index,
+							  vif->addr,
+							  KEY_CTRL_DEL,
+							  key_conf->keyidx,
+							  KEY_TYPE_BCAST,
+							  cipher_type,
+							  &sec_key);
+
+			} else if (vif->type == NL80211_IFTYPE_AP)
+				uccp420wlan_prog_if_key(vif_index,
+							vif->addr,
+							KEY_CTRL_DEL,
+							key_conf->keyidx,
+							cipher_type,
+							&sec_key);
+			else
+				uccp420wlan_prog_if_key(vif_index,
+							vif->addr,
+							KEY_CTRL_DEL,
+							key_conf->keyidx,
+							cipher_type,
+							&sec_key);
+		}
+	}
+
+	mutex_unlock(&dev->mutex);
+
+out:
+	return result;
+}
+
+
+static void bss_info_changed(struct ieee80211_hw *hw,
+			     struct ieee80211_vif *vif,
+			     struct ieee80211_bss_conf *bss_conf,
+			     unsigned int changed)
+{
+	struct mac80211_dev   *dev = hw->priv;
+
+	mutex_lock(&dev->mutex);
+
+	if (wifi->params.production_test || wifi->params.disable_beacon_ibss) {
+		/*Disable beacon generation when running pktgen
+		 *for performance*/
+		changed &= ~BSS_CHANGED_BEACON_INT;
+		changed &= ~BSS_CHANGED_BEACON_ENABLED;
+	}
+
+	uccp420wlan_vif_bss_info_changed((struct umac_vif *)&vif->drv_priv,
+					 bss_conf,
+					 changed);
+	mutex_unlock(&dev->mutex);
+
+	return;
+}
+
+
+static void setup_ht_cap(struct ieee80211_sta_ht_cap *ht_info)
+{
+	int i;
+	memset(ht_info, 0, sizeof(*ht_info));
+	ht_info->ht_supported = true;
+	pr_info("SETUP HT CALLED\n");
+#if 0
+	ht_info->cap |= IEEE80211_HT_CAP_DSSSCCK40;
+#endif
+	ht_info->cap = 0;
+	ht_info->cap |= IEEE80211_HT_CAP_MAX_AMSDU;
+	ht_info->cap |= IEEE80211_HT_CAP_SGI_40;
+	ht_info->cap |= IEEE80211_HT_CAP_SGI_20;
+	ht_info->cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;
+	ht_info->cap |= IEEE80211_HT_CAP_GRN_FLD;
+	ht_info->cap |= IEEE80211_HT_CAP_LDPC_CODING;
+	ht_info->cap |= IEEE80211_HT_CAP_TX_STBC;
+	ht_info->cap |= (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);
+	ht_info->cap |= IEEE80211_HT_CAP_LSIG_TXOP_PROT;
+	/*We support SMPS*/
+
+	ht_info->ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;
+	ht_info->ampdu_density = IEEE80211_HT_MPDU_DENSITY_4;
+
+	memset(&ht_info->mcs, 0, sizeof(ht_info->mcs));
+
+	if (wifi->params.max_tx_streams != wifi->params.max_rx_streams) {
+		ht_info->mcs.tx_params |= IEEE80211_HT_MCS_TX_RX_DIFF;
+		ht_info->mcs.tx_params |= ((wifi->params.max_tx_streams - 1)
+				<< IEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT);
+	}
+
+	for (i = 0; i < wifi->params.max_rx_streams; i++)
+		ht_info->mcs.rx_mask[i] = 0xff;
+	ht_info->mcs.rx_mask[4] = 0x1;
+
+	ht_info->mcs.tx_params |= IEEE80211_HT_MCS_TX_DEFINED;
+}
+
+
+#define IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT 13
+#define IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT 16
+static void setup_vht_cap(struct ieee80211_sta_vht_cap *vht_info)
+{
+	if (!vht_support)
+		return;
+
+	memset(vht_info, 0, sizeof(*vht_info));
+	vht_info->vht_supported = true;
+	pr_info("SETUP VHT CALLED\n");
+
+	vht_info->cap = IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |
+			/*64KB Rx buffer size*/
+			(3 <<
+			IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT) |
+#if 0
+			IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE |
+			IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |
+			(1 << IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT) |
+			(1 << IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT) |
+#endif
+			IEEE80211_VHT_CAP_SHORT_GI_80 |
+			IEEE80211_VHT_CAP_RXLDPC |
+			IEEE80211_VHT_CAP_TXSTBC |
+			IEEE80211_VHT_CAP_RXSTBC_1 |
+			IEEE80211_VHT_CAP_HTC_VHT;
+	/* 1x1 */
+	if ((wifi->params.max_tx_streams == 1) &&
+	    (wifi->params.max_rx_streams == 1)) {
+		vht_info->vht_mcs.rx_mcs_map =
+			((IEEE80211_VHT_MCS_SUPPORT_0_7) << (2*0)) |
+			((IEEE80211_VHT_MCS_NOT_SUPPORTED) << (2*1)) |
+			((IEEE80211_VHT_MCS_NOT_SUPPORTED) << (2*2)) |
+			((IEEE80211_VHT_MCS_NOT_SUPPORTED) << (2*3)) |
+			((IEEE80211_VHT_MCS_NOT_SUPPORTED) << (2*4)) |
+			((IEEE80211_VHT_MCS_NOT_SUPPORTED) << (2*5)) |
+			((IEEE80211_VHT_MCS_NOT_SUPPORTED) << (2*6)) |
+			((IEEE80211_VHT_MCS_NOT_SUPPORTED) << (2*7));
+	}
+
+	/*2x2 */
+	if ((wifi->params.max_tx_streams == 2) &&
+	    (wifi->params.max_rx_streams == 2)) {
+		vht_info->vht_mcs.rx_mcs_map =
+			((IEEE80211_VHT_MCS_SUPPORT_0_7) << (2*0)) |
+			((IEEE80211_VHT_MCS_SUPPORT_0_7) << (2*1)) |
+			((IEEE80211_VHT_MCS_NOT_SUPPORTED) << (2*2)) |
+			((IEEE80211_VHT_MCS_NOT_SUPPORTED) << (2*3)) |
+			((IEEE80211_VHT_MCS_NOT_SUPPORTED) << (2*4)) |
+			((IEEE80211_VHT_MCS_NOT_SUPPORTED) << (2*5)) |
+			((IEEE80211_VHT_MCS_NOT_SUPPORTED) << (2*6)) |
+			((IEEE80211_VHT_MCS_NOT_SUPPORTED) << (2*7));
+	}
+
+	vht_info->vht_mcs.tx_mcs_map = vht_info->vht_mcs.rx_mcs_map;
+}
+
+
+static void init_hw(struct ieee80211_hw *hw)
+{
+	struct mac80211_dev  *dev = (struct mac80211_dev *)hw->priv;
+	int num_if_comb = 0;
+
+	/* Supported Interface Types and other Default values*/
+	hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
+				     BIT(NL80211_IFTYPE_ADHOC) |
+				     BIT(NL80211_IFTYPE_AP) |
+				     BIT(NL80211_IFTYPE_P2P_CLIENT) |
+				     BIT(NL80211_IFTYPE_P2P_GO);
+
+	hw->wiphy->iface_combinations = if_comb;
+
+	num_if_comb = (sizeof(if_comb) /
+		       sizeof(struct ieee80211_iface_combination));
+	hw->wiphy->n_iface_combinations = num_if_comb;
+
+	hw->flags = IEEE80211_HW_SIGNAL_DBM | IEEE80211_HW_SUPPORTS_PS;
+	hw->flags |= IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING;
+	hw->flags |= IEEE80211_HW_AMPDU_AGGREGATION;
+	hw->flags |= IEEE80211_HW_MFP_CAPABLE;
+
+	if (wifi->params.dot11a_support)
+		hw->flags |= IEEE80211_HW_SPECTRUM_MGMT;
+
+	hw->flags |= IEEE80211_HW_SUPPORTS_PER_STA_GTK;
+
+	hw->flags |= IEEE80211_HW_CONNECTION_MONITOR;
+
+	hw->wiphy->max_scan_ssids = MAX_NUM_SSIDS; /* 4 */
+	 /* Low priority bg scan */
+	hw->wiphy->features |= NL80211_FEATURE_LOW_PRIORITY_SCAN;
+	hw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;
+	hw->max_listen_interval = 10;
+	hw->wiphy->max_remain_on_channel_duration = 5000; /*ROC*/
+	hw->max_rates = 4;
+	hw->max_rate_tries = 5;
+	hw->queues = 4;
+
+	/* Size */
+	hw->extra_tx_headroom = 0;
+	hw->vif_data_size = sizeof(struct umac_vif);
+
+	if (wifi->params.dot11g_support) {
+		hw->wiphy->bands[IEEE80211_BAND_2GHZ] = &band_2ghz;
+		setup_ht_cap(&hw->wiphy->bands[IEEE80211_BAND_2GHZ]->ht_cap);
+	}
+
+	if (wifi->params.dot11a_support) {
+		if (vht_support)
+			setup_vht_cap(&band_5ghz.vht_cap);
+		hw->wiphy->bands[IEEE80211_BAND_5GHZ] = &band_5ghz;
+		setup_ht_cap(&hw->wiphy->bands[IEEE80211_BAND_5GHZ]->ht_cap);
+	}
+
+	memset(hw->wiphy->addr_mask, 0, sizeof(hw->wiphy->addr_mask));
+
+	if (wifi->params.num_vifs == 1) {
+		hw->wiphy->addresses = NULL;
+		SET_IEEE80211_PERM_ADDR(hw, dev->if_mac_addresses[0].addr);
+	} else {
+		hw->wiphy->n_addresses = wifi->params.num_vifs;
+		hw->wiphy->addresses = dev->if_mac_addresses;
+	}
+
+	hw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD;
+	hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
+	hw->wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
+
+	if (!wifi->params.disable_power_save &&
+	    !wifi->params.disable_sm_power_save) {
+		/* SMPS Support both Static and Dynamic */
+		hw->wiphy->features |= NL80211_FEATURE_STATIC_SMPS;
+		hw->wiphy->features |= NL80211_FEATURE_DYNAMIC_SMPS;
+        }
+
+#ifdef CONFIG_PM
+	hw->wiphy->wowlan = &uccp_wowlan_support;
+#endif
+}
+
+
+static int ampdu_action(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+				enum ieee80211_ampdu_mlme_action action,
+				struct ieee80211_sta *sta,
+				u16 tid, u16 *ssn, u8 buf_size)
+{
+	int ret = 0;
+	unsigned int val = 0;
+	struct mac80211_dev *dev = (struct mac80211_dev *)hw->priv;
+
+	DEBUG_LOG("%s-80211IF: ampdu action started\n",
+		       ((struct mac80211_dev *)(hw->priv))->name);
+
+	switch (action) {
+	case IEEE80211_AMPDU_RX_START:
+		{
+		val = tid | TID_INITIATOR_AP;
+		dev->tid_info[val].tid_state = TID_STATE_AGGR_START;
+		dev->tid_info[val].ssn = *ssn;
+		uccp420wlan_prog_ba_session_data(1,
+						 tid,
+						 &dev->tid_info[val].ssn,
+						 1,
+						 vif->addr,
+				   (unsigned char *)(vif->bss_conf.bssid));
+		}
+		break;
+	case IEEE80211_AMPDU_RX_STOP:
+		{
+		val = tid | TID_INITIATOR_AP;
+		dev->tid_info[val].tid_state = TID_STATE_AGGR_STOP;
+		uccp420wlan_prog_ba_session_data(0,
+						 tid,
+						 &dev->tid_info[val].ssn,
+						 1,
+						 vif->addr,
+				   (unsigned char *)(vif->bss_conf.bssid));
+		}
+		break;
+	case IEEE80211_AMPDU_TX_START:
+		{
+		val = tid | TID_INITIATOR_STA;
+		ieee80211_start_tx_ba_cb_irqsafe(vif, sta->addr, tid);
+		dev->tid_info[val].tid_state = TID_STATE_AGGR_START;
+		dev->tid_info[val].ssn = *ssn;
+		}
+		break;
+	case IEEE80211_AMPDU_TX_STOP_FLUSH:
+	case IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:
+	case IEEE80211_AMPDU_TX_STOP_CONT:
+		{
+		val = tid | TID_INITIATOR_STA;
+		dev->tid_info[val].tid_state = TID_STATE_AGGR_STOP;
+		ieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);
+		}
+		break;
+	case IEEE80211_AMPDU_TX_OPERATIONAL:
+		{
+		val = tid | TID_INITIATOR_STA;
+		dev->tid_info[val].tid_state = TID_STATE_AGGR_OPERATIONAL;
+		}
+		break;
+	default:
+		pr_err("%s: Invalid command, ignoring\n",
+		       __func__);
+	}
+	return ret;
+}
+
+
+static int set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
+{
+	struct mac80211_dev *dev = (struct mac80211_dev *)hw->priv;
+
+	/* Maximum no of antenna supported =2 */
+	if (!tx_ant || (tx_ant & ~3) || !rx_ant || (rx_ant & ~3))
+		return -EINVAL;
+
+	dev->tx_antenna = (tx_ant & 3);
+
+	return 0;
+}
+
+
+static void uccp420_roc_complete_work(struct work_struct *work)
+{
+	struct delayed_work *dwork;
+	int i;
+	struct mac80211_dev *dev;
+
+	dwork = container_of(work, struct delayed_work, work);
+	dev = container_of(dwork, struct mac80211_dev, roc_complete_work);
+
+	if (atomic_read(&dev->roc_params.roc_mgmt_tx_count) != 0) {
+		DEBUG_LOG("%s:%d but %d off channel tx frames pending\n",
+			  __func__,
+			  __LINE__,
+			  atomic_read(&dev->roc_params.roc_mgmt_tx_count));
+		return;
+	}
+
+	/* ROC Completed */
+	mutex_lock(&dev->mutex);
+
+	/* Put the chip back to its original state */
+	for (i = 0; i < MAX_VIFS; i++) {
+
+		if (!dev->roc_params.roc_ps_changed)
+			break;
+
+		if (!(dev->active_vifs & (1 << i)))
+			continue;
+
+		uccp420wlan_prog_ps_state(i,
+					  dev->if_mac_addresses[i].addr,
+					  dev->power_save);
+	}
+
+	dev->roc_params.roc_ps_changed = 0;
+
+	if (dev->roc_params.roc_chan_changed) {
+		dev->chan_prog_done = 0;
+
+		uccp420wlan_prog_channel(dev->cur_chan.pri_chnl_num,
+					 dev->cur_chan.chnl_num1,
+					 dev->cur_chan.chnl_num2,
+					 dev->cur_chan.ch_width,
+					 dev->cur_chan.freq_band);
+
+		if (wait_for_channel_prog_complete(dev)) {
+			pr_err("%s:%d ROC Complete: Programming the Channel %d Timed-out (500ms)\n",
+			       __func__, __LINE__, dev->cur_chan.pri_chnl_num);
+			dev->roc_params.roc_in_progress = 0;
+			dev->roc_params.roc_chan_changed = 0;
+			ieee80211_remain_on_channel_expired(dev->hw);
+			mutex_unlock(&dev->mutex);
+
+			/* Unable to go back to Home channel, what next?? */
+			return;
+		}
+
+		dev->roc_params.roc_chan_changed = 0;
+	}
+
+	/* Inform FW that ROC is started */
+	uccp420wlan_prog_roc(ROC_START, dev->cur_chan.pri_chnl_num, 0);
+
+	ieee80211_remain_on_channel_expired(dev->hw);
+	dev->roc_params.roc_in_progress = 0;
+
+	DEBUG_LOG("%s:%d Coming back to Orig: %d\n",
+		  __func__,
+		  __LINE__,
+		  dev->power_save);
+
+	mutex_unlock(&dev->mutex);
+}
+
+
+static int remain_on_channel(struct ieee80211_hw *hw,
+			     struct ieee80211_vif *vif,
+			     struct ieee80211_channel *channel,
+			     int duration,
+			     enum ieee80211_roc_type type)
+
+{
+	int i;
+	struct mac80211_dev *dev = (struct mac80211_dev *)hw->priv;
+	unsigned int pri_chnl_num = 0;
+	unsigned int chnl_num1 = 0;
+	unsigned int chnl_num2 = 0;
+	unsigned int freq_band = channel->band;
+	unsigned int ch_width = 0; /* 20MHz */
+
+	pri_chnl_num = ieee80211_frequency_to_channel(channel->center_freq);
+	chnl_num1 = ieee80211_frequency_to_channel(channel->center_freq);
+
+	mutex_lock(&dev->mutex);
+
+	DEBUG_LOG("%s:%d orig_ps: %d The Params are: channel:%d\n",
+		  __func__, __LINE__,
+		  dev->power_save,
+		  pri_chnl_num);
+	DEBUG_LOG("	duration:%d type: %d c1:%d band:%d\n",
+		  duration,
+		  type,
+		  chnl_num1,
+		  freq_band);
+
+	/* Put the chip in powersave */
+	for (i = 0; i < MAX_VIFS; i++) {
+		if (dev->power_save == PWRSAVE_STATE_AWAKE)
+			break;
+
+		dev->roc_params.roc_ps_changed = 1;
+
+		if (!(dev->active_vifs & (1 << i)))
+			continue;
+
+		uccp420wlan_prog_ps_state(i,
+					  dev->if_mac_addresses[i].addr,
+					  PWRSAVE_STATE_AWAKE);
+	}
+
+	do {
+		if (dev->cur_chan.pri_chnl_num == pri_chnl_num)
+			break;
+
+		DEBUG_LOG("%s:%d Programming the Channel\n",
+			  __func__, __LINE__);
+
+		dev->chan_prog_done = 0;
+
+		uccp420wlan_prog_channel(pri_chnl_num,
+					 chnl_num1,
+					 chnl_num2,
+					 ch_width, freq_band);
+
+		if (!wait_for_channel_prog_complete(dev)) {
+			dev->roc_params.roc_chan_changed = 1;
+			break;
+		}
+
+		pr_err("%s:%d ROC Start: Programming the Channel %d Timed-out (500ms)\n",
+			__func__, __LINE__, pri_chnl_num);
+
+		/* Put the chip back to its orig state*/
+		for (i = 0; i < MAX_VIFS; i++) {
+			if (!dev->roc_params.roc_ps_changed)
+				break;
+
+			if (!(dev->active_vifs & (1 << i)))
+				continue;
+
+			uccp420wlan_prog_ps_state(i,
+						  dev->if_mac_addresses[i].addr,
+						  dev->power_save);
+		}
+
+		dev->roc_params.roc_ps_changed = 0;
+
+		ieee80211_remain_on_channel_expired(dev->hw);
+		mutex_unlock(&dev->mutex);
+
+		return 0;
+
+	} while (0);
+
+	DEBUG_LOG("%s:%d Programming the Channel Success:%d\n",
+		  __func__, __LINE__,
+		  dev->chan_prog_done);
+
+	/* Inform FW that ROC is started */
+	uccp420wlan_prog_roc(ROC_START, pri_chnl_num, duration);
+
+	ieee80211_queue_delayed_work(hw,
+				     &dev->roc_complete_work,
+				     msecs_to_jiffies(duration));
+
+	dev->roc_params.roc_in_progress = 1;
+
+	ieee80211_ready_on_channel(dev->hw);
+
+	mutex_unlock(&dev->mutex);
+
+	return 0;
+}
+
+
+static int cancel_remain_on_channel(struct ieee80211_hw *hw)
+{
+	int i = 0;
+	struct mac80211_dev *dev = (struct mac80211_dev *)hw->priv;
+
+	mutex_lock(&dev->mutex);
+
+	if (dev->roc_params.roc_in_progress) {
+		cancel_delayed_work_sync(&dev->roc_complete_work);
+
+		/* Put the chip back to its original state */
+		for (i = 0; i < MAX_VIFS; i++) {
+			if (!(dev->active_vifs & (1 << i)))
+				continue;
+
+			uccp420wlan_prog_ps_state(i,
+						  dev->if_mac_addresses[i].addr,
+						  dev->power_save);
+		}
+
+		DEBUG_LOG("%s:%d Coming back to Orig:%d\n",
+			  __func__, __LINE__,
+			  dev->power_save);
+
+		dev->roc_params.roc_in_progress = 0;
+	}
+
+	mutex_unlock(&dev->mutex);
+
+	return 0;
+}
+
+
+/* Needed in case of IBSS to send out probe responses when we are beaconing */
+static int tx_last_beacon(struct ieee80211_hw *hw)
+{
+	struct mac80211_dev *dev = (struct mac80211_dev *)hw->priv;
+
+	return dev->tx_last_beacon;
+}
+
+
+#ifdef CONFIG_PM
+static int wait_for_econ_ps_cfg(struct mac80211_dev *dev)
+{
+	int count = 0;
+	char econ_ps_cfg_done = 0;
+
+check_econ_ps_cfg_complete:
+	mutex_lock(&dev->mutex);
+	econ_ps_cfg_done = dev->econ_ps_cfg_stats.completed;
+	mutex_unlock(&dev->mutex);
+
+	if (!econ_ps_cfg_done && (count < PS_ECON_CFG_TIMEOUT_TICKS)) {
+		count++;
+		current->state = TASK_INTERRUPTIBLE;
+		schedule_timeout(1);
+		goto check_econ_ps_cfg_complete;
+	}
+
+	if (!econ_ps_cfg_done) {
+		pr_warn("%s: Didn't get ECON_PS_CFG_DONE event\n",
+		       __func__);
+		return -1;
+	}
+
+	pr_debug("%s : Received ECON_PS_CFG_DONE event\n",
+		 __func__);
+
+	return 0;
+}
+
+static int img_resume(struct ieee80211_hw *hw)
+{
+	int i = 0;
+	int active_vif_index = -1;
+	struct mac80211_dev *dev = NULL;
+
+	if (hw == NULL) {
+		pr_err("%s: Invalid parameters\n",
+		       __func__);
+		return -1;
+	}
+
+	dev = (struct mac80211_dev *)hw->priv;
+
+	mutex_lock(&dev->mutex);
+
+	for (i = 0; i < MAX_VIFS; i++) {
+		if (dev->active_vifs & (1 << i))
+			active_vif_index = i;
+	}
+
+	dev->econ_ps_cfg_stats.completed = 0;
+	dev->econ_ps_cfg_stats.result = 0;
+
+	if (uccp420wlan_prog_econ_ps_state(active_vif_index,
+					   PWRSAVE_STATE_AWAKE)) {
+		pr_err(" %s : Error Occured\n",
+		       __func__);
+		mutex_unlock(&dev->mutex);
+		return -1;
+	}
+
+	mutex_unlock(&dev->mutex);
+
+	if (!wait_for_econ_ps_cfg(dev)) {
+		if (!dev->econ_ps_cfg_stats.result) {
+			dev->power_save = PWRSAVE_STATE_AWAKE;
+			pr_debug("%s: Successful\n",
+				 __func__);
+
+			return 0;
+		}
+	}
+
+	pr_err("%s: Error Occured\n",
+	       __func__);
+
+	return -1;
+}
+
+
+static int img_suspend(struct ieee80211_hw *hw,
+		       struct cfg80211_wowlan *wowlan)
+{
+	int i = 0;
+	int active_vif_index = -1;
+	int count = 0;
+	struct mac80211_dev *dev = NULL;
+
+	if (hw == NULL) {
+		pr_err("%s: Invalid parameters\n",
+		       __func__);
+		return -1;
+	}
+
+	if (WARN_ON((wifi->params.hw_scan_status == HW_SCAN_STATUS_PROGRESS)))
+		return -1;
+
+	dev = (struct mac80211_dev *)hw->priv;
+
+	mutex_lock(&dev->mutex);
+
+	for (i = 0; i < MAX_VIFS; i++) {
+		if (dev->active_vifs & (1 << i)) {
+			active_vif_index = i;
+			count++;
+		}
+	}
+
+	if (count != 1) {
+		pr_err("%s: Economy mode supported only for single VIF in STA mode\n",
+		       __func__);
+		mutex_unlock(&dev->mutex);
+		return -1;
+	}
+
+	if (dev->vifs[active_vif_index]->type != NL80211_IFTYPE_STATION) {
+		pr_err("%s: VIF is not in STA Mode\n",
+		       __func__);
+		mutex_unlock(&dev->mutex);
+		return -1;
+	 }
+
+	dev->econ_ps_cfg_stats.completed = 0;
+	dev->econ_ps_cfg_stats.result = 0;
+	dev->econ_ps_cfg_stats.wake_trig = -1;
+
+	if (uccp420wlan_prog_econ_ps_state(active_vif_index,
+					   PWRSAVE_STATE_DOZE)) {
+		pr_err("%s : Error Occured\n",
+		       __func__);
+		mutex_unlock(&dev->mutex);
+
+		return -1;
+	}
+
+	mutex_unlock(&dev->mutex);
+
+	if (!wait_for_econ_ps_cfg(dev)) {
+		if (!dev->econ_ps_cfg_stats.result) {
+			dev->power_save = PWRSAVE_STATE_DOZE;
+			pr_debug("%s: Successful\n",
+				 __func__);
+			return 0;
+		}
+	}
+
+	pr_err("%s: Error Occured\n",
+	       __func__);
+
+	return -1;
+}
+#endif
+
+
+int scan(struct ieee80211_hw *hw,
+	 struct ieee80211_vif *vif,
+	 struct ieee80211_scan_request *ireq)
+{
+	struct umac_vif *uvif = (struct umac_vif *)vif->drv_priv;
+	struct scan_req scan_req = {0};
+	int i = 0;
+
+        struct cfg80211_scan_request *req;
+        req = &ireq->req;
+
+	scan_req.n_ssids = req->n_ssids;
+	scan_req.n_channels = req->n_channels;
+	scan_req.ie_len = req->ie_len;
+
+	if (wifi->params.hw_scan_status != HW_SCAN_STATUS_NONE)
+		return -EBUSY; /* Already in HW SCAN State */
+
+	/* Keep track of HW Scan requests and compeltes */
+	wifi->params.hw_scan_status = HW_SCAN_STATUS_PROGRESS;
+
+	if (uvif->dev->params->production_test == 1) {
+		/* Drop scan, its just intended for IBSS
+		 * and some data traffic
+		 */
+		if (wifi->params.hw_scan_status != HW_SCAN_STATUS_NONE) {
+			ieee80211_scan_completed(uvif->dev->hw, false);
+			wifi->params.hw_scan_status = HW_SCAN_STATUS_NONE;
+		}
+
+		return 0;
+	}
+
+	if (req->ie_len)
+		memcpy(scan_req.ie, req->ie, req->ie_len);
+
+	for (i = 0; i < req->n_channels; i++) {
+		scan_req.center_freq[i] = req->channels[i]->center_freq;
+		scan_req.freq_max_power[i] = req->channels[i]->max_power;
+		scan_req.chan_flags[i] = req->channels[i]->flags;
+		/* The type of scan comes from mac80211 so its taken care of */
+	}
+
+	scan_req.p2p_probe = req->no_cck;
+
+	/* For hostapd scan (40MHz) and scan_type=passive, n_ssids=0
+	 * and req->ssids is NULL
+	 */
+	if (req->n_ssids > 0) {
+		for (i = 0; i < req->n_ssids; i++) {
+			scan_req.ssids[i].ssid_len = req->ssids[i].ssid_len;
+			if (req->ssids[i].ssid_len > 0)
+				memcpy(scan_req.ssids[i].ssid,
+				       req->ssids[i].ssid,
+				       req->ssids[i].ssid_len);
+		}
+	}
+
+	return uccp420wlan_scan(uvif->vif_index, &scan_req);
+}
+
+
+void uccp420wlan_scan_complete(void *context,
+			       struct host_event_scanres *scan_res,
+			       unsigned char *skb,
+			       unsigned int len)
+{
+	struct mac80211_dev *dev = (struct mac80211_dev *)context;
+
+	/* DO NOT update the scan results through cfg80211 API's we just pass
+	 * the beacons and probe responses up and mac80211 will inform cfg80211
+	 */
+	if (scan_res->more_results == 0) {
+		DEBUG_LOG("Event Scan Complete from UCCP:\n");
+		DEBUG_LOG("	More_results: 0, Scan is Completed\n");
+
+		/* There can be a race where we receive remove_interface and
+		 * abort the scan(1)
+		 * But we get scan_complete from the FW(2), this check will make
+		 * sure we are not calling scan_complete when we have already
+		 * aborted the scan. Eg: Killing wpa_supplicant in middle of
+		 * scanning
+		 */
+		if (wifi->params.hw_scan_status != HW_SCAN_STATUS_NONE) {
+			dev->stats->umac_scan_complete++;
+			ieee80211_scan_completed(dev->hw, false);
+
+			/* Keep track of HW Scan requests and compeltes */
+			wifi->params.hw_scan_status = HW_SCAN_STATUS_NONE;
+		}
+	} else {
+		DEBUG_LOG("Event Scan Complete from UCCP:\n");
+		DEBUG_LOG("More_results: %d, Still Scanning\n",
+				scan_res->more_results);
+
+	}
+}
+
+
+void cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	struct umac_vif *uvif = (struct umac_vif *)vif->drv_priv;
+	struct mac80211_dev *dev = NULL;
+
+	dev = (struct mac80211_dev *)hw->priv;
+
+	if (wifi->params.hw_scan_status == HW_SCAN_STATUS_PROGRESS) {
+		pr_info("Aborting pending scan request...\n");
+
+		dev->scan_abort_done = 0;
+
+		if (uccp420wlan_scan_abort(uvif->vif_index))
+			return;
+
+		if (!wait_for_scan_abort(dev)) {
+			ieee80211_scan_completed(hw, true);
+			wifi->params.hw_scan_status = HW_SCAN_STATUS_NONE;
+			dev->stats->umac_scan_complete++;
+			return;
+		}
+	}
+}
+
+
+int set_rts_threshold(struct ieee80211_hw *hw,
+		      u32 value)
+{
+	struct mac80211_dev *dev = NULL;
+
+	dev = (struct mac80211_dev *)hw->priv;
+	/*if thres>=2347 (default case) hostapd sends down (u32) -1*/
+	if (value > 65536)
+		dev->rts_threshold = 65536;
+	else
+		dev->rts_threshold = value;
+	return 0;
+
+}
+int sta_add(struct ieee80211_hw *hw,
+	    struct ieee80211_vif *vif,
+	    struct ieee80211_sta *sta)
+{
+	struct umac_vif *uvif = (struct umac_vif *)vif->drv_priv;
+	struct peer_sta_info peer_st_info = {0};
+	int i;
+	for (i = 0; i < STA_NUM_BANDS; i++)
+		peer_st_info.supp_rates[i] = sta->supp_rates[i];
+	/*HT info*/
+	peer_st_info.ht_cap = sta->ht_cap.cap;
+	peer_st_info.ht_supported = sta->ht_cap.ht_supported;
+	peer_st_info.vht_supported = sta->vht_cap.vht_supported;
+	peer_st_info.vht_cap = sta->vht_cap.cap;
+	peer_st_info.ampdu_factor = sta->ht_cap.ampdu_factor;
+	peer_st_info.ampdu_density = sta->ht_cap.ampdu_density;
+	peer_st_info.rx_highest = sta->ht_cap.mcs.rx_highest;
+	peer_st_info.tx_params = sta->ht_cap.mcs.tx_params;
+	peer_st_info.uapsd_queues = sta->uapsd_queues;
+
+	/* will be used in enforcing rules during Aggregation*/
+	uvif->peer_ampdu_factor = (1 << (13 + sta->ht_cap.ampdu_factor)) - 1;
+
+	if (sta->vht_cap.vht_supported) {
+		if (sta->vht_cap.cap & IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE)
+			uvif->dev->params->vht_beamform_support = 1;
+
+	}
+	for (i = 0; i < HT_MCS_MASK_LEN; i++)
+		peer_st_info.rx_mask[i] = sta->ht_cap.mcs.rx_mask[i];
+
+	for (i = 0; i < ETH_ALEN; i++)
+		peer_st_info.addr[i] = sta->addr[i];
+
+	return uccp420wlan_sta_add(uvif->vif_index, &peer_st_info);
+}
+int sta_remove(struct ieee80211_hw *hw,
+	       struct ieee80211_vif *vif,
+	       struct ieee80211_sta *sta)
+{
+	struct umac_vif *uvif = (struct umac_vif *)vif->drv_priv;
+	struct peer_sta_info peer_st_info = {0};
+	int i;
+	for (i = 0; i < ETH_ALEN; i++)
+		peer_st_info.addr[i] = sta->addr[i];
+
+	return uccp420wlan_sta_remove(uvif->vif_index, &peer_st_info);
+}
+
+static int load_fw(struct ieee80211_hw *hw)
+{
+	int err = 0;
+	int i = 0;
+	struct mac80211_dev *dev = (struct mac80211_dev *)hw->priv;
+	const struct firmware *fw = NULL;
+	const char *bin_name[FWLDR_NUM_BINS] = {FWLDR_HW_BIN,
+						FWLDR_FW_BIN};
+
+	do {
+		err = request_firmware(&fw, bin_name[i], dev->dev);
+
+		if (err) {
+			pr_err("Failed to get %s, Error = %d\n",
+			       bin_name[i],
+			       err);
+			break;
+		}
+
+		err = fwldr_load_fw(fw->data, i);
+
+		if (err == FWLDR_SUCCESS)
+			pr_info("%s is loaded\n", bin_name[i]);
+		else
+			pr_err("Loading of %s failed\n", bin_name[i]);
+
+		release_firmware(fw);
+
+		i++;
+
+	} while ((i < FWLDR_NUM_BINS) && (!err));
+
+	return err;
+}
+
+
+static struct ieee80211_ops ops = {
+	.tx                 = tx,
+	.start              = start,
+	.stop               = stop,
+	.add_interface      = add_interface,
+	.remove_interface   = remove_interface,
+	.config             = config,
+	.prepare_multicast  = prepare_multicast,
+	.configure_filter   = configure_filter,
+	.sw_scan_start      = NULL,
+	.sw_scan_complete   = NULL,
+	.get_stats          = NULL,
+	.sta_notify         = NULL,
+	.conf_tx            = conf_vif_tx,
+	.bss_info_changed   = bss_info_changed,
+	.set_tim            = NULL,
+	.set_key            = set_key,
+	.get_tkip_seq       = NULL,
+	.tx_last_beacon     = tx_last_beacon,
+	.ampdu_action       = ampdu_action,
+	.set_antenna	    = set_antenna,
+	.remain_on_channel = remain_on_channel,
+	.cancel_remain_on_channel = cancel_remain_on_channel,
+#ifdef CONFIG_PM
+	.suspend	    = img_suspend,
+	.resume		    = img_resume,
+#endif
+	.hw_scan	    = scan,
+	.cancel_hw_scan	    = cancel_hw_scan,
+	.set_rekey_data     = NULL,
+	.set_rts_threshold  = set_rts_threshold,
+	.sta_add	    = sta_add,
+	.sta_remove	    = sta_remove,
+};
+
+static void uccp420wlan_exit(void)
+{
+	/* DEV Release */
+	struct mac80211_dev *dev = (struct mac80211_dev *)wifi->hw->priv;
+
+	ieee80211_unregister_hw(wifi->hw);
+	device_release_driver(dev->dev);
+	device_destroy(hwsim_class, 0);
+	ieee80211_free_hw(wifi->hw);
+	wifi->hw = NULL;
+
+	class_destroy(hwsim_class);
+}
+
+static int uccp420wlan_init(void)
+{
+	struct ieee80211_hw *hw;
+	int error;
+	struct mac80211_dev *dev = NULL;
+	int i;
+
+	/* Allocate new hardware device */
+	hw = ieee80211_alloc_hw(sizeof(struct mac80211_dev), &ops);
+
+	if (hw == NULL) {
+		pr_err("Failed to allocate memory for ieee80211_hw\n");
+		error = -ENOMEM;
+		goto out;
+	}
+
+	dev = (struct mac80211_dev *)hw->priv;
+
+	hwsim_class = class_create(THIS_MODULE, "uccp420");
+
+	if (IS_ERR(hwsim_class)) {
+		pr_err("Failed to create the device class\n");
+		error = PTR_ERR(hwsim_class);
+		goto out;
+	}
+
+	/* Only 1 per physical intf*/
+	dev->dev = device_create(hwsim_class, NULL, 0, hw, "uccwlan");
+
+	if (IS_ERR(dev->dev)) {
+		pr_err("uccwlan: device_create failed (%ld)\n",
+		       PTR_ERR(dev->dev));
+		error = -ENOMEM;
+		goto auto_dev_class_failed;
+	}
+
+	dev->dev->driver = &img_uccp_driver.driver;
+
+	if (device_is_registered(dev->dev)) {
+		error = device_bind_driver(dev->dev);
+	} else {
+		pr_err("Device is not registered\n");
+		error = -ENODEV;
+		goto failed_hw;
+	}
+
+	if (error != 0) {
+		pr_err("uccwlan: device_bind_driver failed (%d)\n", error);
+		goto failed_hw;
+	}
+
+	pr_info("MAC ADDR: %pM\n", vif_macs);
+	SET_IEEE80211_DEV(hw, dev->dev);
+
+	mutex_init(&dev->mutex);
+	spin_lock_init(&dev->bcast_lock);
+
+	dev->state = STOPPED;
+	dev->active_vifs = 0;
+	dev->txpower = DEFAULT_TX_POWER;
+	dev->tx_antenna = DEFAULT_TX_ANT_SELECT;
+	dev->rts_threshold = DEFAULT_RTS_THRESHOLD;
+	strncpy(dev->name, UCCP_DRIVER_NAME, 11);
+	dev->name[11] = '\0';
+
+	for (i = 0; i < wifi->params.num_vifs; i++)
+		ether_addr_copy(dev->if_mac_addresses[i].addr, vif_macs[i]);
+
+	/* Initialize HW parameters */
+	init_hw(hw);
+	dev->hw = hw;
+	dev->params = &wifi->params;
+	dev->stats = &wifi->stats;
+	dev->umac_proc_dir_entry = wifi->umac_proc_dir_entry;
+	dev->stats->system_rev = system_rev;
+
+	/*Register hardware*/
+	error = ieee80211_register_hw(hw);
+
+	/* Production test hack: Set all channel flags to 0 to allow IBSS
+	 * creation in all channels
+	 */
+	if (wifi->params.production_test && !error) {
+		enum ieee80211_band band;
+		struct ieee80211_supported_band *sband;
+		for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
+			sband = hw->wiphy->bands[band];
+			if (sband)
+				for (i = 0; i < sband->n_channels; i++)
+					sband->channels[i].flags = 0;
+		}
+	}
+
+	if (!error) {
+		wifi->hw = hw;
+		goto out;
+	} else {
+		uccp420wlan_exit();
+		goto out;
+	}
+
+failed_hw:
+	device_release_driver(dev->dev);
+	device_destroy(hwsim_class, 0);
+auto_dev_class_failed:
+	class_destroy(hwsim_class);
+out:
+	return error;
+}
+
+
+static int proc_read_config(struct seq_file *m, void *v)
+{
+	int i = 0;
+	int cnt = 0;
+	int rf_params_size = sizeof(wifi->params.rf_params) /
+			     sizeof(wifi->params.rf_params[0]);
+
+	seq_puts(m, "************* Configurable Parameters ***********\n");
+	seq_printf(m, "dot11g_support = %d\n", wifi->params.dot11g_support);
+	seq_printf(m, "dot11a_support = %d\n", wifi->params.dot11a_support);
+	seq_printf(m, "sensitivity = %d\n", wifi->params.ed_sensitivity);
+	seq_printf(m, "auto_sensitivity = %d\n", wifi->params.auto_sensitivity);
+	/*RF Input params*/
+	seq_puts(m, "rf_params =");
+	for (i = 0; i < rf_params_size; i++)
+		seq_printf(m, " %02X", wifi->params.rf_params[i]);
+
+	seq_puts(m, "\n");
+
+	seq_puts(m, "rf_params_vpd =");
+	for (i = 0; i < rf_params_size; i++)
+		seq_printf(m, " %02X", wifi->params.rf_params_vpd[i]);
+
+	seq_puts(m, "\n");
+
+	seq_printf(m, "production_test = %d\n", wifi->params.production_test);
+	seq_printf(m, "tx_fixed_mcs_indx = %d (%s)\n",
+		   wifi->params.tx_fixed_mcs_indx,
+		   (wifi->params.prod_mode_rate_flag &
+		    ENABLE_VHT_FORMAT) ?
+		   "VHT" : (wifi->params.prod_mode_rate_flag &
+			    ENABLE_11N_FORMAT) ? "HT" : "Not Set");
+	if (wifi->params.tx_fixed_rate > -1) {
+		if (wifi->params.tx_fixed_rate == 55)
+			seq_puts(m, "tx_fixed_rate = 5.5\n");
+		else
+			seq_printf(m, "tx_fixed_rate = %d\n",
+				   wifi->params.tx_fixed_rate);
+	} else
+		seq_printf(m, "tx_fixed_rate = %d\n",
+			   wifi->params.tx_fixed_rate);
+	seq_printf(m, "num_spatial_streams (Per Frame) = %d\n",
+		   wifi->params.num_spatial_streams);
+	seq_printf(m, "uccp_num_spatial_streams (UCCP Init) = %d\n",
+		   wifi->params.uccp_num_spatial_streams);
+	seq_printf(m, "antenna_sel (UCCP Init) = %d\n",
+		   wifi->params.antenna_sel);
+	seq_printf(m, "max_data_size = %d (%dK)\n",
+		   wifi->params.max_data_size,
+		   wifi->params.max_data_size/1024);
+	seq_printf(m, "max_tx_cmds = %d\n",
+		   wifi->params.max_tx_cmds);
+	seq_printf(m, "disable_power_save (Disables all power save's) = %d\n",
+		   wifi->params.disable_power_save);
+	seq_printf(m, "disable_sm_power_save (Disables MIMO PS only) = %d\n",
+		   wifi->params.disable_sm_power_save);
+	seq_printf(m, "mgd_mode_tx_fixed_mcs_indx = %d (%s)\n",
+		   wifi->params.mgd_mode_tx_fixed_mcs_indx,
+		   (wifi->params.prod_mode_rate_flag &
+		    ENABLE_VHT_FORMAT) ?
+		   "VHT" : (wifi->params.prod_mode_rate_flag &
+			    ENABLE_11N_FORMAT) ? "HT" : "Not Set");
+	if (wifi->params.mgd_mode_tx_fixed_rate > -1) {
+		if (wifi->params.mgd_mode_tx_fixed_rate == 55)
+			seq_puts(m, "mgd_mode_tx_fixed_rate = 5.5\n");
+		else
+			seq_printf(m, "mgd_mode_tx_fixed_rate = %d\n",
+				   wifi->params.mgd_mode_tx_fixed_rate);
+	} else
+		seq_printf(m, "mgd_mode_tx_fixed_rate = %d\n",
+			   wifi->params.mgd_mode_tx_fixed_rate);
+
+	seq_printf(m, "num_vifs = %d\n",
+		   wifi->params.num_vifs);
+
+	seq_printf(m, "chnl_bw = %d\n",
+		   wifi->params.chnl_bw);
+
+	seq_printf(m, "prod_mode_chnl_bw_40_mhz = %d\n",
+		   wifi->params.prod_mode_chnl_bw_40_mhz);
+	if (vht_support)
+		seq_printf(m, "prod_mode_chnl_bw_80_mhz = %d\n",
+			   wifi->params.prod_mode_chnl_bw_80_mhz);
+	seq_printf(m, "sec_ch_offset_40_plus = %d\n",
+		   wifi->params.sec_ch_offset_40_plus);
+	seq_printf(m, "sec_ch_offset_40_minus = %d\n",
+		   wifi->params.sec_ch_offset_40_minus);
+
+	if (vht_support) {
+		seq_printf(m, "sec_40_ch_offset_80_plus = %d\n",
+			   wifi->params.sec_40_ch_offset_80_plus);
+		seq_printf(m, "sec_40_ch_offset_80_minus = %d\n",
+			   wifi->params.sec_40_ch_offset_80_minus);
+	}
+	seq_printf(m, "rate_protection_type = %d (0: Disable, 1: Enable)\n",
+		   wifi->params.rate_protection_type);
+	seq_puts(m, "Bits:80MHz-VHT-11N-SGI-40MHz-GF\n");
+	seq_printf(m, "prod_mode_rate_flag = %d\n",
+		   wifi->params.prod_mode_rate_flag);
+	seq_printf(m, "prod_mode_rate_preamble_type (0: Short, 1: Long) = %d\n",
+		   wifi->params.prod_mode_rate_preamble_type);
+	seq_printf(m, "prod_mode_stbc_enabled = %d\n",
+		   wifi->params.prod_mode_stbc_enabled);
+	seq_printf(m, "prod_mode_bcc_or_ldpc = %d\n",
+		   wifi->params.prod_mode_bcc_or_ldpc);
+	seq_printf(m, "vht_beamformer_enable = %d\n",
+		   wifi->params.vht_beamform_enable);
+	seq_printf(m, "vht_beamformer_period = %dms\n",
+		   wifi->params.vht_beamform_period);
+	seq_printf(m, "bg_scan_enable = %d\n",
+		   wifi->params.bg_scan_enable);
+	seq_puts(m, "bg_scan_channel_list =");
+
+	for (i = 0; i < wifi->params.bg_scan_num_channels;  i++) {
+		if (wifi->params.bg_scan_channel_list[i])
+			seq_printf(m, " %d",
+				   wifi->params.bg_scan_channel_list[i]);
+	}
+
+	seq_puts(m, "\n");
+	seq_puts(m, "bg_scan_channel_flags =");
+
+	for (i = 0; i < wifi->params.bg_scan_num_channels;  i++) {
+		if (wifi->params.bg_scan_channel_flags[i])
+			seq_printf(m, " %d",
+				   wifi->params.bg_scan_channel_flags[i]);
+	}
+
+	seq_puts(m, "\n");
+	seq_printf(m, "bg_scan_intval = %dms\n",
+		   wifi->params.bg_scan_intval/1000);
+
+	/*currently not used in LMAC, so don't export to user*/
+#if 0
+	seq_printf(m, "bg_scan_chan_dur = %d\n", wifi->params.bg_scan_chan_dur);
+	seq_printf(m, "bg_scan_serv_chan_dur = %d\n",
+		   wifi->params.bg_scan_serv_chan_dur);
+#endif
+	seq_printf(m, "bg_scan_num_channels = %d\n",
+		   wifi->params.bg_scan_num_channels);
+	seq_printf(m, "nw_selection = %d\n",
+		   wifi->params.nw_selection);
+	seq_printf(m, "scan_type = %d (PASSIVE: 0, ACTIVE: 1)\n",
+		   wifi->params.scan_type);
+#ifdef PERF_PROFILING
+	seq_printf(m, "driver_tput = %d\n",
+		   wifi->params.driver_tput);
+#endif
+	seq_printf(m, "fw_loading = %d\n", wifi->params.fw_loading);
+	seq_printf(m, "bt_state = %d\n", wifi->params.bt_state);
+
+	/* Beacon Time Stamp */
+	for (cnt = 0; cnt < MAX_VIFS; cnt++) {
+		unsigned long long ts1;
+		unsigned long long bssid, atu;
+		int status;
+		char dev_name[10];
+		unsigned int t2;
+
+		spin_lock_bh(&tsf_lock);
+		ts1 = get_unaligned_le64(wifi->params.sync[cnt].ts1);
+		bssid = get_unaligned_le64(wifi->params.sync[cnt].bssid);
+		status = wifi->params.sync[cnt].status;
+		sprintf(dev_name, "%s%d", "wlan", cnt);
+		atu = wifi->params.sync[cnt].atu;
+		t2 = wifi->params.sync[cnt].ts2;
+		spin_unlock_bh(&tsf_lock);
+		if (status && wifi->params.sync[cnt].name)
+			seq_printf(m, "sync=%s %d %llu %llu %llx t2=%u\n",
+				dev_name, status, (unsigned long long)ts1,
+				atu, (unsigned long long) bssid, t2);
+	}
+
+	seq_puts(m, "****** Production Test (or) FTM Parameters *******\n");
+	seq_printf(m, "pkt_gen_val = %d (-1: Infinite loop)\n",
+		   wifi->params.pkt_gen_val);
+	seq_printf(m, "payload_length = %d bytes\n",
+		   wifi->params.payload_length);
+	seq_printf(m, "start_prod_mode = channel: %d\n",
+		   wifi->params.start_prod_mode);
+
+	if (ftm || wifi->params.production_test)
+		seq_printf(m, "set_tx_power = %d dB\n",
+			   wifi->params.set_tx_power);
+
+	if (ftm)
+		seq_printf(m, "aux_adc_chain_id = %d\n",
+			   wifi->params.aux_adc_chain_id);
+
+	seq_puts(m, "To see the updated stats\n");
+	seq_puts(m, "please run: echo get_stats=1 > /proc/uccp420/params\n");
+	seq_puts(m, "To see the cleared phy stats\n");
+	seq_puts(m, "please run: echo clear_stats=1 > /proc/uccp420/params\n");
+	seq_puts(m, "************* VERSION ***********\n");
+	seq_printf(m, "UCCP_DRIVER_VERSION = %s\n", UCCP_DRIVER_VERSION);
+
+	if (wifi->hw &&
+	    (((struct mac80211_dev *)(wifi->hw->priv))->state != STARTED)) {
+		seq_printf(m, "LMAC_VERSION = %s\n", "UNKNOWN");
+		seq_printf(m, "Firmware version = %s\n", "UNKNOWN");
+	} else {
+		seq_printf(m, "LMAC_VERSION = %s\n",
+			   wifi->stats.uccp420_lmac_version);
+		seq_printf(m, "Firmware version= %d.%d\n",
+			   (wifi->stats.uccp420_lmac_version[0] - '0'),
+			   (wifi->stats.uccp420_lmac_version[2] - '0'));
+	}
+
+	return 0;
+}
+
+
+static int proc_read_phy_stats(struct seq_file *m, void *v)
+{
+
+	int i = 0;
+
+	seq_puts(m, "************* BB Stats ***********\n");
+	seq_printf(m, "ed_cnt=%d\n",
+		   wifi->stats.ed_cnt);
+	seq_printf(m, "mpdu_cnt=%d\n",
+		   wifi->stats.mpdu_cnt);
+	seq_printf(m, "ofdm_crc32_pass_cnt=%d\n",
+		   wifi->stats.ofdm_crc32_pass_cnt);
+	seq_printf(m, "ofdm_crc32_fail_cnt=%d\n",
+		   wifi->stats.ofdm_crc32_fail_cnt);
+	seq_printf(m, "dsss_crc32_pass_cnt=%d\n",
+		   wifi->stats.dsss_crc32_pass_cnt);
+	seq_printf(m, "dsss_crc32_fail_cnt=%d\n",
+		   wifi->stats.dsss_crc32_fail_cnt);
+	seq_printf(m, "mac_id_pass_cnt=%d\n",
+		   wifi->stats.mac_id_pass_cnt);
+	seq_printf(m, "mac_id_fail_cnt=%d\n",
+		   wifi->stats.mac_id_fail_cnt);
+	seq_printf(m, "ofdm_corr_pass_cnt=%d\n",
+		   wifi->stats.ofdm_corr_pass_cnt);
+	seq_printf(m, "ofdm_corr_fail_cnt=%d\n",
+		   wifi->stats.ofdm_corr_fail_cnt);
+	seq_printf(m, "dsss_corr_pass_cnt=%d\n",
+		   wifi->stats.dsss_corr_pass_cnt);
+	seq_printf(m, "dsss_corr_fail_cnt=%d\n",
+		   wifi->stats.dsss_corr_fail_cnt);
+	seq_printf(m, "ofdm_s2l_fail_cnt=%d\n",
+		   wifi->stats.ofdm_s2l_fail_cnt);
+	seq_printf(m, "lsig_fail_cnt=%d\n",
+		   wifi->stats.lsig_fail_cnt);
+	seq_printf(m, "htsig_fail_cnt=%d\n",
+		   wifi->stats.htsig_fail_cnt);
+	seq_printf(m, "vhtsiga_fail_cnt=%d\n",
+		   wifi->stats.vhtsiga_fail_cnt);
+	seq_printf(m, "vhtsigb_fail_cnt=%d\n",
+		   wifi->stats.vhtsigb_fail_cnt);
+	seq_printf(m, "nonht_ofdm_cnt=%d\n",
+		   wifi->stats.nonht_ofdm_cnt);
+	seq_printf(m, "nonht_dsss_cnt=%d\n",
+		   wifi->stats.nonht_dsss_cnt);
+	seq_printf(m, "mm_cnt=%d\n",
+		   wifi->stats.mm_cnt);
+	seq_printf(m, "gf_cnt=%d\n",
+		   wifi->stats.gf_cnt);
+	seq_printf(m, "vht_cnt=%d\n",
+		   wifi->stats.vht_cnt);
+	seq_printf(m, "aggregation_cnt=%d\n",
+		   wifi->stats.aggregation_cnt);
+	seq_printf(m, "non_aggregation_cnt=%d\n",
+		   wifi->stats.non_aggregation_cnt);
+	seq_printf(m, "ndp_cnt=%d\n",
+		   wifi->stats.ndp_cnt);
+	seq_printf(m, "ofdm_ldpc_cnt=%d\n",
+		   wifi->stats.ofdm_ldpc_cnt);
+	seq_printf(m, "ofdm_bcc_cnt=%d\n",
+		   wifi->stats.ofdm_bcc_cnt);
+	seq_printf(m, "midpacket_cnt=%d\n",
+		   wifi->stats.midpacket_cnt);
+	seq_printf(m, "dsss_sfd_fail_cnt=%d\n",
+		   wifi->stats.dsss_sfd_fail_cnt);
+	seq_printf(m, "dsss_hdr_fail_cnt=%d\n",
+		   wifi->stats.dsss_hdr_fail_cnt);
+	seq_printf(m, "dsss_short_preamble_cnt=%d\n",
+		   wifi->stats.dsss_short_preamble_cnt);
+	seq_printf(m, "dsss_long_preamble_cnt=%d\n",
+		   wifi->stats.dsss_long_preamble_cnt);
+	seq_printf(m, "sifs_event_cnt=%d\n",
+		   wifi->stats.sifs_event_cnt);
+	seq_printf(m, "cts_cnt=%d\n",
+		   wifi->stats.cts_cnt);
+	seq_printf(m, "ack_cnt=%d\n",
+		   wifi->stats.ack_cnt);
+	seq_printf(m, "sifs_no_resp_cnt=%d\n",
+		   wifi->stats.sifs_no_resp_cnt);
+	seq_printf(m, "unsupported_cnt=%d\n",
+		   wifi->stats.unsupported_cnt);
+	seq_printf(m, "l1_corr_fail_cnt=%d\n",
+		   wifi->stats.l1_corr_fail_cnt);
+	seq_printf(m, "phy_stats_reserved22=%d\n",
+		   wifi->stats.phy_stats_reserved22);
+	seq_printf(m, "phy_stats_reserved23=%d\n",
+		   wifi->stats.phy_stats_reserved23);
+	seq_printf(m, "phy_stats_reserved24=%d\n",
+		   wifi->stats.phy_stats_reserved24);
+	seq_printf(m, "phy_stats_reserved25=%d\n",
+		   wifi->stats.phy_stats_reserved25);
+	seq_printf(m, "phy_stats_reserved26=%d\n",
+		   wifi->stats.phy_stats_reserved26);
+	seq_printf(m, "phy_stats_reserved27=%d\n",
+		   wifi->stats.phy_stats_reserved27);
+	seq_printf(m, "phy_stats_reserved28=%d\n",
+		   wifi->stats.phy_stats_reserved28);
+	seq_printf(m, "phy_stats_reserved29=%d\n",
+		   wifi->stats.phy_stats_reserved29);
+	seq_printf(m, "phy_stats_reserved30=%d\n",
+		   wifi->stats.phy_stats_reserved30);
+	seq_printf(m, "tx_pkts_from_lmac = %d\n",
+		   wifi->stats.tx_pkts_from_lmac);
+	seq_printf(m, "tx_pkts_tx2tx = %d\n", wifi->stats.tx_pkts_tx2tx);
+	seq_printf(m, "tx_pkts_from_rx = %d\n", wifi->stats.tx_pkts_from_rx);
+	seq_printf(m, "tx_pkts_ofdm = %d\n", wifi->stats.tx_pkts_ofdm);
+	seq_printf(m, "tx_pkts_dsss = %d\n", wifi->stats.tx_pkts_dsss);
+	seq_printf(m, "tx_pkts_reached_end_of_fsm = %d\n",
+		   wifi->stats.tx_pkts_reached_end_of_fsm);
+	seq_printf(m, "tx_unsupported_modulation = %d\n",
+		   wifi->stats.tx_unsupported_modulation);
+	seq_printf(m, "tx_latest_pkt_from_lmac_or_sifs = %d\n",
+		   wifi->stats.tx_latest_pkt_from_lmac_or_sifs);
+	seq_printf(m, "tx_abort_bt_confirm_cnt = %d\n",
+		   wifi->stats.tx_abort_bt_confirm_cnt);
+	seq_printf(m, "tx_abort_txstart_timeout_cnt = %d\n",
+		   wifi->stats.tx_abort_txstart_timeout_cnt);
+	seq_printf(m, "tx_abort_midBT_cnt = %d\n",
+		   wifi->stats.tx_abort_mid_bt_cnt);
+	seq_printf(m, "tx_abort_dac_underrun_cnt = %d\n",
+		   wifi->stats.tx_abort_dac_underrun_cnt);
+	seq_printf(m, "tx_ofdm_symbols_master = %d\n",
+		   wifi->stats.tx_ofdm_symbols_master);
+	seq_printf(m, "tx_ofdm_symbols_slave1 = %d\n",
+		   wifi->stats.tx_ofdm_symbols_slave1);
+	seq_printf(m, "tx_ofdm_symbols_slave2 = %d\n",
+		   wifi->stats.tx_ofdm_symbols_slave2);
+	seq_printf(m, "tx_dsss_symbols = %d\n", wifi->stats.tx_dsss_symbols);
+	seq_puts(m, "************* RF Stats ***********\n");
+	/*RF output data*/
+	seq_puts(m, "rf_calib_data =");
+	for (i = 0; i < wifi->stats.rf_calib_data_length; i++)
+		seq_printf(m, "%02X", wifi->stats.rf_calib_data[i]);
+
+	seq_puts(m, "\n");
+	return 0;
+}
+
+static int proc_read_mac_stats(struct seq_file *m, void *v)
+{
+	unsigned int index;
+	unsigned int total_samples = 0;
+	unsigned int total_value = 0;
+	int total_rssi_samples = 0;
+	int total_rssi_value = 0;
+
+	if (ftm) {
+		for (index = 0; index < MAX_AUX_ADC_SAMPLES; index++) {
+			if (!wifi->params.pdout_voltage[index])
+				continue;
+
+			total_value += wifi->params.pdout_voltage[index];
+			total_samples++;
+		}
+	}
+
+	for (index = 0; index < MAX_RSSI_SAMPLES; index++) {
+
+		if (!wifi->params.production_test)
+			break;
+
+		if (!wifi->params.rssi_average[index])
+			continue;
+
+		total_rssi_value += wifi->params.rssi_average[index];
+		total_rssi_samples++;
+	}
+
+	seq_puts(m, "************* UMAC STATS ***********\n");
+	seq_printf(m, "rx_packet_mgmt_count = %d\n",
+		   wifi->stats.rx_packet_mgmt_count);
+	seq_printf(m, "rx_packet_data_count = %d\n",
+		   wifi->stats.rx_packet_data_count);
+	seq_printf(m, "tx_packet_count(HT MCS0) = %d\n",
+		   wifi->stats.ht_tx_mcs0_packet_count);
+	seq_printf(m, "tx_packet_count(HT MCS1) = %d\n",
+		   wifi->stats.ht_tx_mcs1_packet_count);
+	seq_printf(m, "tx_packet_count(HT MCS2) = %d\n",
+		   wifi->stats.ht_tx_mcs2_packet_count);
+	seq_printf(m, "tx_packet_count(HT MCS3) = %d\n",
+		   wifi->stats.ht_tx_mcs3_packet_count);
+	seq_printf(m, "tx_packet_count(HT MCS4) = %d\n",
+		   wifi->stats.ht_tx_mcs4_packet_count);
+	seq_printf(m, "tx_packet_count(HT MCS5) = %d\n",
+		   wifi->stats.ht_tx_mcs5_packet_count);
+	seq_printf(m, "tx_packet_count(HT MCS6) = %d\n",
+		   wifi->stats.ht_tx_mcs6_packet_count);
+	seq_printf(m, "tx_packet_count(HT MCS7) = %d\n",
+		   wifi->stats.ht_tx_mcs7_packet_count);
+
+	if (wifi->params.uccp_num_spatial_streams == 2) {
+		seq_printf(m, "tx_packet_count(HT MCS8) = %d\n",
+			   wifi->stats.ht_tx_mcs8_packet_count);
+		seq_printf(m, "tx_packet_count(HT MCS9) = %d\n",
+			   wifi->stats.ht_tx_mcs9_packet_count);
+		seq_printf(m, "tx_packet_count(HT MCS10) = %d\n",
+			   wifi->stats.ht_tx_mcs10_packet_count);
+		seq_printf(m, "tx_packet_count(HT MCS11) = %d\n",
+			   wifi->stats.ht_tx_mcs11_packet_count);
+		seq_printf(m, "tx_packet_count(HT MCS12) = %d\n",
+			   wifi->stats.ht_tx_mcs12_packet_count);
+		seq_printf(m, "tx_packet_count(HT MCS13) = %d\n",
+			   wifi->stats.ht_tx_mcs13_packet_count);
+		seq_printf(m, "tx_packet_count(HT MCS14) = %d\n",
+			   wifi->stats.ht_tx_mcs14_packet_count);
+		seq_printf(m, "tx_packet_count(HT MCS15) = %d\n",
+			   wifi->stats.ht_tx_mcs15_packet_count);
+	}
+	if (vht_support) {
+		seq_printf(m, "tx_packet_count(VHT MCS0) = %d\n",
+			   wifi->stats.vht_tx_mcs0_packet_count);
+		seq_printf(m, "tx_packet_count(VHT MCS1) = %d\n",
+			   wifi->stats.vht_tx_mcs1_packet_count);
+		seq_printf(m, "tx_packet_count(VHT MCS2) = %d\n",
+			   wifi->stats.vht_tx_mcs2_packet_count);
+		seq_printf(m, "tx_packet_count(VHT MCS3) = %d\n",
+			   wifi->stats.vht_tx_mcs3_packet_count);
+		seq_printf(m, "tx_packet_count(VHT MCS4) = %d\n",
+			   wifi->stats.vht_tx_mcs4_packet_count);
+		seq_printf(m, "tx_packet_count(VHT MCS5) = %d\n",
+			   wifi->stats.vht_tx_mcs5_packet_count);
+		seq_printf(m, "tx_packet_count(VHT MCS6) = %d\n",
+			   wifi->stats.vht_tx_mcs6_packet_count);
+		seq_printf(m, "tx_packet_count(VHT MCS7) = %d\n",
+			   wifi->stats.vht_tx_mcs7_packet_count);
+		seq_printf(m, "tx_packet_count(VHT MCS8) = %d\n",
+			   wifi->stats.vht_tx_mcs8_packet_count);
+		seq_printf(m, "tx_packet_count(VHT MCS9) = %d\n",
+			   wifi->stats.vht_tx_mcs9_packet_count);
+	}
+	seq_printf(m, "tx_cmds_from_stack= %d\n",
+		   wifi->stats.tx_cmds_from_stack);
+	seq_printf(m, "tx_dones_to_stack= %d\n",
+		   wifi->stats.tx_dones_to_stack);
+	seq_printf(m, "oustanding_cmd_cnt = %d\n",
+		   wifi->stats.outstanding_cmd_cnt);
+	seq_printf(m, "gen_cmd_send_count = %d\n",
+		   wifi->stats.gen_cmd_send_count);
+	seq_printf(m, "umac_scan_req = %d\n",
+		   wifi->stats.umac_scan_req);
+	seq_printf(m, "umac_scan_complete = %d\n",
+		   wifi->stats.umac_scan_complete);
+	seq_printf(m, "tx_cmd_send_count_single = %d\n",
+		   wifi->stats.tx_cmd_send_count_single);
+	seq_printf(m, "tx_cmd_send_count_multi = %d\n",
+		   wifi->stats.tx_cmd_send_count_multi);
+	seq_printf(m, "tx_done_recv_count = %d\n",
+		   wifi->stats.tx_done_recv_count);
+	if (ftm)
+		seq_printf(m, "pdout_val = %d (total samples: %d)\n",
+			   total_samples ? (total_value/total_samples) : 0,
+			   total_samples);
+	if (wifi->params.production_test)
+		seq_printf(m,
+			   "rssi_average = %d dBm (total rssi samples: %d)\n",
+			   total_rssi_samples ?
+			   (total_rssi_value/total_rssi_samples) : 0,
+			   total_rssi_samples);
+
+	seq_puts(m, "************* LMAC STATS ***********\n");
+	/* TX related */
+	seq_printf(m, "tx_cmd_cnt =%d\n",
+		   wifi->stats.tx_cmd_cnt);
+	seq_printf(m, "tx_done_cnt =%d\n",
+		   wifi->stats.tx_done_cnt);
+	seq_printf(m, "tx_edca_trigger_cnt =%d\n",
+		   wifi->stats.tx_edca_trigger_cnt);
+	seq_printf(m, "tx_edca_isr_cnt =%d\n",
+		   wifi->stats.tx_edca_isr_cnt);
+	seq_printf(m, "tx_start_cnt =%d\n",
+		   wifi->stats.tx_start_cnt);
+	seq_printf(m, "tx_abort_cnt =%d\n",
+		   wifi->stats.tx_abort_cnt);
+	seq_printf(m, "tx_abort_isr_cnt =%d\n",
+		   wifi->stats.tx_abort_isr_cnt);
+	seq_printf(m, "tx_underrun_cnt =%d\n",
+		   wifi->stats.tx_underrun_cnt);
+	seq_printf(m, "tx_rts_cnt =%d\n",
+		   wifi->stats.tx_rts_cnt);
+	seq_printf(m, "tx_ampdu_cnt =%d\n",
+		   wifi->stats.tx_ampdu_cnt);
+	seq_printf(m, "tx_mpdu_cnt =%d\n",
+		   wifi->stats.tx_mpdu_cnt);
+
+	/* RX related */
+	seq_printf(m, "rx_isr_cnt  =%d\n",
+		   wifi->stats.rx_isr_cnt);
+	seq_printf(m, "rx_ack_cts_to_cnt =%d\n",
+		   wifi->stats.rx_ack_cts_to_cnt);
+	seq_printf(m, "rx_cts_cnt =%d\n",
+		   wifi->stats.rx_cts_cnt);
+	seq_printf(m, "rx_ack_resp_cnt =%d\n",
+		   wifi->stats.rx_ack_resp_cnt);
+	seq_printf(m, "rx_ba_resp_cnt =%d\n",
+		   wifi->stats.rx_ba_resp_cnt);
+	seq_printf(m, "rx_fail_in_ba_bitmap_cnt =%d\n",
+		   wifi->stats.rx_fail_in_ba_bitmap_cnt);
+	seq_printf(m, "rx_circular_buffer_free_cnt =%d\n",
+		   wifi->stats.rx_circular_buffer_free_cnt);
+	seq_printf(m, "rx_mic_fail_cnt =%d\n",
+		   wifi->stats.rx_mic_fail_cnt);
+
+	/* HAL related */
+	seq_printf(m, "hal_cmd_cnt  =%d\n",
+		   wifi->stats.hal_cmd_cnt);
+	seq_printf(m, "hal_event_cnt =%d\n",
+		   wifi->stats.hal_event_cnt);
+	seq_printf(m, "hal_ext_ptr_null_cnt =%d\n",
+		   wifi->stats.hal_ext_ptr_null_cnt);
+
+	return 0;
+
+}
+
+static long param_get_val(unsigned char *buf,
+			  unsigned char *str,
+			  unsigned long *val)
+{
+	unsigned char *temp;
+
+	if (strstr(buf, str)) {
+		temp = strstr(buf, "=") + 1;
+		/*To handle the fixed rate 5.5Mbps case*/
+		if (!strncmp(temp, "5.5", 3)) {
+			*val = 55;
+			return 1;
+		} else if (!kstrtoul(temp, 0, val)) {
+			return 1;
+		} else {
+			return 0;
+		}
+	} else {
+		return 0;
+	}
+}
+
+static long param_get_sval(unsigned char *buf,
+			   unsigned char *str,
+			   long *val)
+{
+
+	unsigned char *temp;
+	if (strstr(buf, str)) {
+		temp = strstr(buf, "=") + 1;
+		/*To handle the fixed rate 5.5Mbps case*/
+		if (!strncmp(temp, "5.5", 3)) {
+			*val = 55;
+			return 1;
+		} else if (!kstrtol(temp, 0, val)) {
+			return 1;
+		} else {
+			return 0;
+		}
+	} else {
+		return 0;
+	}
+
+}
+
+static long param_get_match(unsigned char *buf, unsigned char *str)
+{
+
+	if (strstr(buf, str))
+		return 1;
+	else
+		return 0;
+}
+static ssize_t proc_write_config(struct file *file,
+				 const char __user *buffer,
+				 size_t count,
+				 loff_t *ppos)
+{
+	char buf[(RF_PARAMS_SIZE * 2) + 50];
+	unsigned long val;
+	long sval;
+
+	if (count >= sizeof(buf))
+		count = sizeof(buf) - 1;
+
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	buf[count] = '\0';
+
+	if (param_get_val(buf, "dot11a_support=", &val)) {
+		if (((val == 0) || (val == 1)) &&
+		    (wifi->params.dot11a_support != val)) {
+			wifi->params.dot11a_support = val;
+
+			if ((wifi->params.dot11g_support == 0) &&
+			    (wifi->params.dot11a_support == 0)) {
+				pr_err("Invalid parameter value. Both bands can't be disabled, at least 1 is needed\n");
+			} else {
+				if (wifi->hw) {
+					uccp420wlan_exit();
+					wifi->hw = NULL;
+				}
+
+				pr_info("Re-initializing UMAC ..with 2.4GHz support %s and 5GHz support %s\n",
+					wifi->params.dot11g_support == 0 ?
+					"disabled" : "enabled",
+					wifi->params.dot11a_support == 0 ?
+					"disabled" : "enabled");
+
+				uccp420wlan_init();
+			}
+		} else
+			pr_err("Invalid parameter value\n");
+	} else if (param_get_val(buf, "dot11g_support=", &val)) {
+		if (((val == 0) || (val == 1)) &&
+		    (wifi->params.dot11g_support != val)) {
+			wifi->params.dot11g_support = val;
+
+			if ((wifi->params.dot11g_support == 0) &&
+			    (wifi->params.dot11a_support == 0)) {
+				pr_err("Invalid parameter value. Both bands can't be disabled, at least 1 is needed\n");
+			} else {
+				if (wifi->hw) {
+					uccp420wlan_exit();
+					wifi->hw = NULL;
+				}
+
+				pr_info("Re-initializing UMAC ..with 2.4GHz support %s and 5GHz support %s\n",
+					wifi->params.dot11g_support == 0 ?
+					"disabled" : "enabled",
+					wifi->params.dot11a_support == 0 ?
+					"disabled" : "enabled");
+
+				uccp420wlan_init();
+			}
+		} else
+			pr_err("Invalid parameter value\n");
+	} else if (param_get_sval(buf, "sensitivity=", &sval)) {
+		/*if (sval > -51 || sval < -96 || (sval % 3 != 0))*/
+		/*	pr_err("Invalid parameter value\n");*/
+		/*else*/
+		wifi->params.ed_sensitivity = sval;
+	} else if (param_get_val(buf, "auto_sensitivity=", &val)) {
+		if ((val == 0) || (val == 1))
+			wifi->params.auto_sensitivity = val;
+		else
+			pr_err("Invalid parameter value.\n");
+	} else if (param_get_val(buf, "production_test=", &val)) {
+		if ((val == 0) || (val == 1)) {
+			if (wifi->params.production_test != val) {
+				if (wifi->params.production_test)
+					wifi->params.num_vifs = 1;
+
+				wifi->params.production_test = val;
+
+				if (wifi->hw) {
+					uccp420wlan_exit();
+					wifi->hw = NULL;
+				}
+
+				pr_err("Re-initializing UMAC ..\n");
+				uccp420wlan_init();
+			}
+		} else
+			pr_err("Invalid parameter value\n");
+	} else if (param_get_val(buf, "num_vifs=", &val)) {
+		if (val > 0 && val <= MAX_VIFS) {
+			if (wifi->params.num_vifs != val) {
+				if (wifi->hw) {
+					uccp420wlan_exit();
+					wifi->hw = NULL;
+				}
+
+				pr_err("Re-initializing UMAC ..\n");
+				wifi->params.num_vifs = val;
+
+				uccp420wlan_init();
+			}
+		}
+	} else if (param_get_match(buf, "rf_params=")) {
+		conv_str_to_byte(wifi->params.rf_params,
+				strstr(buf, "=") + 1,
+				RF_PARAMS_SIZE);
+	} else if (param_get_val(buf, "rx_packet_mgmt_count=", &val)) {
+		wifi->stats.rx_packet_mgmt_count = val;
+	} else if (param_get_val(buf, "rx_packet_data_count=", &val)) {
+		wifi->stats.rx_packet_data_count = val;
+	} else if (param_get_val(buf, "pdout_val=", &val)) {
+		wifi->stats.pdout_val = val;
+	} else if (param_get_val(buf, "get_stats=", &val)) {
+		uccp420wlan_prog_mib_stats();
+	} else if (param_get_val(buf, "max_data_size=", &val)) {
+		if (wifi->params.max_data_size != val) {
+			if ((wifi->params.max_data_size >= 2 * 1024) &&
+			    (wifi->params.max_data_size <= (12 * 1024))) {
+				wifi->params.max_data_size = val;
+
+				if (wifi->hw) {
+					uccp420wlan_exit();
+					wifi->hw = NULL;
+				}
+
+				pr_err("Re-initalizing UCCP420 with %ld as max data size\n",
+				       val);
+
+				uccp420wlan_init();
+			} else
+				pr_err("Invalid Value for max data size: should be (2K-12K)\n");
+		}
+	} else if (param_get_val(buf, "max_tx_cmds=", &val)) {
+		if (val >= 1 || val <= MAX_TX_CMDS)
+			wifi->params.max_tx_cmds = val;
+	} else if (param_get_val(buf, "disable_power_save=", &val)) {
+		if ((val == 0) || (val == 1)) {
+			if (val != wifi->params.disable_power_save) {
+				wifi->params.disable_power_save = val;
+
+				if (wifi->hw) {
+					uccp420wlan_exit();
+					wifi->hw = NULL;
+				}
+
+				pr_err("Re-initalizing UCCP420 with global powerave %s\n",
+				       val ? "DISABLED" : "ENABLED");
+
+				uccp420wlan_init();
+			}
+		}
+	} else if (param_get_val(buf, "disable_sm_power_save=", &val)) {
+		if ((val == 0) || (val == 1)) {
+			if (val != wifi->params.disable_sm_power_save) {
+				wifi->params.disable_sm_power_save = val;
+
+				if (wifi->hw) {
+					uccp420wlan_exit();
+					wifi->hw = NULL;
+				}
+
+				pr_err("Re-initalizing UCCP420 with smps %s\n",
+				       val ? "DISABLED" : "ENABLED");
+
+				uccp420wlan_init();
+			}
+		}
+	} else if (param_get_val(buf, "uccp_num_spatial_streams=", &val)) {
+		if (val > 0 && val <= min(MAX_TX_STREAMS, MAX_RX_STREAMS)) {
+			if (val != wifi->params.uccp_num_spatial_streams) {
+				wifi->params.uccp_num_spatial_streams = val;
+				wifi->params.num_spatial_streams = val;
+				wifi->params.max_tx_streams = val;
+				wifi->params.max_rx_streams = val;
+				if (wifi->hw) {
+					uccp420wlan_exit();
+					wifi->hw = NULL;
+				}
+				pr_err("Re-initalizing UCCP420 with %ld spatial streams\n",
+				       val);
+				uccp420wlan_init();
+			}
+		} else
+			pr_err("Invalid parameter value: Allowed Range: 1 to %d\n",
+			       min(MAX_TX_STREAMS, MAX_RX_STREAMS));
+	} else if (param_get_val(buf, "antenna_sel=", &val)) {
+		if (val == 1 || val == 2) {
+			if (val != wifi->params.antenna_sel) {
+				wifi->params.antenna_sel = val;
+				if (wifi->hw) {
+					uccp420wlan_exit();
+					wifi->hw = NULL;
+				}
+				pr_err("Re-initalizing UCCP420 with %ld antenna selection \n",
+				       val);
+				uccp420wlan_init();
+			}
+		} else
+			pr_err("Invalid parameter value: Allowed Values: 1 or 2\n");
+	} else if (param_get_val(buf, "num_spatial_streams=", &val)) {
+		if (val > 0 && val <= wifi->params.uccp_num_spatial_streams)
+			wifi->params.num_spatial_streams = val;
+		else
+			pr_err("Invalid parameter value, should be less than or equal to uccp_num_spatial_streams\n");
+	} else if (param_get_sval(buf, "mgd_mode_tx_fixed_mcs_indx=", &sval)) {
+		if (wifi->params.mgd_mode_tx_fixed_rate == -1) {
+
+			int mcs_indx = wifi->params.mgd_mode_tx_fixed_mcs_indx;
+
+			if (vht_support && (wifi->params.prod_mode_rate_flag &
+					    ENABLE_VHT_FORMAT)) {
+				if ((sval >= -1) && (sval <= 9)) {
+					/* Get_rate will do the MCS holes
+					 * validation
+					 */
+					mcs_indx = sval;
+				} else
+					pr_err("Invalid parameter value.\n");
+			} else {
+				if (wifi->params.num_spatial_streams == 2) {
+					if ((sval >= -1) && (sval <= 15))
+						mcs_indx = sval;
+					else
+						pr_err("Invalid MIMO HT MCS: %ld\n",
+						       sval);
+				}
+				if (wifi->params.num_spatial_streams == 1) {
+					if ((sval >= -1) && (sval <= 7))
+						mcs_indx = sval;
+					else
+						pr_err("Invalid SISO HT MCS: %ld\n",
+						       sval);
+				}
+			}
+
+			wifi->params.mgd_mode_tx_fixed_mcs_indx = mcs_indx;
+		} else
+			pr_err("Fixed rate other than MCS index is currently set\n");
+	} else if (param_get_sval(buf, "mgd_mode_tx_fixed_rate=", &sval)) {
+		if (wifi->params.mgd_mode_tx_fixed_mcs_indx == -1) {
+			int tx_fixed_rate = wifi->params.mgd_mode_tx_fixed_rate;
+			if (wifi->params.dot11g_support == 1 &&
+			    ((sval == 1) ||
+			     (sval == 2) ||
+			     (sval == 55) ||
+			     (sval == 11))) {
+				tx_fixed_rate = sval;
+			} else if ((sval == 6) ||
+				   (sval == 9) ||
+				   (sval == 12) ||
+				   (sval == 18) ||
+				   (sval == 24) ||
+				   (sval == 36) ||
+				   (sval == 48) ||
+				   (sval == 54) ||
+				   (sval == -1)) {
+				tx_fixed_rate = sval;
+			} else {
+				pr_err("Invalid parameter value.\n");
+				return count;
+			}
+			wifi->params.mgd_mode_tx_fixed_rate = tx_fixed_rate;
+		} else
+			pr_err("MCS data rate(index) is currently set\n");
+	} else if (param_get_sval(buf, "tx_fixed_mcs_indx=", &sval)) {
+
+		do {
+			if (wifi->params.production_test != 1) {
+				pr_err("Only can be set in production mode\n");
+				break;
+			}
+
+			if ((wifi->params.num_spatial_streams == 2) &&
+			    (sval >= -1) && (sval <= 15))
+				wifi->params.tx_fixed_mcs_indx = sval;
+			else
+				pr_err("Invalid MIMO HT MCS: %ld\n", sval);
+
+			if ((wifi->params.num_spatial_streams == 1) &&
+			    (sval >= -1) && (sval <= 7))
+				wifi->params.tx_fixed_mcs_indx = sval;
+			else
+				pr_err("Invalid SISO HT MCS: %ld\n", sval);
+
+		} while (0);
+
+		if (wifi->params.production_test == 1 &&
+		    wifi->params.tx_fixed_rate == -1 &&
+		    vht_support && (wifi->params.prod_mode_rate_flag &
+				    ENABLE_VHT_FORMAT)) {
+
+			if (!((sval >= -1) && (sval <= 9)))
+				pr_err("Invalid parameter value.\n");
+
+			if ((sval >= -1) && (sval <= 9))
+				wifi->params.tx_fixed_mcs_indx = sval;
+
+			if ((wifi->params.prod_mode_chnl_bw_40_mhz == 0) &&
+			    (wifi->params.prod_mode_chnl_bw_80_mhz == 0) &&
+			    (sval == 9)) {
+				pr_err("Invalid VHT MCS: 20MHZ-MCS9.\n");
+
+				/*Reset to Default*/
+				wifi->params.tx_fixed_mcs_indx = 7;
+			}
+		}
+
+	} else if (param_get_sval(buf, "tx_fixed_rate=", &sval)) {
+		if (wifi->params.production_test == 1) {
+			if (wifi->params.tx_fixed_mcs_indx == -1) {
+				if ((wifi->params.dot11g_support == 1) &&
+				    ((sval == 1) ||
+				     (sval == 2) ||
+				     (sval == 55) ||
+				     (sval == 11))) {
+					wifi->params.tx_fixed_rate = sval;
+				} else if ((sval == 6) ||
+					   (sval == 9) ||
+					   (sval == 12) ||
+					   (sval == 18) ||
+					   (sval == 24) ||
+					   (sval == 36) ||
+					   (sval == 48) ||
+					   (sval == 54) ||
+					   (sval == -1)) {
+					wifi->params.tx_fixed_rate = sval;
+				} else {
+					pr_err("Invalid parameter value.\n");
+					return count;
+				}
+			} else
+				pr_err("MCS data rate(index) is currently set\n");
+		} else
+			pr_err("Only can be set in production mode.\n");
+	} else if (param_get_val(buf, "chnl_bw=", &val)) {
+		if (((val == 0) ||
+		    (vht_support && (val == 2)) ||
+		     (val == 1))) {
+			wifi->params.chnl_bw = val;
+
+			if (wifi->hw) {
+				uccp420wlan_exit();
+				wifi->hw = NULL;
+			}
+
+			pr_err("Re-initializing UMAC ..\n");
+
+			uccp420wlan_init();
+		} else
+			pr_err("Invalid parameter value.\n");
+	} else if (param_get_val(buf, "prod_mode_chnl_bw_40_mhz=", &val)) {
+
+		do {
+			if (wifi->params.production_test != 1) {
+				pr_err("Can be set in only in production mode.\n");
+				break;
+			}
+
+			if (!((val == 0) || (val == 1))) {
+				pr_err("Invalid parameter value.\n");
+				break;
+			}
+
+			wifi->params.prod_mode_chnl_bw_40_mhz = val;
+
+			if (!vht_support)
+				break;
+
+			wifi->params.prod_mode_chnl_bw_80_mhz = 0;
+		} while (0);
+
+	} else if (vht_support &&
+		   param_get_val(buf, "prod_mode_chnl_bw_80_mhz=", &val)) {
+		if (wifi->params.production_test == 1) {
+			if ((val == 0) || (val == 1)) {
+				wifi->params.prod_mode_chnl_bw_40_mhz = 0;
+				wifi->params.prod_mode_chnl_bw_80_mhz = val;
+			} else
+				pr_err("Invalid parameter value.\n");
+		} else
+			pr_err("Can be set in only in production mode.\n");
+	} else if (param_get_val(buf, "sec_ch_offset_40_plus=", &val)) {
+		do {
+			if (wifi->params.production_test != 1) {
+				pr_err("Can be set in only in production mode.\n");
+				break;
+			}
+
+			if (!((wifi->params.prod_mode_chnl_bw_40_mhz == 1)
+			    || (vht_support &&
+				(wifi->params.prod_mode_chnl_bw_80_mhz == 1))
+			    )) {
+				pr_err("Can be set only when prod_mode_chnl_bw_40_mhz is set.\n");
+				break;
+			}
+
+
+			if (wifi->params.sec_ch_offset_40_minus == 1) {
+				pr_err("Can be set only when sec_ch_offset_40_minus is not set\n");
+				break;
+			}
+
+			if (!((val == 0) || (val == 1))) {
+				pr_err("Invalid parameter value.\n");
+				break;
+			}
+
+			wifi->params.sec_ch_offset_40_plus = val;
+
+		} while (0);
+
+	} else if (param_get_val(buf, "sec_ch_offset_40_minus=", &val)) {
+		do {
+			if (wifi->params.production_test != 1) {
+				pr_err("Can be set in only in production mode.\n");
+				break;
+			}
+
+			if (!((wifi->params.prod_mode_chnl_bw_40_mhz == 1)
+			    || (vht_support &&
+				(wifi->params.prod_mode_chnl_bw_80_mhz == 1))
+			    )) {
+				pr_err("Can be set only when prod_mode_chnl_bw_40_mhz is set.\n");
+				break;
+			}
+
+
+			if (wifi->params.sec_ch_offset_40_plus == 1) {
+				pr_err("Can be set only when sec_ch_offset_40_plus is not set\n");
+				break;
+			}
+
+			if (!((val == 0) || (val == 1))) {
+				pr_err("Invalid parameter value.\n");
+				break;
+			}
+
+			wifi->params.sec_ch_offset_40_minus = val;
+
+		} while (0);
+
+	} else if (vht_support &&
+		   param_get_val(buf, "sec_40_ch_offset_80_plus=", &val)) {
+		do {
+			if (wifi->params.production_test != 1) {
+				pr_err("Can be set in only in production mode.\n");
+				break;
+			}
+
+			if (!(wifi->params.prod_mode_chnl_bw_80_mhz == 1)) {
+				pr_err("Can be set if prod_mode_chnl_bw_80_mhz is set\n");
+				break;
+			}
+
+
+			if (wifi->params.sec_40_ch_offset_80_minus == 1) {
+				pr_err("Can be set only when sec_40_ch_offset_80_minus is not set\n");
+				break;
+			}
+
+			if (!((val == 0) || (val == 1))) {
+				pr_err("Invalid parameter value.\n");
+				break;
+			}
+
+			wifi->params.sec_40_ch_offset_80_plus = val;
+
+		} while (0);
+
+	} else if (vht_support &&
+		   (param_get_val(buf, "sec_40_ch_offset_80_minus=", &val))) {
+		do {
+			if (wifi->params.production_test != 1) {
+				pr_err("Can be set in only in production mode.\n");
+				break;
+			}
+
+			if (!(wifi->params.prod_mode_chnl_bw_80_mhz == 1)) {
+				pr_err("Can be set if prod_mode_chnl_bw_80_mhz is set\n");
+				break;
+			}
+
+
+			if (wifi->params.sec_40_ch_offset_80_plus == 1) {
+				pr_err("Can be set only when sec_40_ch_offset_80_plus is not set\n");
+				break;
+			}
+
+			if (!((val == 0) || (val == 1))) {
+				pr_err("Invalid parameter value.\n");
+				break;
+			}
+
+			wifi->params.sec_40_ch_offset_80_minus = val;
+
+		} while (0);
+	} else if (param_get_val(buf, "prod_mode_rate_flag=", &val)) {
+		do {
+			/*Only first 6 flags are defined currently*/
+			if (val > 63)
+				pr_err("Invalid parameter value");
+
+			if ((val & ENABLE_VHT_FORMAT) &&
+			    (val & ENABLE_11N_FORMAT)) {
+				pr_err("Cannot set HT and VHT both.");
+				break;
+			}
+
+			if ((val & ENABLE_CHNL_WIDTH_40MHZ) &&
+			    (val & ENABLE_CHNL_WIDTH_80MHZ)) {
+				pr_err("Cannot set 40 and 80 both.");
+				break;
+			}
+
+			if ((wifi->params.uccp_num_spatial_streams == 1)  &&
+			    (val & ENABLE_SGI) &&
+			    (val & ENABLE_GREEN_FIELD)) {
+				pr_err("Cannot set GreenField when SGI is enabled for SISO");
+				break;
+			}
+
+			wifi->params.prod_mode_rate_flag = val;
+		} while (0);
+
+	} else if (param_get_val(buf, "rate_protection_type=", &val)) {
+		/* 0 is None, 1 is RTS/CTS, 2 is for CTS2SELF */
+		if ((val == 0) || (val == 1) /*|| (val == 2)*/)
+			wifi->params.rate_protection_type = val;
+		else
+			pr_err("Invalid parameter value");
+	} else if (param_get_val(buf, "prod_mode_rate_preamble_type=", &val)) {
+		/*0 is short, 1 is Long*/
+		if ((val == 0) || (val == 1))
+			wifi->params.prod_mode_rate_preamble_type = val;
+		else
+			pr_err("Invalid parameter value");
+	} else if (param_get_val(buf, "prod_mode_stbc_enabled=", &val)) {
+		if (val <= 1)
+			wifi->params.prod_mode_stbc_enabled = val;
+		else
+			pr_err("Invalid parameter value\n");
+	} else if (param_get_val(buf, "prod_mode_bcc_or_ldpc=", &val)) {
+		if (val <= 1)
+			wifi->params.prod_mode_bcc_or_ldpc = val;
+		else
+			pr_err("Invalid parameter value\n");
+	} else if (param_get_val(buf, "reset_hal_params=", &val)) {
+		if (((struct mac80211_dev *)
+		     (wifi->hw->priv))->state != STARTED) {
+			if (val != 1)
+				pr_err("Invalid parameter value\n");
+			else
+				hal_ops.reset_hal_params();
+		} else
+			pr_err("HAL parameters reset can be done only when all interface are down\n");
+	} else if (param_get_val(buf, "vht_beamformer_enable=", &val)) {
+		do {
+			int vht_beamform_period;
+
+			if (wifi->params.vht_beamform_enable != val)
+				break;
+
+			if (!((val == VHT_BEAMFORM_ENABLE) ||
+			      (val == VHT_BEAMFORM_DISABLE))) {
+				pr_err("Invalid VHT Beamforming Enable value should be 1 or 0\n");
+				break;
+			}
+
+			wifi->params.vht_beamform_enable = val;
+
+			/* If not associated, it will be sent upon
+			 * association
+			 */
+			if (!wifi->params.is_associated)
+				break;
+
+			vht_beamform_period = wifi->params.vht_beamform_period;
+
+			uccp420wlan_prog_vht_bform(val, vht_beamform_period);
+		} while (0);
+
+	} else if (param_get_val(buf, "vht_beamformer_period=", &val)) {
+
+		do {
+			int vht_beamform_enable;
+
+			if (wifi->params.vht_beamform_enable !=
+			    VHT_BEAMFORM_ENABLE) {
+				pr_err("VHT Beamforming is disabled, please enable it first\n");
+				break;
+			}
+
+			if (wifi->params.vht_beamform_enable != val)
+				break;
+
+			if (!((val > 100) || (val < 10000))) {
+				pr_err("Invalid VHT Beamforming Period must be between 100-10000ms\n");
+				break;
+			}
+
+			wifi->params.vht_beamform_period = val;
+
+			/* If not associated, it will be sent upon
+			 * association
+			 */
+			if (!wifi->params.is_associated)
+				break;
+
+			vht_beamform_enable = wifi->params.vht_beamform_period;
+
+			uccp420wlan_prog_vht_bform(vht_beamform_enable, val);
+		} while (0);
+
+	} else if (param_get_val(buf, "bg_scan_enable=", &val)) {
+		if (wifi->params.bg_scan_enable != val) {
+			if ((val == 1) || (val == 0)) {
+				wifi->params.bg_scan_enable = val;
+				if (wifi->hw) {
+					uccp420wlan_exit();
+					wifi->hw = NULL;
+				}
+				pr_err("Re-initializing UMAC ..\n");
+				uccp420wlan_init();
+			} else
+				pr_err("Invalid bg_scan_enable value should be 1 or 0\n");
+		}
+	} else if (param_get_match(buf, "bg_scan_channel_list=")) {
+		conv_str_to_byte(wifi->params.bg_scan_channel_list,
+				 strstr(buf, "=") + 1,
+				 50);
+	} else if (param_get_match(buf, "bg_scan_channel_flags=")) {
+		conv_str_to_byte(wifi->params.bg_scan_channel_flags,
+				 strstr(buf, "=") + 1,
+				 50);
+	} else if (param_get_val(buf, "bg_scan_intval=", &val)) {
+		if ((val >= 1000) && (val <= 60000))
+			wifi->params.bg_scan_intval = val * 1000;/* us */
+		else
+			pr_err("Invalid bgscan duration/interval value should be between 1000 to 60000 ms.\n");
+#if 0
+		/*currently not used in LMAC, so don't export to user*/
+	} else if (param_get_val(buf, "bg_scan_chan_dur =", &val)) {
+		if ((val >= 100) && (val <= 1000))
+			wifi->params.bg_scan_chan_dur = val;
+		else
+			pr_err("Invalid chan duration value should be between 100 to 1000.\n");
+	} else if (param_get_val(buf, "bg_scan_serv_chan_dur =", &val)) {
+		if ((val >= 100) && (val <= 1000))
+			wifi->params.bg_scan_serv_chan_dur = val;
+		else
+			pr_err("Invalid serv chan duration value should be between 100 to 1000.\n");
+#endif
+	} else if (param_get_val(buf, "bg_scan_num_channels=", &val)) {
+		wifi->params.bg_scan_num_channels = val;
+	} else if (param_get_val(buf, "nw_selection=", &val)) {
+		if ((val == 1) || (val == 0)) {
+			wifi->params.nw_selection = val;
+			pr_err("in nw_selection\n");
+			uccp420wlan_prog_nw_selection(1, vif_macs[0]);
+		} else
+			pr_err("Invalid nw selection value should be 1 or 0\n");
+	} else if (param_get_val(buf, "scan_type=", &val)) {
+		if ((val == 0) || (val == 1))
+			wifi->params.scan_type = val;
+		else
+			pr_err("Invalid scan type value %d, should be 0 or 1\n",
+			       (unsigned int)val);
+	} else if (ftm && param_get_val(buf, "aux_adc_chain_id=", &val)) {
+		memset(wifi->params.pdout_voltage, 0 ,
+		       sizeof(char) * MAX_AUX_ADC_SAMPLES);
+		if ((val == AUX_ADC_CHAIN1) || (val == AUX_ADC_CHAIN2)) {
+			wifi->params.aux_adc_chain_id = val;
+			uccp420wlan_prog_aux_adc_chain(val);
+		} else
+			pr_err("Invalid chain id %d, should be %d or %d\n",
+			       (unsigned int) val,
+			       AUX_ADC_CHAIN1,
+			       AUX_ADC_CHAIN2);
+	} else if ((wifi->params.production_test) &&
+		    param_get_val(buf, "start_prod_mode=", &val)) {
+			unsigned int pri_chnl_num = 0;
+			unsigned int chnl_num1 = 0;
+			unsigned int chnl_num2 = 0;
+			unsigned int freq_band = IEEE80211_BAND_5GHZ;
+			unsigned int ch_width = 0;
+			int center_freq = 0;
+			int cf_offset = 0;
+			int is_vht_bw80 = 0;
+			int is_vht_bw80_sec_40minus = 0;
+			int is_vht_bw80_sec_40plus = 0;
+			struct mac80211_dev *dev = wifi->hw->priv;
+			pri_chnl_num = val;
+			wifi->params.start_prod_mode = val;
+			tasklet_init(&dev->proc_tx_tasklet, packet_generation,
+				     (unsigned long)dev);
+			if (pri_chnl_num < 15)
+				freq_band = IEEE80211_BAND_2GHZ;
+			else
+				freq_band = IEEE80211_BAND_5GHZ;
+
+			center_freq =
+			ieee80211_channel_to_frequency(pri_chnl_num,
+						       freq_band);
+			cf_offset = center_freq;
+
+			if ((wifi->params.prod_mode_chnl_bw_40_mhz == 1) &&
+			    (wifi->params.sec_ch_offset_40_minus == 1)) {
+				/*  NL80211_CHAN_HT40MINUS */
+				ch_width = 2;
+				cf_offset = center_freq - 10;
+			} else if (wifi->params.prod_mode_chnl_bw_40_mhz == 1) {
+				/* NL80211_CHAN_HT40PLUS */
+				ch_width = 2;
+				cf_offset = center_freq + 10;
+			}
+
+			is_vht_bw80 = vht_support &&
+				(wifi->params.prod_mode_chnl_bw_80_mhz == 1);
+
+			is_vht_bw80_sec_40minus = is_vht_bw80 &&
+				(wifi->params.sec_ch_offset_40_minus == 1);
+
+			is_vht_bw80_sec_40plus = is_vht_bw80 &&
+				(wifi->params.sec_ch_offset_40_plus == 1);
+
+			if (is_vht_bw80)
+				ch_width = 3;
+
+			if (is_vht_bw80_sec_40minus &&
+			    (wifi->params.sec_40_ch_offset_80_minus == 1))
+				cf_offset = center_freq - 30;
+			else if (is_vht_bw80_sec_40minus &&
+				 (wifi->params.sec_40_ch_offset_80_plus == 1))
+				cf_offset = center_freq + 10;
+			else if (is_vht_bw80_sec_40minus)/* default */
+				cf_offset = center_freq - 30;
+
+			if (is_vht_bw80_sec_40plus &&
+			    (wifi->params.sec_40_ch_offset_80_minus == 1))
+				cf_offset = center_freq - 10;
+			else if (is_vht_bw80_sec_40plus &&
+				 (wifi->params.sec_40_ch_offset_80_plus == 1))
+				cf_offset = center_freq + 30;
+			else if (is_vht_bw80_sec_40plus)/* default */
+				cf_offset = center_freq - 10;
+
+			chnl_num1 = ieee80211_frequency_to_channel(cf_offset);
+			chnl_num2 = 0;
+
+			if ((wifi->params.fw_loading == 1) &&
+			     load_fw(dev->hw)) {
+				pr_err("%s: Firmware loading failed\n",
+				       dev->name);
+				goto error;
+			 }
+			if (!uccp420wlan_core_init(dev, ftm)) {
+				uccp420wlan_prog_vif_ctrl(0,
+						dev->if_mac_addresses[0].addr,
+						IF_MODE_STA_IBSS,
+						IF_ADD);
+				proc_bss_info_changed(
+						dev->if_mac_addresses[0].addr,
+						val);
+				uccp420wlan_prog_channel(pri_chnl_num,
+							 chnl_num1,
+							 chnl_num2, ch_width,
+							 freq_band);
+				skb_queue_head_init(&dev->tx.proc_tx_list[0]);
+				wifi->params.init_prod = 1;
+			 } else {
+				pr_err("LMAC Initialization Failed\n");
+				wifi->params.init_prod = 0;
+			}
+
+	} else if ((wifi->params.production_test) && (wifi->params.init_prod)
+		   && param_get_sval(buf, "stop_prod_mode=", &sval)) {
+			struct mac80211_dev *dev = wifi->hw->priv;
+			tasklet_kill(&dev->proc_tx_tasklet);
+			#if 0
+			/* Todo: Enabling this causes RPU Lockup,
+			 * need to debug */
+			uccp420wlan_prog_vif_ctrl(0,
+						  dev->if_mac_addresses[0].addr,
+						  IF_MODE_STA_IBSS,
+						  IF_REM);
+			#endif
+			uccp420wlan_core_deinit(dev, 0);
+			wifi->params.start_prod_mode = 0;
+			wifi->params.pkt_gen_val = 1;
+			hal_ops.reset_hal_params();
+			wifi->params.init_prod = 0;
+	} else if ((wifi->params.production_test) && (wifi->params.init_prod)
+		 &&   param_get_sval(buf, "start_packet_gen=", &sval)) {
+		struct mac80211_dev *dev = wifi->hw->priv;
+		wifi->params.pkt_gen_val = sval;
+		if (sval != 0)
+			tasklet_schedule(&dev->proc_tx_tasklet);
+
+	} else if ((wifi->params.production_test) && (wifi->params.init_prod)
+		 && param_get_sval(buf, "stop_packet_gen=", &sval)) {
+			struct mac80211_dev *dev = wifi->hw->priv;
+			wifi->params.pkt_gen_val = 1;
+			tasklet_kill(&dev->proc_tx_tasklet);
+	} else if ((wifi->params.production_test) &&
+		    param_get_sval(buf, "payload_length=", &sval)) {
+			wifi->params.payload_length = val;
+	} else if ((ftm || wifi->params.production_test) &&
+		    param_get_sval(buf, "set_tx_power=", &sval)) {
+		memset(wifi->params.pdout_voltage, 0 ,
+		       sizeof(char) * MAX_AUX_ADC_SAMPLES);
+		wifi->params.set_tx_power = sval;
+		uccp420wlan_prog_txpower(sval);
+#ifdef PERF_PROFILING
+	} else if (param_get_val(buf, "driver_tput=", &val)) {
+		if ((val == 1) || (val == 0))
+			wifi->params.driver_tput = val;
+		else
+			pr_err("Invalid driver_tput value should be 1 or 0\n");
+#endif
+	} else if (param_get_val(buf, "fw_loading=", &val)) {
+			wifi->params.fw_loading = val;
+	} else if (param_get_val(buf, "bt_state=", &val)) {
+		if (val == 0 || val == 1) {
+			if (val != wifi->params.bt_state) {
+				wifi->params.bt_state = val;
+				uccp420wlan_prog_btinfo(val);
+			}
+		} else
+			pr_err("Invalid parameter value: Allowed values: 0 or 1\n");
+	} else if (param_get_val(buf, "clear_stats=", &val)) {
+		uccp420wlan_prog_clear_stats();
+	} else if (param_get_val(buf, "disable_beacon_ibss=", &val)) {
+		if ((val == 1) || (val == 0))
+			wifi->params.disable_beacon_ibss = val;
+		else
+			pr_err("Invalid driver_tput value should be 1 or 0\n");
+	} else
+		pr_err("Invalid parameter name: %s\n", buf);
+error:
+	return count;
+}
+
+
+static int proc_open_config(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_config, NULL);
+}
+
+
+static int proc_open_phy_stats(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_phy_stats, NULL);
+}
+
+
+static int proc_open_mac_stats(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_mac_stats, NULL);
+}
+
+
+static const struct file_operations params_fops_config = {
+	.open = proc_open_config,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.write = proc_write_config,
+	.release = single_release
+};
+
+static const struct file_operations params_fops_phy_stats = {
+	.open = proc_open_phy_stats,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.write = NULL,
+	.release = single_release
+};
+static const struct file_operations params_fops_mac_stats = {
+	.open = proc_open_mac_stats,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.write = NULL,
+	.release = single_release
+};
+static int proc_init(void)
+{
+	struct proc_dir_entry *entry;
+	int err = 0;
+	unsigned int i = 0;
+	/*2.4GHz and 5 GHz PD and TX-PWR calibration params*/
+	unsigned char rf_params[RF_PARAMS_SIZE * 2];
+
+	strncpy(rf_params,
+		"1E00000000002426292A2C2E3237393F454A52576066000000002B2C3033373A3D44474D51575A61656B6F000000002B2C3033373A3D44474D51575A61656B6F000000002B2C3033373A3D44474D51575A61656B6F000000002B2C3033373A3D44474D51575A61656B6F00000000002426292A2C2E3237393F454A52576066000000002B2C3033373A3D44474D51575A61656B6F000000002B2C3033373A3D44474D51575A61656B6F000000002B2C3033373A3D44474D51575A61656B6F000000002B2C3033373A3D44474D51575A61656B6F0808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808",
+		(RF_PARAMS_SIZE * 2));
+
+	wifi = kzalloc(sizeof(struct wifi_dev), GFP_KERNEL);
+	if (!wifi) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	wifi->umac_proc_dir_entry = proc_mkdir("uccp420", NULL);
+	if (!wifi->umac_proc_dir_entry) {
+		pr_err("Failed to create proc dir\n");
+		err = -ENOMEM;
+		goto  proc_dir_fail;
+	}
+
+	entry = proc_create("params", 0644, wifi->umac_proc_dir_entry,
+			    &params_fops_config);
+	if (!entry) {
+		pr_err("Failed to create proc entry\n");
+		err = -ENOMEM;
+		goto  proc_entry1_fail;
+	}
+
+	entry = proc_create("phy_stats", 0444, wifi->umac_proc_dir_entry,
+			    &params_fops_phy_stats);
+	if (!entry) {
+		pr_err("Failed to create proc entry\n");
+		err = -ENOMEM;
+		goto  proc_entry2_fail;
+	}
+
+	entry = proc_create("mac_stats", 0444, wifi->umac_proc_dir_entry,
+			    &params_fops_mac_stats);
+	if (!entry) {
+		pr_err("Failed to create proc entry\n");
+		err = -ENOMEM;
+		goto  proc_entry3_fail;
+	}
+
+	/* Initialize WLAN params */
+	memset(&wifi->params, 0, sizeof(struct wifi_params));
+
+	/* TODO: Make this a struct */
+	memset(wifi->params.rf_params, 0xFF, sizeof(wifi->params.rf_params));
+	conv_str_to_byte(wifi->params.rf_params, rf_params, RF_PARAMS_SIZE);
+
+	if (!rf_params_vpd)
+		rf_params_vpd = wifi->params.rf_params;
+
+	memcpy(wifi->params.rf_params_vpd, rf_params_vpd, RF_PARAMS_SIZE);
+
+	wifi->params.is_associated = 0;
+	wifi->params.ed_sensitivity = -89;
+	wifi->params.auto_sensitivity = 1;
+	wifi->params.dot11a_support = 1;
+	wifi->params.dot11g_support = 1;
+	wifi->params.num_vifs = 2;
+
+	/* Check, if required add it */
+	wifi->params.tx_fixed_mcs_indx = -1;
+	wifi->params.tx_fixed_rate = -1;
+	wifi->params.num_spatial_streams = min(MAX_TX_STREAMS, MAX_RX_STREAMS);
+	wifi->params.uccp_num_spatial_streams = min(MAX_TX_STREAMS,
+						    MAX_RX_STREAMS);
+	wifi->params.antenna_sel = 1;
+
+	if (num_streams_vpd > 0)
+		wifi->params.uccp_num_spatial_streams = num_streams_vpd;
+
+	wifi->params.bt_state = 1;
+	wifi->params.mgd_mode_tx_fixed_mcs_indx = -1;
+	wifi->params.mgd_mode_tx_fixed_rate = -1;
+	if (vht_support)
+		wifi->params.chnl_bw = WLAN_80MHZ_OPERATION;
+	else
+		wifi->params.chnl_bw = WLAN_20MHZ_OPERATION;
+	wifi->params.max_tx_streams = MAX_TX_STREAMS;
+	wifi->params.max_rx_streams = MAX_RX_STREAMS;
+	wifi->params.max_data_size  = 8 * 1024;
+
+	wifi->params.vht_beamform_enable = VHT_BEAMFORM_DISABLE;
+	wifi->params.vht_beamform_period = 1000; /* ms */
+	wifi->params.vht_beamform_support = 0;
+	if (vht_support)
+		wifi->params.max_tx_cmds = 24;
+	else
+		wifi->params.max_tx_cmds = 16;
+	wifi->params.disable_power_save = 0;
+	wifi->params.disable_sm_power_save = 0;
+	wifi->params.rate_protection_type = 0; /* Disable protection by def */
+	wifi->params.prod_mode_rate_preamble_type = 1; /* LONG */
+	wifi->params.prod_mode_stbc_enabled = 0;
+	wifi->params.prod_mode_bcc_or_ldpc = 0;
+	wifi->params.bg_scan_enable = 0;
+	memset(wifi->params.bg_scan_channel_list, 0 , 50);
+	memset(wifi->params.bg_scan_channel_flags, 0 , 50);
+
+	if (wifi->params.dot11g_support) {
+		wifi->params.bg_scan_num_channels = 3;
+
+		wifi->params.bg_scan_channel_list[i] = 1;
+		wifi->params.bg_scan_channel_flags[i++] = ACTIVE;
+
+		wifi->params.bg_scan_channel_list[i] = 6;
+		wifi->params.bg_scan_channel_flags[i++] = ACTIVE;
+
+		wifi->params.bg_scan_channel_list[i] = 11;
+		wifi->params.bg_scan_channel_flags[i++] = ACTIVE;
+	}
+
+	if (wifi->params.dot11a_support) {
+		wifi->params.bg_scan_num_channels += 4;
+
+		wifi->params.bg_scan_channel_list[i] = 36;
+		wifi->params.bg_scan_channel_flags[i++] = ACTIVE;
+
+		wifi->params.bg_scan_channel_list[i] = 40;
+		wifi->params.bg_scan_channel_flags[i++] = ACTIVE;
+
+		wifi->params.bg_scan_channel_list[i] = 44;
+		wifi->params.bg_scan_channel_flags[i++] = ACTIVE;
+
+		wifi->params.bg_scan_channel_list[i] = 48;
+		wifi->params.bg_scan_channel_flags[i++] = ACTIVE;
+	}
+
+	wifi->params.disable_beacon_ibss = 0;
+	wifi->params.pkt_gen_val = -1;
+	wifi->params.payload_length = 4000;
+	wifi->params.start_prod_mode = 0;
+	wifi->params.init_prod = 0;
+	wifi->params.bg_scan_intval = 5000 * 1000; /* Once in 5 seconds */
+	wifi->params.bg_scan_chan_dur = 300; /* Channel spending time */
+	wifi->params.bg_scan_serv_chan_dur = 100; /* Oper chan spending time */
+	wifi->params.nw_selection = 0;
+	wifi->params.scan_type = ACTIVE;
+	wifi->params.hw_scan_status = HW_SCAN_STATUS_NONE;
+	wifi->params.fw_loading = 1;
+
+	return err;
+
+proc_entry3_fail:
+	remove_proc_entry("phy_stats", wifi->umac_proc_dir_entry);
+proc_entry2_fail:
+	remove_proc_entry("params", wifi->umac_proc_dir_entry);
+proc_entry1_fail:
+	remove_proc_entry("uccp420", NULL);
+proc_dir_fail:
+	kfree(wifi);
+out:
+	return err;
+
+}
+
+static void proc_exit(void)
+{
+	remove_proc_entry("mac_stats", wifi->umac_proc_dir_entry);
+	remove_proc_entry("phy_stats", wifi->umac_proc_dir_entry);
+	remove_proc_entry("params", wifi->umac_proc_dir_entry);
+	remove_proc_entry("uccp420", NULL);
+	kfree(wifi);
+}
+
+
+int _uccp420wlan_80211if_init(void)
+{
+	int error;
+	error = proc_init();
+	if (error)
+		return error;
+
+	error = uccp420wlan_init();
+
+	return error;
+}
+
+void _uccp420wlan_80211if_exit(void)
+{
+	if (wifi && wifi->hw) {
+		uccp420wlan_exit();
+		proc_exit();
+	}
+}
diff --git a/drivers/net/wireless/uccp420wlan/src/core.c b/drivers/net/wireless/uccp420wlan/src/core.c
new file mode 100644
index 0000000..6c98af4
--- /dev/null
+++ b/drivers/net/wireless/uccp420wlan/src/core.c
@@ -0,0 +1,1225 @@
+/*
+ * File Name  : core.c
+ *
+ * This file contains the source functions for UMAC core
+ *
+ * Copyright (c) 2011, 2012, 2013, 2014 Imagination Technologies Ltd.
+ * All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#include <linux/rtnetlink.h>
+
+#include "core.h"
+
+#define UMAC_PRINT(fmt, args...) pr_debug(fmt, ##args)
+
+spinlock_t tsf_lock;
+
+unsigned char bss_addr[6] = {72, 14, 29 , 35, 31, 52};
+static int is_robust_mgmt(struct sk_buff *skb)
+{
+	/*TODO: mmie struture not being used now. Uncomment once in use */
+#if 0
+	struct ieee80211_mmie *mmie;
+#endif
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+
+	if (skb->len < 24)
+		return 0;
+
+	if (!((hdr->frame_control & IEEE80211_FCTL_FTYPE) ==
+	      IEEE80211_FTYPE_MGMT))
+		return 0;
+
+	/* Not a BIP frame */
+	if (((hdr->frame_control & IEEE80211_FCTL_STYPE) ==
+	     IEEE80211_STYPE_DISASSOC) ||
+	    ((hdr->frame_control & IEEE80211_FCTL_STYPE) ==
+	     IEEE80211_STYPE_DEAUTH) ||
+	    ((hdr->frame_control & IEEE80211_FCTL_STYPE) ==
+	     IEEE80211_STYPE_ACTION)) {
+		if (((hdr->frame_control & IEEE80211_FCTL_STYPE) ==
+			IEEE80211_STYPE_ACTION)) {
+			u8 *category;
+			category = ((u8 *) hdr) + 24;
+
+			if (*category == WLAN_CATEGORY_PUBLIC ||
+			    *category == WLAN_CATEGORY_HT ||
+			    *category == WLAN_CATEGORY_SELF_PROTECTED ||
+			    *category == WLAN_CATEGORY_VENDOR_SPECIFIC)
+				return 0;
+		}
+	} else {
+		return 0;
+	}
+
+	if ((hdr->addr1[0] & 0x01)) {
+#if 0
+		if (skb->len < (24 + sizeof(*mmie)))
+			return 0;
+
+		mmie = (struct ieee80211_mmie *)(skb->data + skb->len -
+						 sizeof(*mmie));
+		if (mmie->element_id != 76 || mmie->length != sizeof(*mmie) - 2)
+			/* #define WLAN_EID_MMIE = 76;*/
+			return 0;
+#endif
+	} else {
+		if (hdr->frame_control & IEEE80211_FCTL_PROTECTED)
+			return 0;
+	}
+	return 1;
+}
+
+
+int wait_for_scan_abort(struct mac80211_dev *dev)
+{
+	int count;
+	count = 0;
+
+check_scan_abort_complete:
+	if (!dev->scan_abort_done && (count < SCAN_ABORT_TIMEOUT_TICKS)) {
+		current->state = TASK_INTERRUPTIBLE;
+
+		if (0 == schedule_timeout(1))
+			count++;
+
+		goto check_scan_abort_complete;
+	}
+
+	if (!dev->scan_abort_done) {
+		UMAC_PRINT("%s-UMAC: No SCAN_ABORT_DONE after %ld ticks\n",
+			   dev->name, SCAN_ABORT_TIMEOUT_TICKS);
+		return -1;
+	}
+
+	UMAC_PRINT("%s-UMAC: Scan abort complete after %d timer ticks\n",
+		   dev->name, count);
+
+	return 0;
+
+}
+
+
+int wait_for_channel_prog_complete(struct mac80211_dev *dev)
+{
+	int count;
+	count = 0;
+
+check_ch_prog_complete:
+	if (!dev->chan_prog_done && (count < CH_PROG_TIMEOUT_TICKS)) {
+		current->state = TASK_INTERRUPTIBLE;
+
+		if (0 == schedule_timeout(1))
+			count++;
+
+		goto check_ch_prog_complete;
+	}
+
+	if (!dev->chan_prog_done) {
+		UMAC_PRINT("%s-UMAC: No channel prog done after %ld ticks\n",
+			   dev->name, CH_PROG_TIMEOUT_TICKS);
+		return -1;
+	}
+
+	DEBUG_LOG("%s-CORE: Channel Prog Complete after %d timer ticks\n",
+		  dev->name, count);
+
+	return 0;
+
+}
+
+
+int wait_for_reset_complete(struct mac80211_dev *dev)
+{
+	int count;
+	count = 0;
+
+check_reset_complete:
+	if (!dev->reset_complete && (count < RESET_TIMEOUT_TICKS)) {
+		current->state = TASK_INTERRUPTIBLE;
+
+		if (0 == schedule_timeout(1))
+			count++;
+
+		goto check_reset_complete;
+	}
+
+	if (!dev->reset_complete) {
+		UMAC_PRINT("%s-UMAC: No reset complete after %ld ticks\n",
+			   dev->name, RESET_TIMEOUT_TICKS);
+		return -1;
+	}
+
+	UMAC_PRINT("%s-UMAC: Reset complete after %d timer ticks\n",
+		   dev->name, count);
+	return 0;
+
+}
+
+
+#ifdef PERF_PROFILING
+static void driver_tput_timer_expiry(unsigned long data)
+{
+	struct umac_vif *uvif = (struct umac_vif *)data;
+
+	if (uvif->dev->stats->rx_packet_data_count) {
+		pr_info("The RX packets/sec are: %d\n",
+			uvif->dev->stats->rx_packet_data_count);
+
+		uvif->dev->stats->rx_packet_data_count = 0;
+	}
+
+	if (uvif->dev->stats->tx_cmd_send_count_single) {
+		pr_info("The TX packets/sec single are: %d\n",
+			uvif->dev->stats->tx_cmd_send_count_single);
+
+		uvif->dev->stats->tx_cmd_send_count_single = 0;
+	}
+
+	if (uvif->dev->stats->tx_cmd_send_count_multi) {
+		pr_info("The TX packets/sec multi are: %d\n",
+			uvif->dev->stats->tx_cmd_send_count_multi);
+
+		uvif->dev->stats->tx_cmd_send_count_multi = 0;
+	}
+
+	mod_timer(&uvif->driver_tput_timer, jiffies + msecs_to_jiffies(1000));
+
+}
+#endif
+
+void proc_bss_info_changed(unsigned char *mac_addr, int value)
+{
+		int temp = 0, i = 0, j = 0;
+		get_random_bytes(&j, sizeof(j));
+		for (i = 5; i > 0; i--) {
+			j = j % (i+1);
+			temp = bss_addr[i];
+			bss_addr[i] = bss_addr[j];
+			bss_addr[j] = temp;
+			}
+		uccp420wlan_prog_vif_bssid(0, mac_addr, bss_addr);
+
+}
+
+void packet_generation(unsigned long data)
+{
+		struct mac80211_dev *dev = (struct mac80211_dev *)data;
+		unsigned char *mac_addr = dev->if_mac_addresses[0].addr;
+		struct ieee80211_hdr hdr = {0};
+		struct sk_buff *skb;
+		unsigned char broad_addr[6] = {0xff, 0xff, 0xff ,
+					       0xff, 0xff, 0xff};
+		u16 hdrlen = 26;
+
+		/*LOOP_START*/
+		/*PREPARE_SKB_LIST and SEND*/
+
+		skb = alloc_skb(dev->params->payload_length + hdrlen,
+				GFP_ATOMIC);
+		ether_addr_copy(hdr.addr1, broad_addr);
+		ether_addr_copy(hdr.addr2, mac_addr);
+		ether_addr_copy(hdr.addr3, bss_addr);
+		hdr.frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |
+						IEEE80211_STYPE_QOS_DATA);
+		memcpy(skb_put(skb, hdrlen), &hdr, hdrlen);
+		memset(skb_put(skb, dev->params->payload_length), 0xAB ,
+			dev->params->payload_length);
+
+		/*LOOP_END*/
+		skb_queue_tail(&dev->tx.proc_tx_list[0], skb);
+		uccp420wlan_proc_tx();
+
+}
+
+static void vif_bcn_timer_expiry(unsigned long data)
+{
+	struct umac_vif *uvif = (struct umac_vif *)data;
+	struct sk_buff *skb, *temp;
+	struct sk_buff_head bcast_frames;
+	unsigned long flags;
+
+	if (uvif->vif->bss_conf.enable_beacon == false)
+		return;
+
+	if (uvif->vif->type == NL80211_IFTYPE_AP) {
+		temp = skb = ieee80211_beacon_get(uvif->dev->hw, uvif->vif);
+
+		if (!skb) {
+			/* No beacon, so dont transmit braodcast frames*/
+			goto reschedule_timer;
+		}
+
+		skb_queue_head_init(&bcast_frames);
+		skb->priority = 1;
+		skb_queue_tail(&bcast_frames, skb);
+
+		skb = ieee80211_get_buffered_bc(uvif->dev->hw, uvif->vif);
+
+		while (skb) {
+			/* Hack: skb->priority is used to indicate more
+			 * frames
+			 */
+			skb->priority = 1;
+			skb_queue_tail(&bcast_frames, skb);
+			temp = skb;
+			skb = ieee80211_get_buffered_bc(uvif->dev->hw,
+							uvif->vif);
+		}
+
+		if (temp)
+			temp->priority = 0;
+
+		spin_lock_irqsave(&uvif->dev->bcast_lock, flags);
+
+		while ((skb = skb_dequeue(&bcast_frames)))
+			uccp420wlan_tx_frame(skb, NULL, uvif->dev, true);
+
+		spin_unlock_irqrestore(&uvif->dev->bcast_lock, flags);
+
+	} else {
+		skb = ieee80211_beacon_get(uvif->dev->hw, uvif->vif);
+
+		if (!skb)
+			goto reschedule_timer;
+
+		uccp420wlan_tx_frame(skb, NULL, uvif->dev, true);
+
+	}
+reschedule_timer:
+	return;
+
+}
+
+
+int uccp420wlan_core_init(struct mac80211_dev *dev, unsigned int ftm)
+{
+
+	DEBUG_LOG("%s-CORE: Init called\n", dev->name);
+	spin_lock_init(&tsf_lock);
+	uccp420wlan_lmac_if_init(dev, dev->name);
+
+	/* Enable the LMAC, set defaults and initialize TX */
+	dev->reset_complete = 0;
+
+	UMAC_PRINT("%s-UMAC: Reset (ENABLE)\n", dev->name);
+
+	if (hal_ops.start(dev->umac_proc_dir_entry))
+		goto lmac_deinit;
+	if (ftm)
+		uccp420wlan_prog_reset(LMAC_ENABLE, LMAC_MODE_FTM);
+	else
+		uccp420wlan_prog_reset(LMAC_ENABLE, LMAC_MODE_NORMAL);
+
+	if (wait_for_reset_complete(dev) < 0)
+		goto hal_stop;
+
+	if (hal_ops.init_bufs(NUM_TX_DESCS,
+			      NUM_RX_BUFS_2K,
+			      NUM_RX_BUFS_12K,
+			      dev->params->max_data_size) < 0)
+		goto hal_stop;
+
+	uccp420wlan_prog_btinfo(dev->params->bt_state);
+	uccp420wlan_prog_global_cfg(512, /* Rx MSDU life time in msecs */
+				    512, /* Tx MSDU life time in msecs */
+				    dev->params->ed_sensitivity,
+				    dev->params->auto_sensitivity,
+				    dev->params->rf_params);
+
+	uccp420wlan_prog_txpower(dev->txpower);
+	uccp420wlan_tx_init(dev);
+
+	return 0;
+hal_stop:
+	hal_ops.stop(dev->umac_proc_dir_entry);
+lmac_deinit:
+	uccp420wlan_lmac_if_deinit();
+	return -1;
+}
+
+
+void uccp420wlan_core_deinit(struct mac80211_dev *dev, unsigned int ftm)
+{
+	DEBUG_LOG("%s-CORE: De-init called\n", dev->name);
+
+	/* De initialize tx  and disable LMAC*/
+	uccp420wlan_tx_deinit(dev);
+
+	/* Disable the LMAC */
+	dev->reset_complete = 0;
+	UMAC_PRINT("%s-UMAC: Reset (DISABLE)\n", dev->name);
+
+	if (ftm)
+		uccp420wlan_prog_reset(LMAC_DISABLE, LMAC_MODE_FTM);
+	else
+		uccp420wlan_prog_reset(LMAC_DISABLE, LMAC_MODE_NORMAL);
+
+
+	wait_for_reset_complete(dev);
+
+	uccp420_lmac_if_free_outstnding();
+
+	hal_ops.stop(dev->umac_proc_dir_entry);
+	hal_ops.deinit_bufs();
+
+	uccp420wlan_lmac_if_deinit();
+
+	return;
+}
+
+
+void uccp420wlan_vif_add(struct umac_vif *uvif)
+{
+	unsigned int type;
+	struct ieee80211_conf *conf = &uvif->dev->hw->conf;
+
+	DEBUG_LOG("%s-CORE: Add VIF %d Type = %d\n",
+		   uvif->dev->name, uvif->vif_index, uvif->vif->type);
+
+	uvif->config.atim_window = uvif->config.bcn_lost_cnt =
+		uvif->config.aid = 0;
+
+	switch (uvif->vif->type) {
+	case NL80211_IFTYPE_STATION:
+		type = IF_MODE_STA_BSS;
+		uvif->noa_active = 0;
+		skb_queue_head_init(&uvif->noa_que);
+		spin_lock_init(&uvif->noa_que.lock);
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		type = IF_MODE_STA_IBSS;
+		init_timer(&uvif->bcn_timer);
+		uvif->bcn_timer.data = (unsigned long)uvif;
+		uvif->bcn_timer.function = vif_bcn_timer_expiry;
+		spin_lock_init(&uvif->noa_que.lock);
+		break;
+	case NL80211_IFTYPE_AP:
+		type = IF_MODE_AP;
+		init_timer(&uvif->bcn_timer);
+		uvif->bcn_timer.data = (unsigned long)uvif;
+		uvif->bcn_timer.function = vif_bcn_timer_expiry;
+		spin_lock_init(&uvif->noa_que.lock);
+		break;
+	default:
+		WARN_ON(1);
+		return;
+	}
+
+#ifdef PERF_PROFILING
+	/* Timer to print stats for tput*/
+	init_timer(&uvif->driver_tput_timer);
+	uvif->driver_tput_timer.data = (unsigned long)uvif;
+	uvif->driver_tput_timer.function = driver_tput_timer_expiry;
+#endif
+	uccp420wlan_prog_vif_ctrl(uvif->vif_index,
+				  uvif->vif->addr,
+				  type,
+				  IF_ADD);
+
+	/* Reprogram retry counts */
+	uccp420wlan_prog_short_retry(uvif->vif_index, uvif->vif->addr,
+					 conf->short_frame_max_tx_count);
+
+	uccp420wlan_prog_long_retry(uvif->vif_index, uvif->vif->addr,
+					conf->long_frame_max_tx_count);
+
+	if (uvif->vif->type == NL80211_IFTYPE_AP) {
+		/* Program the EDCA params */
+		unsigned int queue;
+		unsigned int aifs;
+		unsigned int txop;
+		unsigned int cwmin;
+		unsigned int cwmax;
+		unsigned int uapsd;
+
+		for (queue = 0; queue < 4; queue++) {
+			aifs = uvif->config.edca_params[queue].aifs;
+			txop = uvif->config.edca_params[queue].txop;
+			cwmin = uvif->config.edca_params[queue].cwmin;
+			cwmax = uvif->config.edca_params[queue].cwmax;
+			uapsd = uvif->config.edca_params[queue].uapsd;
+
+			uccp420wlan_prog_txq_params(uvif->vif_index,
+						    uvif->vif->addr,
+						    queue,
+						    aifs,
+						    txop,
+						    cwmin,
+						    cwmax,
+						    uapsd);
+		}
+	}
+}
+
+
+void uccp420wlan_vif_remove(struct umac_vif *uvif)
+{
+	struct sk_buff *skb;
+	unsigned int type;
+	unsigned long flags;
+
+	DEBUG_LOG("%s-CORE: Remove VIF %d called\n", uvif->dev->name,
+		   uvif->vif_index);
+
+	switch (uvif->vif->type) {
+	case NL80211_IFTYPE_STATION:
+		type = IF_MODE_STA_BSS;
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		type = IF_MODE_STA_IBSS;
+		del_timer(&uvif->bcn_timer);
+		break;
+	case NL80211_IFTYPE_AP:
+		type = IF_MODE_AP;
+		del_timer(&uvif->bcn_timer);
+		break;
+	default:
+		WARN_ON(1);
+		return;
+	}
+
+#ifdef PERF_PROFILING
+	del_timer(&uvif->driver_tput_timer);
+#endif
+
+	spin_lock_irqsave(&uvif->noa_que.lock, flags);
+
+	while ((skb = __skb_dequeue(&uvif->noa_que)))
+		dev_kfree_skb(skb);
+
+	spin_unlock_irqrestore(&uvif->noa_que.lock, flags);
+
+	uccp420wlan_prog_vif_ctrl(uvif->vif_index,
+				  uvif->vif->addr,
+				  type,
+				  IF_REM);
+
+}
+
+
+void uccp420wlan_vif_set_edca_params(unsigned short queue,
+				     struct umac_vif *uvif,
+				     struct edca_params *params,
+				     unsigned int vif_active)
+{
+	switch (queue) {
+	case 0:
+		queue = 3; /* Voice */
+		break;
+	case 1:
+		queue = 2; /* Video */
+		break;
+	case 2:
+		queue = 1; /* Best effort */
+		break;
+	case 3:
+		queue = 0; /* Back groud */
+		break;
+	}
+
+	DEBUG_LOG("%s-CORE:Set EDCA params, VIF %d, Val: %d, %d, %d, %d, %d\n",
+		   uvif->dev ? uvif->dev->name : 0, uvif->vif_index, queue,
+		   params->aifs, params->txop, params->cwmin, params->cwmax);
+
+	if (uvif->dev->params->production_test == 0) {
+		/* arbitration interframe space [0..255] */
+		uvif->config.edca_params[queue].aifs = params->aifs;
+
+		/* maximum burst time in units of 32 usecs, 0 meaning disabled*/
+		uvif->config.edca_params[queue].txop = params->txop;
+
+		/* minimum contention window in units of  2^n-1 */
+		uvif->config.edca_params[queue].cwmin = params->cwmin;
+
+		/*  maximum contention window in units of 2^n-1 */
+		uvif->config.edca_params[queue].cwmax = params->cwmax;
+		uvif->config.edca_params[queue].uapsd = params->uapsd;
+	} else {
+		uvif->config.edca_params[queue].aifs = 3;
+		uvif->config.edca_params[queue].txop = 0;
+		uvif->config.edca_params[queue].cwmin = 0;
+		uvif->config.edca_params[queue].cwmax = 0;
+		uvif->config.edca_params[queue].uapsd = 0;
+	}
+
+	/* For the AP case, EDCA params are set before ADD interface is called.
+	 * Since this is not supported, we simply store the params and program
+	 * them to the LMAC after the interface is added
+	 */
+	if (!vif_active)
+		return;
+
+	/* Program the txq parameters into the LMAC */
+	uccp420wlan_prog_txq_params(uvif->vif_index,
+				    uvif->vif->addr,
+				    queue,
+				    params->aifs,
+				    params->txop,
+				    params->cwmin,
+				    params->cwmax,
+				    params->uapsd);
+
+}
+
+
+void uccp420wlan_vif_bss_info_changed(struct umac_vif *uvif,
+				      struct ieee80211_bss_conf *bss_conf,
+				      unsigned int changed)
+{
+	unsigned int bcn_int = 0;
+	unsigned long bcn_tim_val = 0;
+	unsigned int caps = 0;
+	int center_freq = 0;
+	int chan = 0;
+	unsigned int bform_enable = 0;
+	unsigned int bform_per = 0;
+
+	DEBUG_LOG("%s-CORE: BSS INFO changed %d, %d, %d\n", uvif->dev->name,
+		   uvif->vif_index, uvif->vif->type, changed);
+
+
+	if (changed & BSS_CHANGED_BSSID)
+		uccp420wlan_prog_vif_bssid(uvif->vif_index, uvif->vif->addr,
+					   (unsigned char *)bss_conf->bssid);
+
+	if (changed & BSS_CHANGED_BASIC_RATES) {
+		if (bss_conf->basic_rates)
+			uccp420wlan_prog_vif_basic_rates(uvif->vif_index,
+							 uvif->vif->addr,
+							 bss_conf->basic_rates);
+		else
+			uccp420wlan_prog_vif_basic_rates(uvif->vif_index,
+							 uvif->vif->addr,
+							 0x153);
+	}
+
+	if (changed & BSS_CHANGED_ERP_SLOT) {
+		unsigned int queue = 0;
+		unsigned int aifs = 0;
+		unsigned int txop = 0;
+		unsigned int cwmin = 0;
+		unsigned int cwmax = 0;
+		unsigned int uapsd = 0;
+
+		uccp420wlan_prog_vif_short_slot(uvif->vif_index,
+						uvif->vif->addr,
+						bss_conf->use_short_slot);
+
+		for (queue = 0; queue < WLAN_AC_MAX_CNT; queue++) {
+			aifs = uvif->config.edca_params[queue].aifs;
+			txop = uvif->config.edca_params[queue].txop;
+			cwmin = uvif->config.edca_params[queue].cwmin;
+			cwmax = uvif->config.edca_params[queue].cwmax;
+			uapsd = uvif->config.edca_params[queue].uapsd;
+
+			if (uvif->config.edca_params[queue].cwmin != 0)
+				uccp420wlan_prog_txq_params(uvif->vif_index,
+							    uvif->vif->addr,
+							    queue,
+							    aifs,
+							    txop,
+							    cwmin,
+							    cwmax,
+							    uapsd);
+		}
+	}
+
+	switch (uvif->vif->type) {
+	case NL80211_IFTYPE_STATION:
+		if (changed & BSS_CHANGED_ASSOC) {
+			center_freq = bss_conf->chandef.chan->center_freq;
+			chan = ieee80211_frequency_to_channel(center_freq);
+			bform_enable = uvif->dev->params->vht_beamform_enable;
+			bform_per = uvif->dev->params->vht_beamform_period;
+
+			if (bss_conf->assoc) {
+				DEBUG_LOG("%s-CORE: AID %d, CAPS 0x%04x\n",
+					   uvif->dev->name, bss_conf->aid,
+					   bss_conf->assoc_capability |
+					   (bss_conf->qos << 9));
+
+				uccp420wlan_prog_vif_conn_state(uvif->vif_index,
+								uvif->vif->addr,
+								STA_CONN);
+
+				uccp420wlan_prog_vif_aid(uvif->vif_index,
+							 uvif->vif->addr,
+							 bss_conf->aid);
+
+				uccp420wlan_prog_vif_op_channel(uvif->vif_index,
+								uvif->vif->addr,
+								chan);
+
+				caps = (bss_conf->assoc_capability |
+					(bss_conf->qos << 9));
+
+				uccp420wlan_prog_vif_assoc_cap(uvif->vif_index,
+							       uvif->vif->addr,
+							       caps);
+
+				if (uvif->dev->params->vht_beamform_support)
+					uccp420wlan_prog_vht_bform(bform_enable,
+								   bform_per);
+
+				uvif->noa_active = 0;
+				uvif->dev->params->is_associated = 1;
+
+#ifdef PERF_PROFILING
+				mod_timer(&uvif->driver_tput_timer,
+					  jiffies + msecs_to_jiffies(1000));
+#endif
+			} else {
+				uvif->dev->params->is_associated = 0;
+
+				uccp420wlan_prog_vif_conn_state(uvif->vif_index,
+								uvif->vif->addr,
+								STA_DISCONN);
+
+				uccp420wlan_prog_vht_bform(VHT_BEAMFORM_DISABLE,
+							   bform_per);
+
+			}
+		}
+
+		if (changed & BSS_CHANGED_BEACON_INT) {
+			uccp420wlan_prog_vif_beacon_int(uvif->vif_index,
+							uvif->vif->addr,
+							bss_conf->beacon_int);
+
+		}
+
+		if (changed & BSS_CHANGED_BEACON_INFO) {
+			uccp420wlan_prog_vif_dtim_period(uvif->vif_index,
+							 uvif->vif->addr,
+							 bss_conf->dtim_period);
+
+		}
+
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		if (changed & BSS_CHANGED_BEACON_ENABLED) {
+			if (uvif->vif->bss_conf.enable_beacon == true) {
+
+				bcn_int = bss_conf->beacon_int;
+				bcn_tim_val =  msecs_to_jiffies(bcn_int - 10);
+
+				mod_timer(&uvif->bcn_timer,
+					  jiffies + bcn_tim_val);
+			} else {
+				del_timer(&uvif->bcn_timer);
+			}
+		}
+
+		if (changed & BSS_CHANGED_BEACON_INT) {
+			bcn_int = bss_conf->beacon_int;
+			bcn_tim_val =  msecs_to_jiffies(bcn_int - 10);
+
+			if (uvif->vif->bss_conf.enable_beacon == true) {
+				mod_timer(&uvif->bcn_timer,
+					  jiffies + bcn_tim_val);
+
+				uccp420wlan_prog_vif_beacon_int(uvif->vif_index,
+								uvif->vif->addr,
+								bcn_int);
+			}
+		}
+
+		break;
+	case NL80211_IFTYPE_AP:
+		if (changed & BSS_CHANGED_BEACON_ENABLED) {
+			if (uvif->vif->bss_conf.enable_beacon == true) {
+				bcn_int = uvif->vif->bss_conf.beacon_int;
+				bcn_tim_val =  msecs_to_jiffies(bcn_int - 10);
+
+				mod_timer(&uvif->bcn_timer,
+					  jiffies + bcn_tim_val);
+
+			} else {
+				del_timer(&uvif->bcn_timer);
+			}
+		}
+
+		if (changed & BSS_CHANGED_BEACON_INT) {
+			bcn_int = bss_conf->beacon_int;
+			bcn_tim_val =  msecs_to_jiffies(bcn_int - 10);
+
+			if (uvif->vif->bss_conf.enable_beacon == true) {
+				mod_timer(&uvif->bcn_timer,
+					  jiffies + bcn_tim_val);
+
+				uccp420wlan_prog_vif_beacon_int(uvif->vif_index,
+								uvif->vif->addr,
+								bcn_int);
+			}
+		}
+
+		break;
+	default:
+		WARN_ON(1);
+		return;
+	}
+
+}
+
+
+void uccp420wlan_reset_complete(char *lmac_version, void *context)
+{
+	struct mac80211_dev *dev = (struct mac80211_dev *)context;
+	memcpy(dev->stats->uccp420_lmac_version, lmac_version, 5);
+	dev->stats->uccp420_lmac_version[5] = '\0';
+	dev->reset_complete = 1;
+}
+
+
+void uccp420wlan_mib_stats(struct umac_event_mib_stats *mib_stats,
+			   void *context)
+{
+	struct mac80211_dev *dev = (struct mac80211_dev *)context;
+
+	dev->stats->ed_cnt = mib_stats->ed_cnt;
+	dev->stats->mpdu_cnt = mib_stats->mpdu_cnt;
+	dev->stats->ofdm_crc32_pass_cnt = mib_stats->ofdm_crc32_pass_cnt;
+	dev->stats->ofdm_crc32_fail_cnt = mib_stats->ofdm_crc32_fail_cnt;
+	dev->stats->dsss_crc32_pass_cnt = mib_stats->dsss_crc32_pass_cnt;
+	dev->stats->dsss_crc32_fail_cnt = mib_stats->dsss_crc32_fail_cnt;
+	dev->stats->mac_id_pass_cnt = mib_stats->mac_id_pass_cnt;
+	dev->stats->mac_id_fail_cnt = mib_stats->mac_id_fail_cnt;
+	dev->stats->ofdm_corr_pass_cnt = mib_stats->ofdm_corr_pass_cnt;
+	dev->stats->ofdm_corr_fail_cnt = mib_stats->ofdm_corr_fail_cnt;
+	dev->stats->dsss_corr_pass_cnt = mib_stats->dsss_corr_pass_cnt;
+	dev->stats->dsss_corr_fail_cnt = mib_stats->dsss_corr_fail_cnt;
+	dev->stats->ofdm_s2l_fail_cnt = mib_stats->ofdm_s2l_fail_cnt;
+	dev->stats->lsig_fail_cnt = mib_stats->lsig_fail_cnt;
+	dev->stats->htsig_fail_cnt = mib_stats->htsig_fail_cnt;
+	dev->stats->vhtsiga_fail_cnt = mib_stats->vhtsiga_fail_cnt;
+	dev->stats->vhtsigb_fail_cnt = mib_stats->vhtsigb_fail_cnt;
+	dev->stats->nonht_ofdm_cnt = mib_stats->nonht_ofdm_cnt;
+	dev->stats->nonht_dsss_cnt = mib_stats->nonht_dsss_cnt;
+	dev->stats->mm_cnt = mib_stats->mm_cnt;
+	dev->stats->gf_cnt = mib_stats->gf_cnt;
+	dev->stats->vht_cnt = mib_stats->vht_cnt;
+	dev->stats->aggregation_cnt = mib_stats->aggregation_cnt;
+	dev->stats->non_aggregation_cnt = mib_stats->non_aggregation_cnt;
+	dev->stats->ndp_cnt = mib_stats->ndp_cnt;
+	dev->stats->ofdm_ldpc_cnt = mib_stats->ofdm_ldpc_cnt;
+	dev->stats->ofdm_bcc_cnt = mib_stats->ofdm_bcc_cnt;
+	dev->stats->midpacket_cnt = mib_stats->midpacket_cnt;
+	dev->stats->dsss_sfd_fail_cnt = mib_stats->dsss_sfd_fail_cnt;
+	dev->stats->dsss_hdr_fail_cnt = mib_stats->dsss_hdr_fail_cnt;
+	dev->stats->dsss_short_preamble_cnt =
+		mib_stats->dsss_short_preamble_cnt;
+	dev->stats->dsss_long_preamble_cnt = mib_stats->dsss_long_preamble_cnt;
+	dev->stats->sifs_event_cnt = mib_stats->sifs_event_cnt;
+	dev->stats->cts_cnt = mib_stats->cts_cnt;
+	dev->stats->ack_cnt = mib_stats->ack_cnt;
+	dev->stats->sifs_no_resp_cnt = mib_stats->sifs_no_resp_cnt;
+	dev->stats->unsupported_cnt = mib_stats->unsupported_cnt;
+	dev->stats->l1_corr_fail_cnt = mib_stats->l1_corr_fail_cnt;
+	dev->stats->phy_stats_reserved22 = mib_stats->phy_stats_reserved22;
+	dev->stats->phy_stats_reserved23 = mib_stats->phy_stats_reserved23;
+	dev->stats->phy_stats_reserved24 = mib_stats->phy_stats_reserved24;
+	dev->stats->phy_stats_reserved25 = mib_stats->phy_stats_reserved25;
+	dev->stats->phy_stats_reserved26 = mib_stats->phy_stats_reserved26;
+	dev->stats->phy_stats_reserved27 = mib_stats->phy_stats_reserved27;
+	dev->stats->phy_stats_reserved28 = mib_stats->phy_stats_reserved28;
+	dev->stats->phy_stats_reserved29 = mib_stats->phy_stats_reserved29;
+	dev->stats->phy_stats_reserved30 = mib_stats->phy_stats_reserved30;
+
+}
+
+void uccp420wlan_mac_stats(struct umac_event_mac_stats *mac_stats,
+			   void *context)
+{
+	struct mac80211_dev *dev = (struct mac80211_dev *)context;
+
+	/* TX related */
+	dev->stats->tx_cmd_cnt = mac_stats->tx_cmd_cnt;
+	dev->stats->tx_done_cnt = mac_stats->tx_done_cnt;
+	dev->stats->tx_edca_trigger_cnt = mac_stats->tx_edca_trigger_cnt;
+	dev->stats->tx_edca_isr_cnt = mac_stats->tx_edca_isr_cnt;
+	dev->stats->tx_start_cnt = mac_stats->tx_start_cnt;
+	dev->stats->tx_abort_cnt = mac_stats->tx_abort_cnt;
+	dev->stats->tx_abort_isr_cnt = mac_stats->tx_abort_isr_cnt;
+	dev->stats->tx_underrun_cnt = mac_stats->tx_underrun_cnt;
+	dev->stats->tx_rts_cnt = mac_stats->tx_rts_cnt;
+	dev->stats->tx_ampdu_cnt = mac_stats->tx_ampdu_cnt;
+	dev->stats->tx_mpdu_cnt = mac_stats->tx_mpdu_cnt;
+
+	/* RX related */
+	dev->stats->rx_isr_cnt = mac_stats->rx_isr_cnt;
+	dev->stats->rx_ack_cts_to_cnt = mac_stats->rx_ack_cts_to_cnt;
+	dev->stats->rx_cts_cnt = mac_stats->rx_cts_cnt;
+	dev->stats->rx_ack_resp_cnt = mac_stats->rx_ack_resp_cnt;
+	dev->stats->rx_ba_resp_cnt = mac_stats->rx_ba_resp_cnt;
+	dev->stats->rx_fail_in_ba_bitmap_cnt =
+		mac_stats->rx_fail_in_ba_bitmap_cnt;
+	dev->stats->rx_circular_buffer_free_cnt =
+		mac_stats->rx_circular_buffer_free_cnt;
+	dev->stats->rx_mic_fail_cnt = mac_stats->rx_mic_fail_cnt;
+
+	/* HAL related */
+	dev->stats->hal_cmd_cnt = mac_stats->hal_cmd_cnt;
+	dev->stats->hal_event_cnt = mac_stats->hal_event_cnt;
+	dev->stats->hal_ext_ptr_null_cnt = mac_stats->hal_ext_ptr_null_cnt;
+}
+void uccp420wlan_rf_calib_data(struct umac_event_rf_calib_data *rf_data,
+			       void *context)
+{
+	struct mac80211_dev  *dev = (struct mac80211_dev *)context;
+
+	if (rf_data->rf_calib_data_length > MAX_RF_CALIB_DATA) {
+		printk_once("%s: RF calib data exceeded the max size: %d\n",
+			    __func__,
+			    MAX_RF_CALIB_DATA);
+		return;
+	}
+	dev->stats->rf_calib_data_length = rf_data->rf_calib_data_length;
+	memset(dev->stats->rf_calib_data, 0x00,
+	       MAX_RF_CALIB_DATA);
+	memcpy(dev->stats->rf_calib_data, rf_data->rf_calib_data,
+	       rf_data->rf_calib_data_length);
+}
+void uccp420wlan_noa_event(int event, struct umac_event_noa *noa, void *context,
+			   struct sk_buff *skb)
+{
+	struct mac80211_dev  *dev = (struct mac80211_dev *)context;
+	struct ieee80211_vif *vif;
+	struct umac_vif *uvif;
+	unsigned long flags;
+	bool transmit = false;
+
+	rcu_read_lock();
+
+	vif = (struct ieee80211_vif *)rcu_dereference(dev->vifs[noa->if_index]);
+
+	if (vif == NULL) {
+		rcu_read_unlock();
+		return;
+	}
+
+	uvif = (struct umac_vif *)vif->drv_priv;
+
+	spin_lock_irqsave(&uvif->noa_que.lock, flags);
+
+	if (event == FROM_TX) {
+		if (uvif->noa_active) {
+			if (!uvif->noa_tx_allowed || skb_peek(&uvif->noa_que))
+				__skb_queue_tail(&uvif->noa_que, skb);
+			else
+				transmit = true;
+		} else
+			transmit = true;
+	} else if (event == FROM_TX_DONE) {
+		if (uvif->noa_active && uvif->noa_tx_allowed) {
+			skb = __skb_dequeue(&uvif->noa_que);
+
+			if (skb)
+				transmit = true;
+		}
+	} else { /* event = FROM_EVENT_NOA */
+
+		uvif->noa_active = noa->noa_active;
+
+		if (uvif->noa_active) {
+			pr_debug("%s: noa active = %d, ap_present = %d\n",
+				 dev->name, noa->noa_active, noa->ap_present);
+
+			uvif->noa_tx_allowed = noa->ap_present;
+
+			if (uvif->noa_tx_allowed) {
+				skb = __skb_dequeue(&uvif->noa_que);
+				if (skb)
+					transmit = true;
+			}
+		} else {
+			pr_debug("%s: noa active = %d\n",
+				 dev->name, noa->noa_active);
+
+			uvif->noa_tx_allowed = 1;
+
+			/* Can be done in a better way. For now, just flush the
+			 * NoA Queue
+			 */
+			while ((skb = __skb_dequeue(&uvif->noa_que)))
+				dev_kfree_skb_any(skb);
+		}
+	}
+
+	spin_unlock_irqrestore(&uvif->noa_que.lock, flags);
+
+	rcu_read_unlock();
+
+	if (transmit)
+		uccp420wlan_tx_frame(skb, NULL, dev, false);
+
+	return;
+}
+
+/* Beacon Time Stamp */
+static unsigned int get_real_ts2(unsigned int t2,
+					unsigned long long t1,
+					unsigned long long t3)
+{
+	unsigned long long t;
+	int td;
+	unsigned int clock_mask = 0, tck_num = 0, tck_denom = 0;
+
+	if (get_evt_timer_freq) {
+		get_evt_timer_freq(&clock_mask, &tck_num, &tck_denom);
+	} else {
+		clock_mask = CLOCK_MASK;
+		tck_num = TICK_NUMRATOR;
+		tck_denom = TICK_DENOMINATOR;
+	}
+
+	if (t3 >= t1) {
+		t = t3 - t1;
+	} else {
+		t = t1 - t3;
+		t = ULLONG_MAX - t + 1;
+	}
+
+	t *= tck_num;
+	do_div(t, tck_denom);
+	td = t2 - (int32_t)t;
+
+	if (td < 0)
+		td = clock_mask + 1 + td;
+
+	return td & clock_mask;
+}
+
+
+void uccp420wlan_rx_frame(struct sk_buff *skb, void *context)
+{
+	struct mac80211_dev *dev = (struct mac80211_dev *)context;
+	struct wlan_rx_pkt *rx = (struct wlan_rx_pkt *)(skb->data);
+	struct ieee80211_hdr *hdr;
+	struct ieee80211_rx_status rx_status;
+	struct ieee80211_supported_band *band = NULL;
+	int i;
+	static unsigned int rssi_index;
+	struct ieee80211_vif *vif = NULL;
+
+	/* Remove RX control information:
+	 * unused more_cmd_data in RX direction is used to indicate QoS/Non-Qos
+	 * frames
+	 */
+	/*pr_debug(" more command : %d\n", rx->hdr.more_cmd_data);*/
+	if (rx->hdr.more_cmd_data == 0) {
+		/* Non-QOS case*/
+		skb_pull(skb, sizeof(struct wlan_rx_pkt));
+	} else {
+		/* Qos Case: The UCCP overwrites the 2 reserved bytes with data
+		 * to maintain the 4 byte alignment of total length and 2 byte
+		 * alignment
+		 * of starting address (as expected by mac80211).
+		 */
+		skb_pull(skb, sizeof(struct wlan_rx_pkt) - 2);
+		skb_trim(skb, skb->len - 2);
+	}
+
+#ifdef DRIVER_DEBUG
+	pr_debug("%s-RX: RX frame, Len = %d, RSSI = %d, Rate = %d\n",
+		 dev->name, rx->pkt_length, rx->rssi, rx->rate_or_mcs);
+	/* print_hex_dump(KERN_DEBUG, " ", DUMP_PREFIX_NONE, 16 ,1, skb->data,
+	 * skb->len,1);
+	 */
+#endif
+
+	hdr = (struct ieee80211_hdr *)skb->data;
+
+	/* Stats for debugging */
+	if (ieee80211_is_data(hdr->frame_control)) {
+		dev->stats->rx_packet_data_count++;
+
+#ifdef PERF_PROFILING
+		if (dev->params->driver_tput == 1) {
+			dev_kfree_skb_any(skb);
+			return;
+		}
+#endif
+	} else if (ieee80211_is_mgmt(hdr->frame_control)) {
+		dev->stats->rx_packet_mgmt_count++;
+	}
+
+	memset(&rx_status, 0, sizeof(struct ieee80211_rx_status));
+
+	if (rx->channel < 15)
+		rx_status.band = IEEE80211_BAND_2GHZ;
+	else
+		rx_status.band = IEEE80211_BAND_5GHZ;
+
+	rx_status.freq = ieee80211_channel_to_frequency(rx->channel,
+							rx_status.band);
+	rx_status.signal = rx->rssi;
+
+	/* RSSI Average for Production Mode*/
+	if (dev->params->production_test == 1) {
+		dev->params->rssi_average[rssi_index++] = (char)(rx->rssi);
+		if (rssi_index >= MAX_RSSI_SAMPLES)
+			rssi_index = 0;
+	}
+
+	rx_status.antenna = 0;
+
+	if (rx->rate_flags & ENABLE_VHT_FORMAT) {
+		/* Rate */
+		if ((rx->rate_or_mcs & MARK_RATE_AS_MCS_INDEX) != 0x80) {
+#ifdef DRIVER_DEBUG
+			pr_info("Invalid VHT MCS Information\n");
+#endif
+			rx->rate_or_mcs = 0;/*default to MCS0*/
+		} else {
+			rx_status.rate_idx = (rx->rate_or_mcs & 0x7f);
+		}
+
+		/* NSS */
+		if (!rx->nss || rx->nss > 8)
+			rx_status.vht_nss = 1;
+		else
+			 rx_status.vht_nss = rx->nss;
+
+		/* CBW */
+		if (rx->rate_flags & ENABLE_CHNL_WIDTH_80MHZ)
+			rx_status.flag |= RX_VHT_FLAG_80MHZ;
+		else if (rx->rate_flags & ENABLE_CHNL_WIDTH_40MHZ)
+			rx_status.flag |= RX_FLAG_40MHZ;
+
+		/* SGI */
+		if (rx->rate_flags & ENABLE_SGI)
+			rx_status.flag |= RX_FLAG_SHORT_GI;
+
+		rx_status.flag |= RX_FLAG_VHT;
+	} else if (rx->rate_flags & ENABLE_11N_FORMAT) {
+		/* Rate */
+		if ((rx->rate_or_mcs & MARK_RATE_AS_MCS_INDEX) != 0x80) {
+#ifdef DRIVER_DEBUG
+			pr_info("Invalid HT MCS Information\n");
+#endif
+			   rx->rate_or_mcs = 0;/*default to MCS0*/
+		} else {
+			   rx_status.rate_idx = (rx->rate_or_mcs & 0x7f);
+		}
+
+		/* CBW */
+		if (rx->rate_flags & ENABLE_CHNL_WIDTH_40MHZ)
+			rx_status.flag |= RX_FLAG_40MHZ;
+
+		/* SGI */
+		if (rx->rate_flags & ENABLE_SGI)
+			rx_status.flag |= RX_FLAG_SHORT_GI;
+
+		/* HT Greenfield */
+		if (rx->rate_flags & ENABLE_GREEN_FIELD)
+			rx_status.flag |= RX_FLAG_HT_GF;
+
+		rx_status.flag |= RX_FLAG_HT;
+	} else {
+		band = dev->hw->wiphy->bands[rx_status.band];
+
+		if (!WARN_ON_ONCE(!band)) {
+			for (i = 0; i < band->n_bitrates; i++) {
+				if (rx->rate_or_mcs ==
+				    band->bitrates[i].hw_value) {
+					rx_status.rate_idx = i;
+					break;
+				}
+			}
+		} else {
+#ifdef DRIVER_DEBUG
+			print_hex_dump(KERN_DEBUG, " ",
+				       DUMP_PREFIX_NONE, 16, 1, rx ,
+				       sizeof(struct wlan_rx_pkt), 1);
+#endif
+			dev_kfree_skb_any(skb);
+			return;
+		}
+	}
+
+	/* Remove this once hardware supports bip(11w) is available*/
+	if (!is_robust_mgmt(skb))
+		rx_status.flag |= RX_FLAG_DECRYPTED;
+
+	rx_status.flag |= RX_FLAG_MMIC_STRIPPED;
+
+	if (rx->rx_pkt_status == RX_MIC_FAILURE_TKIP) {
+		rx_status.flag |= RX_FLAG_MMIC_ERROR;
+	} else if (rx->rx_pkt_status == RX_MIC_FAILURE_CCMP) {
+		/*Drop the Frame*/
+		dev_kfree_skb_any(skb);
+		return;
+	}
+
+	if (((hdr->frame_control & IEEE80211_FCTL_FTYPE) ==
+	     IEEE80211_FTYPE_MGMT) &&
+	    ((hdr->frame_control & IEEE80211_FCTL_STYPE) ==
+	     IEEE80211_STYPE_BEACON)) {
+		rx_status.mactime = get_unaligned_le64(rx->timestamp);
+		rx_status.flag |= RX_FLAG_MACTIME_START;
+	}
+
+	/* Beacon Time Stamp */
+	if (((hdr->frame_control & IEEE80211_FCTL_FTYPE) ==
+	     IEEE80211_FTYPE_MGMT) &&
+	    ((hdr->frame_control & IEEE80211_FCTL_STYPE) ==
+	     IEEE80211_STYPE_BEACON)) {
+		for (i = 0; i < MAX_VIFS; i++) {
+			vif = NULL;
+			vif = dev->vifs[i];
+			if (vif &&
+			ether_addr_equal(hdr->addr2, vif->bss_conf.bssid)) {
+				unsigned int ts2;
+				unsigned long long ts3;
+				spin_lock(&tsf_lock);
+				dev->params->sync[i].status = 1;
+				memcpy(dev->params->sync[i].bssid,
+				       vif->bss_conf.bssid, 6);
+				memcpy(dev->params->sync[i].ts1,
+					(char *)hdr->addr4, 8);
+				memcpy(&ts3, &rx->reserved, 8);
+				memcpy(&ts2, &rx->reserved[8], 4);
+				memcpy(&dev->params->sync[i].ts2,
+						&rx->reserved[8], 4);
+				dev->params->sync[i].atu = 0;
+				ts2 = get_real_ts2(ts2, get_unaligned_le64(
+					dev->params->sync[i].ts1), ts3);
+				if (frc_to_atu)
+					frc_to_atu(ts2,
+						&dev->params->sync[i].atu, 0);
+				spin_unlock(&tsf_lock);
+				break;
+			}
+		}
+	}
+
+	memcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));
+	ieee80211_rx(dev->hw, skb);
+}
+
+
+void uccp420wlan_ch_prog_complete(int event,
+				  struct umac_event_ch_prog_complete *prog_ch,
+				  void *context)
+{
+	struct mac80211_dev *dev = (struct mac80211_dev *)context;
+	dev->chan_prog_done = 1;
+}
+
diff --git a/drivers/net/wireless/uccp420wlan/src/fwldr.c b/drivers/net/wireless/uccp420wlan/src/fwldr.c
new file mode 100644
index 0000000..70522d5
--- /dev/null
+++ b/drivers/net/wireless/uccp420wlan/src/fwldr.c
@@ -0,0 +1,1201 @@
+/*
+ * File Name  : fwldr.c
+ *
+ * This file contains contains functions related to firmware loading
+ * functionality.
+ *
+ * Copyright (c) 2011, 2012, 2013, 2014 Imagination Technologies Ltd.
+ * All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+
+#include <fwldr.h>
+
+struct fwload_priv  *fpriv, fpv;
+
+static unsigned short fwldr_read_le2(unsigned char *buf);
+static unsigned int fwldr_read_le4(unsigned char *buf);
+static unsigned fwldr_virt_to_linear_off(unsigned page_size,
+					 unsigned offset);
+
+static void fwldr_soft_reset(unsigned int thrd_num);
+
+static void fwldr_load_mem(unsigned int dst_addr,
+		    unsigned int len,
+		    unsigned char *src_buf);
+
+static void fwldr_start_thrd(unsigned int thrd_number,
+			unsigned int stack_ptr,
+			unsigned int program_ctr,
+			unsigned int catch_state_addr);
+
+static void fwldr_stop_thrd(unsigned int thrd_num);
+
+static void fwldr_zero_mem(unsigned int dst_addr,
+		    unsigned int len);
+
+static unsigned int fwldr_config_read(unsigned int dst_addr);
+
+static void fwldr_config_write(unsigned int dst_addr,
+			unsigned int val);
+
+static enum uccp_mem_region fwldr_chk_region(unsigned int src_addr,
+				      int length);
+
+static int fwldr_parser(const unsigned char *fw_data);
+
+static int fwldr_wait_for_completion(void);
+
+static void dir_mem_cpy(unsigned int addr,
+			unsigned char *data,
+			unsigned int len);
+
+static void dir_mem_set(unsigned int addr,
+			unsigned char data,
+			unsigned int len);
+
+static void dir_mem_read(unsigned int addr,
+			 unsigned int *data,
+			 unsigned int len);
+
+static void dir_mem_write(unsigned int addr,
+			 unsigned int data);
+
+static void core_mem_cpy(unsigned int addr,
+			 unsigned char *data,
+			 unsigned int len);
+
+static void core_mem_set(unsigned int addr,
+			 unsigned int data,
+			 unsigned int len);
+
+static void core_mem_read(unsigned int addr,
+			  unsigned int *data,
+			  unsigned int len);
+
+/* dir_mem_cpy
+ *
+ * Perform a memcpy of 'len' bytes from 'src_addr' to the UCCP memory location
+ * pointed by 'dst_addr'.
+ *
+ * dst_addr is always a 4 byte aligned address
+ * data is always a 4 byte aligned address
+ * len is always a multiple of 4 when dst_addr is of type 0xB4xxxxxx
+ * len may NOT be a multiple of 4 when dst_addr is of type 0xB7xxxxxx
+ *
+ *
+ * When dst_addr is of type 0xB4xxxxxx, perform only 32 bit writes to these
+ * locations
+ *
+ */
+static void dir_mem_cpy(unsigned int addr,
+			unsigned char *data,
+			unsigned int len)
+{
+	int i;
+	unsigned long offset = (unsigned long)addr & UCCP_OFFSET_MASK;
+	unsigned long base = ((unsigned long)addr & UCCP_BASE_MASK) >> 24;
+	unsigned int *data_addr = (unsigned int *)data;
+	unsigned char *gram_byte_addr, *data_byte_addr;
+
+	if ((fpriv->gram_b4_addr ==  NULL) && (base == UCCP_GRAM_MSB)) {
+
+		/* The HAL didn't provide a virtual address for 0xB4xxxxxx alias
+		 * Convert into 0xB7 and do the writes by ignoring MSB of the
+		 * 32-bit word
+		 */
+
+		addr &= 0x00FFFFFF;
+		addr |= 0xB7000000;
+
+		data_byte_addr = (unsigned char *)data_addr;
+		gram_byte_addr = (void *)(fpriv->gram_addr + (offset / 4) * 3);
+
+		hal_ops.set_mem_region(addr);
+
+		if (len % 4 == 0) {
+			for (i = 0; i < len / 4; i++) {
+				memcpy(gram_byte_addr, data_byte_addr + 1, 3);
+				gram_byte_addr += 3;
+				data_byte_addr += 4;
+			}
+		} else {
+			fwldr_dbg_err("%s:Unexpected length(base:%lx)\n",
+				      __func__, base);
+		}
+
+	} else {
+
+		hal_ops.set_mem_region(addr);
+		if (len % 4 == 0) {
+			for (i = 0; i < len / 4; i++) {
+				fwload_uccp_write(fpriv, base, offset,
+						  data_addr[i]);
+				offset += 4;
+			}
+		} else {
+			if (base == UCCP_GRAM_PACKED)
+				memcpy((void *)(fpriv->gram_addr + offset),
+				       (void *)data_addr, len);
+			else
+				fwldr_dbg_err("%s:Unexpected length(%lx)\n",
+					      __func__, base);
+		}
+	}
+
+	return;
+}
+
+
+/* dir_mem_set
+ *
+ * Perform a memset of 'len' bytes with value of 'val' to the UCCP memory
+ * location pointed by 'dst_addr'.
+ *
+ * dst_addr is always a 4 byte aligned address
+ * len is always a multiple of 4 when dst_addr is of type 0xB4xxxxxx
+ * len may NOT be a multiple of 4 when dst_addr is of type 0xB7xxxxxx
+ *
+ *
+ * When dst_addr is of type 0xB4xxxxxx, perform only 32 bit writes to these
+ * locations
+ *
+ */
+static void dir_mem_set(unsigned int addr,
+			unsigned char data,
+			unsigned int len)
+{
+	int i;
+	unsigned long offset = (unsigned long)addr & UCCP_OFFSET_MASK;
+	unsigned long base = ((unsigned long)addr & UCCP_BASE_MASK) >> 24;
+	unsigned char *gram_byte_addr;
+
+	if ((fpriv->gram_b4_addr ==  NULL) && (base == UCCP_GRAM_MSB)) {
+
+		/* The HAL didn't provide a virtual address for 0xB4xxxxxx alias
+		 * Convert into 0xB7 and do the writes by ignoring MSB of the
+		 * 32-bit word
+		 */
+
+		addr &= 0x00FFFFFF;
+		addr |= 0xB7000000;
+
+		gram_byte_addr = (void *)(fpriv->gram_addr + (offset / 4) * 3);
+
+		hal_ops.set_mem_region(addr);
+
+		if (len % 4 == 0) {
+			memset(gram_byte_addr, data, (len / 4) * 3);
+		} else {
+			fwldr_dbg_err("%s :Unexpected length (base : %lx)\n",
+				      __func__, base);
+		}
+
+	} else {
+
+		hal_ops.set_mem_region(addr);
+
+		if (len % 4 == 0) {
+			for (i = 0; i <= len / 4; i++) {
+				fwload_uccp_write(fpriv, base, offset, data);
+				offset += 4;
+			}
+		} else if (base == UCCP_GRAM_PACKED) {
+			memset((void *)(fpriv->gram_addr + offset),
+			       data, len);
+		} else {
+			fwldr_dbg_err("%s: Unexpected length (base %lx)\n",
+				      __func__, base);
+		}
+	}
+
+	return;
+}
+
+/* Perform 'len' 32 bit reads from a UCCP memory location 'addr'
+ * 'addr' is always a 4 byte aligned address
+ */
+static void dir_mem_read(unsigned int addr,
+			 unsigned int *data,
+			 unsigned int len)
+{
+	int i = 0;
+	unsigned long offset = (unsigned long)addr & UCCP_OFFSET_MASK;
+	unsigned long base = ((unsigned long)addr & UCCP_BASE_MASK) >> 24;
+
+	hal_ops.set_mem_region(addr);
+
+	for (i = 0; i <= len / 4; i++) {
+		fwload_uccp_read(fpriv, base, offset, data+i);
+		offset += 4;
+	}
+}
+
+/* 32 bit write to UCCP memory location 'addr'
+ * 'addr' is always a 4 byte aligned address
+ */
+static void dir_mem_write(unsigned int addr,
+			 unsigned int data)
+{
+	unsigned long offset = (unsigned long)addr & UCCP_OFFSET_MASK;
+	unsigned long base = ((unsigned long)addr & UCCP_BASE_MASK) >> 24;
+
+	hal_ops.set_mem_region(addr);
+	fwload_uccp_write(fpriv, base, offset, data);
+}
+
+
+static void core_mem_cpy(unsigned int addr,
+			 unsigned char *data,
+			 unsigned int len)
+{
+	unsigned int i = 0;
+	unsigned int *src_data = (unsigned int *)data;
+	unsigned int flag = 0;
+	unsigned int val = 0;
+
+	/* Poll MSLVCTRL1 */
+	do {
+		dir_mem_read(MSLVCTRL1, &val, 1);
+	} while (!MSLAVE_READY(val));
+
+	if (len > 1)
+		flag = SLAVE_BLOCK_WRITE;
+	else
+		flag = SLAVE_SINGLE_WRITE;
+
+	dir_mem_write(MSLVCTRL0,
+			((addr & SLAVE_ADDR_MODE_MASK) | flag));
+
+	for (i = 0; i < len / 4; i++) {
+		do {
+			dir_mem_read(MSLVCTRL1, &val, 1);
+		} while (!MSLAVE_READY(val));
+
+		if (data != NULL)
+			dir_mem_write(MSLVDATAT, src_data[i]);
+		else
+			dir_mem_write(MSLVDATAT, 0x00);
+	}
+
+}
+
+
+static void core_mem_set(unsigned int addr,
+			 unsigned int data,
+			 unsigned int len)
+{
+	unsigned int flag = 0;
+	unsigned int val = 0;
+
+	/* Poll MSLVCTRL1 */
+	do {
+		dir_mem_read(MSLVCTRL1, &val, 1);
+	} while (!MSLAVE_READY(val));
+
+	if (len > 1)
+		flag = SLAVE_BLOCK_WRITE;
+	else
+		flag = SLAVE_SINGLE_WRITE;
+
+	dir_mem_write(MSLVCTRL0,
+			((addr & SLAVE_ADDR_MODE_MASK) | flag));
+	dir_mem_write(MSLVDATAT, data);
+}
+
+
+static void core_mem_read(unsigned int addr,
+			  unsigned int *data,
+			  unsigned int len)
+{
+	unsigned int i = 0;
+	unsigned int val = 0;
+
+	/* Poll MSLVCTRL1 */
+	do {
+		dir_mem_read(MSLVCTRL1, &val, 1);
+	} while (!MSLAVE_READY(val));
+
+	dir_mem_write(MSLVCTRL0,
+			((addr & SLAVE_ADDR_MODE_MASK) | SLAVE_BLOCK_READ));
+
+	for (i = 0; i < len-1; i++) {
+		do {
+			dir_mem_read(MSLVCTRL1, &val, 1);
+		} while (!MSLAVE_READY(val));
+
+		dir_mem_read(MSLVDATAT, &data[i], 1);
+	}
+
+	/* Read the last word */
+	do {
+		dir_mem_read(MSLVCTRL1, &val, 1);
+	} while (!MSLAVE_READY(val));
+
+	dir_mem_read(MSLVDATAX, &data[len-1], 1);
+
+
+}
+
+
+
+int fwldr_load_fw(const unsigned char *fw_data, int i)
+{
+	struct fwldr_cfg_rw rw_v;
+	int err = FWLDR_SUCCESS;
+
+	fpriv = &fpv;
+	hal_ops.request_mem_regions(&fpriv->gram_addr,
+				    &fpriv->core_addr,
+				    &fpriv->gram_b4_addr);
+
+	fwldr_soft_reset(LTP_THREAD_NUM);
+
+	memset(&rw_v, 0, sizeof(rw_v));
+	rw_v.addr = UCCP_GRAM_BASE + UCCP_THRD_EXEC_SIG_OFFSET;
+	rw_v.val = 0x00;
+	fwldr_config_write(rw_v.addr, rw_v.val);
+
+	err = fwldr_parser(fw_data);
+
+	if (err != FWLDR_SUCCESS) {
+		pr_err("FW load failed\n");
+		return err;
+	}
+
+	if (!fwldr_wait_for_completion()) {
+		pr_err("FW load timed out waiting for completion\n");
+		return FWLDR_FAIL;
+	}
+	if (!i)
+		fwldr_stop_thrd(LTP_THREAD_NUM);
+	return err;
+}
+
+
+static void fwldr_load_mem(unsigned int dst_addr,
+		    unsigned int len,
+		    unsigned char *src_buf)
+{
+	enum uccp_mem_region mem_region = UCCP_MEM_ERR;
+	int i = 0;
+
+	mem_region = fwldr_chk_region(dst_addr, len);
+
+	fwldr_dbg_info("%s dst_addr = 0x%X, length = 0x%X, srcaddr = 0x%X\n",
+		       __func__, dst_addr, len, (unsigned int)src_buf);
+
+	fwldr_dbg_info("Dump upto 16 bytes\n");
+
+	if (0 != (dst_addr % 4))
+		fwldr_dbg_info("Destination Address is not 4 - byte aligned\n");
+
+	for (i = 0; i < 16; i += 2)
+		fwldr_dbg_dump("0x%X \t 0x%X\n", src_buf[i], src_buf[i + 1]);
+
+	switch (mem_region) {
+	case UCCP_MEM_CORE:
+		core_mem_cpy(dst_addr, src_buf, len);
+		break;
+
+	case UCCP_MEM_DIRECT:
+		dir_mem_cpy(dst_addr, src_buf, len);
+		break;
+
+	default:
+		fwldr_dbg_err("Region unknown. Skipped writing\n");
+		break;
+	}
+}
+
+
+static void fwldr_start_thrd(unsigned int thrd_num,
+		      unsigned int stack_ptr,
+		      unsigned int prog_ctr,
+		      unsigned int catch_state_addr)
+{
+	fwldr_dbg_info("%s PC = 0x%X,\tSP = 0x%X\n",
+		       __func__, prog_ctr, stack_ptr);
+
+	/* Program Counter */
+	core_mem_set(MTX_TXUXXRXDT, prog_ctr, 1);
+	core_mem_set(MTX_TXUXXRXRQ, MTX_PC_REG_IND_ADDR, 1);
+
+	/* Stack Pointer */
+	core_mem_set(MTX_TXUXXRXDT, stack_ptr, 1);
+	core_mem_set(MTX_TXUXXRXRQ, MTX_A0STP_REG_IND_ADDR, 1);
+
+	/* Thread Enable */
+	core_mem_set(MTX_TXENABLE_ADDR, MTX_START_EXECUTION, 1);
+
+	fwldr_dbg_info("Thread %d is Enabled\n", thrd_num);
+}
+
+
+static void fwldr_stop_thrd(unsigned int thrd_num)
+{
+	unsigned int val;
+
+	/* Thread Disable */
+	core_mem_set(MTX_TXENABLE_ADDR, MTX_STOP_EXECUTION, 1);
+
+	core_mem_read(MTX_TXENABLE_ADDR, &val, 1);
+
+	while ((val & 0x2) != 0x2) {
+		core_mem_read(MTX_TXENABLE_ADDR, &val, 1);
+
+		fwldr_dbg_info("%s val = 0x%X\n", __func__, val);
+
+	}
+
+	fwldr_dbg_info("TXENABLE = 0x%X\n", val);
+	fwldr_dbg_info("Thread %d is Stopped\n", thrd_num);
+}
+
+
+static void fwldr_zero_mem(unsigned int dst_addr,
+		    unsigned int len)
+{
+	int mem_region = 0;
+
+	fwldr_dbg_info("%s DestAddr = 0x%X, length = 0x%X\n",
+		       __func__, dst_addr, len);
+
+	if (0 != (dst_addr % 4))
+		fwldr_dbg_info("Destination Address is not 4 - byte aligned");
+
+	mem_region = fwldr_chk_region(dst_addr, len);
+
+	switch (mem_region) {
+	case UCCP_MEM_CORE:
+		core_mem_cpy(dst_addr, NULL, len);
+		break;
+
+	case UCCP_MEM_DIRECT:
+		dir_mem_set(dst_addr, 0x00, len);
+		break;
+
+	default:
+		fwldr_dbg_err("Region unknown. Skipped setting\n");
+		break;
+	}
+}
+
+
+static unsigned int fwldr_config_read(unsigned int dst_addr)
+{
+	int mem_region = 0;
+	int val = 0;
+
+	fwldr_dbg_info("%s dst_addr = 0x%X\n", __func__, dst_addr);
+
+	if (0 != (dst_addr % 4))
+		fwldr_dbg_info("Destination Address is not 4 - byte aligned");
+
+	mem_region = fwldr_chk_region(dst_addr, 0);
+
+	switch (mem_region) {
+	case UCCP_MEM_CORE:
+		core_mem_read(dst_addr, &val, 1);
+		return val;
+
+	case UCCP_MEM_DIRECT:
+		dir_mem_read(dst_addr, &val, 1);
+		return val;
+
+	default:
+		fwldr_dbg_err("Region unknown. Skipped reading\n");
+		return 0;
+	}
+
+	return 0;
+}
+
+
+static void fwldr_config_write(unsigned int dst_addr,
+			unsigned int val)
+{
+	int mem_region = 0;
+
+	fwldr_dbg_info("%s dst_addr = 0x%X,\tValue = 0x%X\n",
+		       __func__, dst_addr, val);
+
+	if (0 != (dst_addr % 4))
+		fwldr_dbg_info("Destination Address is not 4 - byte aligned");
+
+	mem_region = fwldr_chk_region(dst_addr, 0);
+
+
+	switch (mem_region) {
+	case UCCP_MEM_CORE:
+		core_mem_set(dst_addr, val, 1);
+		break;
+
+	case UCCP_MEM_DIRECT:
+		dir_mem_write(dst_addr, val);
+		break;
+
+	default:
+		fwldr_dbg_err("Region unknown. Skipped writing\n");
+		break;
+	}
+
+}
+
+
+static enum uccp_mem_region fwldr_chk_region(unsigned int src_addr, int len)
+{
+	unsigned int dst_addr = src_addr + len;
+
+	if (((src_addr >= 0x03000000) && (src_addr <= 0x04FFFFFF))  ||
+	    ((src_addr >= 0x02009000) && (src_addr <= 0x0203BFFF))  ||
+	    ((src_addr >= 0x80000000) && (src_addr <= 0x87FFFFFF))) {
+		if (len != 0) {
+			if (((dst_addr >= 0x03000000) &&
+			     (dst_addr <= 0x04FFFFFF)) ||
+			    ((dst_addr >= 0x02009000) &&
+			     (dst_addr <= 0x0203BFFF)) ||
+			    ((dst_addr >= 0x80000000) &&
+			     (dst_addr <= 0x87FFFFFF)))
+				return UCCP_MEM_CORE;
+			else
+				return UCCP_MEM_ERR;
+		}
+
+		return UCCP_MEM_CORE;
+	} else if ((src_addr & 0xFF000000) == 0xB0000000) {
+		return UCCP_MEM_ERR;
+	} else {
+		return UCCP_MEM_DIRECT;
+	}
+}
+
+
+static void fwldr_soft_reset(unsigned int thrd_num)
+{
+	unsigned int val, temp;
+	unsigned int retries = 3;
+
+	/* If the thread is running, then stop it and clear the registers,
+	 * otherwise do nothing
+	 */
+	core_mem_read(MTX_TXENABLE_ADDR, &val, 1);
+
+	fwldr_dbg_info("Resetting UCCP420\n");
+
+	/* Soft Reset */
+	dir_mem_read(MSLVSRST, &val, 1);
+	dir_mem_write(MSLVSRST, (val | 1));
+
+	/* Wait for 16 core clock cycles. Core runs at 320MHz */
+	udelay(10);
+
+	/* Clear the Soft Reset */
+	dir_mem_write(MSLVSRST, (val & 0xFFFFFFFE));
+
+	/* Give additional 20 ms for the DA to do its own reset */
+	mdelay(20);
+
+	/* Clear the Minim Bit in PrivExt */
+	core_mem_set(MTX_TXPRIVEXT_ADDR, 0, 1);
+
+	/* Set the PCX value i to 0 */
+	core_mem_set(MTX_TXUXXRXDT, 0, 1);
+	core_mem_set(MTX_TXUXXRXRQ, MTX_PCX_REG_IND_ADDR, 1);
+
+
+	/* Clear TXPOLL{I} to clear TXSTAT{I}
+	 * Writing 0xFFFFFFFF clears TXSTATI, but TXMASKI must
+	 * be all set too for this to work.
+	 */
+	core_mem_set(MTX_TXUXXRXDT, 0xFFFFFFFF, 1);
+	core_mem_set(MTX_TXUXXRXRQ, MTX_TXMASK_REG_IND_ADDR, 1);
+
+	core_mem_set(MTX_TXUXXRXDT, 0xFFFFFFFF, 1);
+	core_mem_set(MTX_TXUXXRXRQ, MTX_TXMASKI_REG_IND_ADDR, 1);
+
+	core_mem_set(MTX_TXUXXRXDT, 0xFFFFFFFF, 1);
+	core_mem_set(MTX_TXUXXRXRQ, MTX_TXPOLL_REG_IND_ADDR, 1);
+
+	core_mem_set(MTX_TXUXXRXDT, 0xFFFFFFFF, 1);
+	core_mem_set(MTX_TXUXXRXRQ, MTX_TXPOLLI_REG_IND_ADDR, 1);
+
+	/* Clear TXMASK and TXMASKI */
+	core_mem_set(MTX_TXUXXRXDT, 0x0, 1);
+	core_mem_set(MTX_TXUXXRXRQ, MTX_TXMASK_REG_IND_ADDR, 1);
+
+
+	core_mem_set(MTX_TXUXXRXDT, 0x0, 1);
+	core_mem_set(MTX_TXUXXRXRQ, MTX_TXMASKI_REG_IND_ADDR, 1);
+
+	/* Ensure all kicks are cleared */
+	core_mem_set(MTX_TXUXXRXRQ,
+			     (MTX_TXPOLLI_REG_IND_ADDR | REG_IND_READ_FLAG),
+			     1);
+
+	core_mem_read(MTX_TXUXXRXDT, &temp, 1);
+
+	while (temp && retries--) {
+		core_mem_set(MTX_TXUXXRXDT, 0x2, 1);
+
+		core_mem_set(MTX_TXUXXRXRQ,
+				     MTX_TXPOLLI_REG_IND_ADDR,
+				     1);
+
+		core_mem_set(MTX_TXUXXRXRQ,
+				     (MTX_TXPOLLI_REG_IND_ADDR |
+				      REG_IND_READ_FLAG),
+				     1);
+
+		core_mem_read(MTX_TXUXXRXDT, &temp, 1);
+	}
+
+	/* Reset TXSTATUS */
+	core_mem_set(MTX_TXSTATUS_ADDR, 0x00020000, 1);
+
+	fwldr_dbg_info("Soft Reset core\n");
+}
+
+
+/* Reads a 16-bit little endian value from the specified position in a buffer */
+static unsigned short fwldr_read_le2(unsigned char *buf)
+{
+	unsigned short val = 0;
+
+	val  = buf[0];
+	val |= buf[1] << 8;
+
+	return val;
+}
+
+
+/* Reads a 32-bit little endian value from the specified position in a buffer */
+static unsigned int fwldr_read_le4(unsigned char *buf)
+{
+	unsigned int val = 0;
+
+	val = buf[0];
+	val |= buf[1] << 8;
+	val |= buf[2] << 16;
+	val |= buf[3] << 24;
+
+	return val;
+}
+
+
+/* Converts a virtual (paged) offset to a linear (non-paged) offset */
+static unsigned fwldr_virt_to_linear_off(unsigned page_size, unsigned offset)
+{
+	static unsigned virt_page_size;
+
+	unsigned val = offset;
+
+	if (page_size) {
+		if (virt_page_size == 0) {
+			virt_page_size = 1;
+			while (virt_page_size < page_size)
+				virt_page_size <<= 1;
+		}
+
+		val = ((offset / virt_page_size) * page_size) +
+			(offset % virt_page_size);
+	}
+
+	return val;
+}
+
+
+static int fwldr_parser(const unsigned char *fw_data)
+{
+	int quit = 0;
+	signed int nxt = 0;
+	signed int file_offset = 0;
+	signed int page_size = 0;
+	signed int orig_offset = 0;
+	signed int prev_offset = 0;
+	struct fwldr_bootdevhdr boot_dev_hdr;
+	char info_buf[256];
+	char *cfg_str = NULL;
+	char cfg_buf[256];
+	char *cfg_buf_ptr = NULL;
+	struct fwldr_sec_ldr_l1_record l1_rec;
+	struct fwldr_load_mem_info lm_v;
+	struct fwldr_cfg_rw rw_v;
+	unsigned char l1_buf[FWLDR_L1_MAXSIZE];
+	signed int seek_off;
+	char *str_curr = NULL;
+	char *str_end = NULL;
+	char *str_new = NULL;
+	int buf_len = 0;
+	int res = FWLDR_SUCCESS;
+
+	/* Lets really do it */
+	memcpy(&boot_dev_hdr, fw_data, sizeof(struct fwldr_bootdevhdr));
+
+	fwldr_dbg_info("DevID:  0x%08X\n", boot_dev_hdr.dev_id);
+	fwldr_dbg_info("SLCode: 0x%08X\n", boot_dev_hdr.sl_code);
+	fwldr_dbg_info("SLData: 0x%08X\n", boot_dev_hdr.sl_data);
+	fwldr_dbg_info("PLCtrl: 0x%04X\n", boot_dev_hdr.pl_ctrl);
+	fwldr_dbg_info("CRC:    0x%04X\n", boot_dev_hdr.CRC);
+	fwldr_dbg_info("%d", sizeof(boot_dev_hdr));
+	fwldr_dbg_info("\n");
+
+	file_offset = fwldr_virt_to_linear_off(page_size, boot_dev_hdr.sl_code);
+	orig_offset = fwldr_virt_to_linear_off(page_size, boot_dev_hdr.sl_data);
+
+	nxt = sizeof(struct fwldr_bootdevhdr);
+
+	do {
+		unsigned char sec_ldr_code[FWLDR_PLRCRD_BYTES];
+
+		memcpy(&sec_ldr_code,
+		       fw_data + file_offset,
+		       FWLDR_PLRCRD_BYTES);
+
+		nxt = fwldr_read_le4(&sec_ldr_code[FWLDR_PLRCRD_DATA_BYTES]);
+
+		file_offset = fwldr_virt_to_linear_off(page_size,
+						       nxt);
+	} while (nxt);
+
+	file_offset = orig_offset;
+
+	while (!quit) {
+		unsigned char *l2_buf = NULL, *l2_blk = NULL;
+		unsigned int l2_len = 0U;
+
+		memcpy(&l1_buf,
+		       fw_data + file_offset,
+		       FWLDR_L1_MAXSIZE);
+
+		l1_rec.cmd_tag = fwldr_read_le2(&l1_buf[FWLDR_L1_CMD_OFF]);
+		l1_rec.len = fwldr_read_le2(&l1_buf[FWLDR_L1_LEN_OFF]);
+		l1_rec.nxt = fwldr_read_le4(&l1_buf[FWLDR_L1_NXT_OFF]);
+
+		if ((l1_rec.len > FWLDR_L1_MAXSIZE) ||
+		    (l1_rec.len < FWLDR_L1_L2OFF_OFF) ||
+		    (l1_rec.len < FWLDR_L1_L2LEN_OFF)) {
+			fwldr_dbg_err("Maximum L1 length exceeded\n");
+			res = FWLDR_FAIL;
+			break;
+		}
+
+		/* Extract generic L1 fields */
+		l1_rec.l2_offset = fwldr_read_le4(&l1_buf[l1_rec.len -
+						  FWLDR_L1_L2OFF_OFF]);
+
+		l1_rec.l2_len = fwldr_read_le2(&l1_buf[l1_rec.len -
+					       FWLDR_L1_L2LEN_OFF]);
+
+		if (l1_rec.l2_len > FWLDR_L2_BASIC_SIZE) {
+			/* Read the L2 data */
+			seek_off = fwldr_virt_to_linear_off(page_size,
+							    l1_rec.l2_offset);
+
+			if (l1_rec.l2_len > FWLDR_L2_MAXSIZE) {
+				fwldr_dbg_err("Maximum L2 length exceeded\n");
+				res = FWLDR_FAIL;
+				break;
+			}
+
+			l2_blk = kmalloc(l1_rec.l2_len + 1,
+					 GFP_KERNEL);
+
+			if (l2_blk == NULL) {
+				fwldr_dbg_err("Not Enough Memory\n");
+				res = FWLDR_FAIL;
+				break;
+			}
+
+			memcpy(l2_blk,
+			       fw_data + seek_off,
+			       l1_rec.l2_len);
+
+			l2_blk[l1_rec.l2_len] = '\0';
+
+			l2_buf = l2_blk +
+				(FWLDR_L2_CMD_SIZE + FWLDR_L2_LEN_SIZE);
+
+			l2_len = l1_rec.l2_len - FWLDR_L2_BASIC_SIZE;
+		}
+
+		switch (l1_rec.cmd_tag) {
+		case FWLDR_L1_CMD_LOAD_MEM:
+			if (!l2_buf) {
+				fwldr_dbg_err("Invalid params to Load Mem\n");
+				res = FWLDR_FAIL;
+				quit = 1;
+				break;
+			}
+
+			/* Load mem record */
+			l1_rec.arg1 =
+				fwldr_read_le4(&l1_buf[FWLDR_L1_ARG1_OFF]);
+
+			snprintf(info_buf,
+				 sizeof(info_buf),
+				 "%-12s: Addr: 0x%08X: Size: 0x%08X\n",
+				 "LoadMem", l1_rec.arg1, l2_len);
+
+			lm_v.dst_addr = l1_rec.arg1;
+			lm_v.len = l2_len;
+			lm_v.src_buf = l2_buf;
+
+			fwldr_load_mem(lm_v.dst_addr,
+				       lm_v.len,
+				       lm_v.src_buf);
+			break;
+
+		case FWLDR_L1_CMD_START_THRDS:
+			/* Start each thread with initial SP */
+			if (!l2_buf) {
+				fwldr_dbg_err("%s : %d Invalid params\n",
+					      __func__, __LINE__);
+				res = FWLDR_FAIL;
+				quit = 1;
+				break;
+			}
+
+			cfg_buf[0] = '\0';
+			cfg_buf_ptr = cfg_buf;
+
+			while (l2_len > 0) {
+				struct fwldr_thrd_info tinfo_v;
+
+				snprintf(cfg_buf_ptr,
+					 sizeof(cfg_buf),
+					 "\tThrd %d: SP: 0x%08X: PC: 0x%08X: Catch: 0x%08X\n",
+					 fwldr_read_le4(l2_buf),
+					 fwldr_read_le4(l2_buf + 4),
+					 fwldr_read_le4(l2_buf + 8),
+					 fwldr_read_le4(l2_buf + 12));
+
+				tinfo_v.thrd_num = fwldr_read_le4(l2_buf);
+				tinfo_v.stack_ptr = fwldr_read_le4(l2_buf + 4);
+				tinfo_v.prog_ctr = fwldr_read_le4(l2_buf + 8);
+				tinfo_v.catch_state_addr =
+					fwldr_read_le4(l2_buf + 12);
+
+				fwldr_start_thrd(tinfo_v.thrd_num,
+						 tinfo_v.stack_ptr,
+						 tinfo_v.prog_ctr,
+						 tinfo_v.catch_state_addr);
+
+				l2_buf += (4 * sizeof(unsigned int));
+				l2_len -= (4 * sizeof(unsigned int));
+				cfg_buf_ptr += strlen(cfg_buf_ptr);
+			}
+
+			snprintf(info_buf,
+				 sizeof(info_buf),
+				 "%-12s:\n%s",
+				 "StartThrds",
+				 cfg_buf);
+
+			break;
+
+		case FWLDR_L1_CMD_ZERO_MEM:
+			/* Zero memory */
+			l1_rec.arg1 =
+				fwldr_read_le4(&l1_buf[FWLDR_L1_ARG1_OFF]);
+			l1_rec.arg2 =
+				fwldr_read_le4(&l1_buf[FWLDR_L1_ARG2_OFF]);
+
+			snprintf(info_buf,
+				 sizeof(info_buf),
+				 "%-12s: Addr: 0x%08X: Size: 0x%08X\n",
+				 "ZeroMem",
+				 l1_rec.arg1,
+				 l1_rec.arg2);
+
+			lm_v.dst_addr = l1_rec.arg1;
+			lm_v.len = l1_rec.arg2;
+
+			fwldr_zero_mem(lm_v.dst_addr, lm_v.len);
+
+			break;
+
+		case FWLDR_L1_CMD_CONFIG:
+			/* Configuration commands */
+			buf_len = (l1_rec.l2_len / 8) * 40;
+
+			if (!l2_buf) {
+				fwldr_dbg_err("%s:%d:Invalid params\n",
+					      __func__, __LINE__);
+				res = FWLDR_FAIL;
+				quit = 1;
+				break;
+			}
+
+			cfg_str = kmalloc(buf_len, GFP_KERNEL);
+
+			if (cfg_str == NULL) {
+				fwldr_dbg_err("Failed to allocate cfg_str\n");
+			} else {
+				str_curr = cfg_str;
+				str_end = cfg_str + buf_len;
+			}
+
+			do {
+				int rec_len = 0, len = 0;
+				unsigned int cmd = fwldr_read_le4(l2_buf);
+
+				if ((str_curr && cfg_str) &&
+				    ((str_end - str_curr) < 256)) {
+					size_t pos = str_curr - cfg_str;
+
+					/* Extend buffer */
+					buf_len *= 2;
+
+					str_new = krealloc(cfg_str,
+							   buf_len,
+							   GFP_KERNEL);
+
+					if (str_new == NULL) {
+						fwldr_dbg_err("%s : %d %s\n",
+							__func__,
+							__LINE__,
+							"realloc failed");
+						kfree(cfg_str);
+						cfg_str = NULL;
+						str_curr = NULL;
+						str_end = NULL;
+					} else {
+						cfg_str	= str_new;
+						/* Relocate pointers */
+						str_curr = cfg_str +
+							   pos;
+						str_end = cfg_str +
+							  buf_len;
+					}
+				}
+
+				switch (cmd) {
+				case FWLDR_CONF_CMD_PAUSE:
+					rec_len = 8;
+					/* TODO: Calculate the exact delay */
+					mdelay(2);
+					break;
+				case FWLDR_CONF_CMD_READ:
+					rec_len = 8;
+
+					rw_v.addr = fwldr_read_le4(&l2_buf[4]);
+					rw_v.val = fwldr_config_read(rw_v.addr);
+
+					if (str_curr) {
+						len = snprintf(str_curr,
+							       buf_len,
+							       "\tRead : 0x%08X\n",
+							       rw_v.addr);
+					}
+
+
+					/* Value read is in rw_v */
+					break;
+
+				case FWLDR_CONF_CMD_WRITE:
+					rec_len = 12;
+
+					rw_v.addr = fwldr_read_le4(&l2_buf[4]);
+					rw_v.val = fwldr_read_le4(&l2_buf[8]);
+
+					if (str_curr) {
+						len = snprintf(str_curr,
+							       buf_len,
+							       "\tWrite: 0x%08X: 0x%08X\n",
+							       rw_v.addr,
+							       rw_v.val);
+					}
+
+
+					fwldr_config_write(rw_v.addr, rw_v.val);
+
+					break;
+
+				case FWLDR_CONF_CMD_USER:
+					if (str_curr) {
+						unsigned int v1 = 0;
+						unsigned int v2 = 0;
+						unsigned int v3 = 0;
+						unsigned int v4 = 0;
+
+						v1 =
+						    fwldr_read_le4(&l2_buf[4]),
+						v2 =
+						    fwldr_read_le4(&l2_buf[8]),
+						v3 =
+						    fwldr_read_le4(&l2_buf[12]),
+						v4 =
+						    fwldr_read_le4(&l2_buf[16]),
+
+						len = snprintf(str_curr,
+							       buf_len,
+							       "\tUser: 0x%08X: 0x%08X: 0x%08X: 0x%08X\n",
+							       v1,
+							       v2,
+							       v3,
+							       v4);
+					}
+
+					rec_len = 20;
+					break;
+
+				default:
+					if (str_curr) {
+						len = snprintf(str_curr,
+							       buf_len,
+							       "\tUnknown: %08X (%d bytes remain)\n",
+							       cmd,
+							       l2_len);
+					}
+					break;
+				}
+
+				if ((rec_len == 0) || (res == FWLDR_FAIL))
+					break;
+
+				if (str_curr)
+					str_curr += len;
+
+				l2_buf += rec_len;
+				l2_len -= rec_len;
+			} while (l2_len > 0);
+
+			snprintf(info_buf, sizeof(info_buf),
+				 "%-12s: %d bytes %s\n", "Config",
+				 (unsigned int)(l2_buf-l2_blk),
+				 ((l2_len != 0) ? ": ERROR!!" : ""));
+			break;
+
+		case FWLDR_L1_CMD_FILENAME:
+			if (!l2_blk) {
+				fwldr_dbg_err("Invalid params to Filename\n");
+				res = FWLDR_FAIL;
+				quit = 1;
+				break;
+			}
+
+			snprintf(info_buf,
+				 sizeof(info_buf),
+				 "%-12s: %s\n",
+				 "FileName",
+				 l2_blk + 8);
+			break;
+
+		default:
+			/* Not expected */
+			snprintf(info_buf,
+				 sizeof(info_buf),
+				 "%-12s\n",
+				 "Unknown");
+			break;
+		}
+
+		kfree(l2_blk);
+
+		if (cfg_str) {
+			fwldr_dbg_info("0x%08X: %s%s",
+				       file_offset,
+				       info_buf,
+				       cfg_str);
+			kfree(cfg_str);
+			cfg_str = NULL;
+		} else {
+			fwldr_dbg_info("0x%08X: %s ",
+				       file_offset,
+				       info_buf);
+		}
+
+		if (l1_rec.nxt == FWLDR_L1_TERMINATE) {
+			unsigned int overlay_off = 0;
+
+			/* There is the possibility of further overlays.
+			 * Without additional information, the best guess is
+			 * that they start immediately after the L2 data of the
+			 * last record.
+			 */
+			l1_rec.l2_offset = fwldr_read_le4(&l1_buf[l1_rec.len -
+							  FWLDR_L1_L2OFF_OFF]);
+			l1_rec.l2_len = fwldr_read_le2(&l1_buf[l1_rec.len -
+						       FWLDR_L1_L2LEN_OFF]);
+
+			overlay_off = fwldr_virt_to_linear_off(page_size,
+							      l1_rec.l2_offset);
+			overlay_off += l1_rec.l2_len;
+
+			/* Round to next 32-bit boundary */
+			overlay_off += 3;
+			overlay_off &= ~3;
+
+			fwldr_dbg_info("\n");
+			fwldr_dbg_info("Possible next L1 Record 0x%08X\n",
+				       overlay_off);
+
+			quit = 1;
+		} else {
+			/* Move on to next L1 record */
+			prev_offset = file_offset;
+			file_offset = fwldr_virt_to_linear_off(page_size,
+							       l1_rec.nxt);
+
+			if (file_offset <= prev_offset) {
+				/* Possibly incorrect page size specified.
+				 * Stopping
+				 */
+				fwldr_dbg_err("Out of sequence record found\n");
+				quit = 1;
+			}
+		}
+	}
+
+	return res;
+}
+
+
+static int fwldr_wait_for_completion(void)
+{
+	struct fwldr_cfg_rw rw_v;
+	int result = 1;
+	unsigned int i = 0;
+
+	rw_v.addr = UCCP_GRAM_BASE + UCCP_THRD_EXEC_SIG_OFFSET;
+
+	do {
+		rw_v.val = fwldr_config_read(rw_v.addr);
+		/* Sleep for 10 ms */
+		mdelay(10);
+
+		i++;
+
+	} while ((UCCP_THRD_EXEC_SIG != rw_v.val) && (i < 1000));
+
+	if (i == 1000)
+		result = 0;
+
+	rw_v.addr = UCCP_GRAM_BASE + UCCP_THRD_EXEC_SIG_OFFSET;
+	rw_v.val = 0x00;
+
+	fwldr_config_write(rw_v.addr, rw_v.val);
+
+	return result;
+}
diff --git a/drivers/net/wireless/uccp420wlan/src/hal_hostport.c b/drivers/net/wireless/uccp420wlan/src/hal_hostport.c
new file mode 100644
index 0000000..71a2af9
--- /dev/null
+++ b/drivers/net/wireless/uccp420wlan/src/hal_hostport.c
@@ -0,0 +1,1858 @@
+/*
+ * File Name  : hal_hostport.c
+ *
+ * This file contains the source functions of HAL IF for hostport+shared
+ * memmory based communications
+ *
+ * Copyright (c) 2011, 2012, 2013, 2014 Imagination Technologies Ltd.
+ * All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/interrupt.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/netdevice.h>
+
+#include <asm/unaligned.h>
+
+#include <linux/time.h>
+#include <linux/sort.h>
+
+#include "hal.h"
+#include "hal_hostport.h"
+
+#include <linux/of.h>
+#include <linux/of_net.h>
+#include <linux/of_device.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/iio/consumer.h>
+
+#define COMMAND_START_MAGIC 0xDEAD
+
+static int is_mem_dma(void *virt_addr, int len);
+static int init_rx_buf(int pkt_desc,
+		       unsigned int max_data_size,
+		       dma_addr_t *dma_buf,
+		       struct sk_buff *new_skb);
+
+static int is_mem_bounce(void *virt_addr, int len);
+
+static struct hal_priv *hpriv;
+static const char *hal_name = "UCCP420_WIFI_HAL";
+
+static unsigned long shm_offset = HAL_SHARED_MEM_OFFSET;
+module_param(shm_offset, ulong, S_IRUSR|S_IWUSR);
+
+unsigned int hal_cmd_sent;
+unsigned int hal_event_recv;
+struct timer_list stats_timer;
+unsigned int alloc_skb_failures;
+unsigned int alloc_skb_dma_region;
+unsigned int alloc_skb_priv_region;
+unsigned int alloc_skb_priv_runtime;
+
+static unsigned int uccp_ddr_base;
+
+#ifdef PERF_PROFILING
+/* The timing markers */
+unsigned long irq_timestamp[20] = {0};
+unsigned long rcv_hdlr_time[20] = {0};
+unsigned long rx_pkts_halint_event[20] = {0};
+unsigned long halint_event_handling_time[20] = {0};
+unsigned long pflags;
+
+/*Indexs for current sample*/
+unsigned int halint_handling_index;
+unsigned int rx_pkt_index;
+unsigned int rcv_hdlr_index;
+unsigned int irq_ts_index;
+spinlock_t  timing_lock;
+#endif
+
+#ifdef HAL_DEBUG
+#define _HAL_DEBUG(fmt, args...) pr_debug(fmt, ##args)
+/* for send and receive count. */
+static unsigned long tx_cnt;
+static unsigned long rx_cnt;
+#else /* CONFIG_HAL_DEBUG */
+#define _HAL_DEBUG(...) do { } while (0)
+#endif /* CONFIG_HAL_DEBUG */
+
+unsigned char vif_macs[2][ETH_ALEN];
+
+static char *mac_addr;
+module_param(mac_addr, charp, 0000);
+MODULE_PARM_DESC(mac_addr, "Configure wifi base mac address");
+
+#define RF_PARAMS_SIZE 369
+unsigned char rf_params[RF_PARAMS_SIZE];
+unsigned char *rf_params_vpd;
+int num_streams_vpd = -1;
+
+/* Range check */
+#define CHECK_EVENT_ADDR_UCCP(x) ((x) >= HAL_UCCP_GRAM_BASE && (x) <=\
+				  (HAL_UCCP_GRAM_BASE + \
+				  hpriv->uccp_pkd_gram_len))
+
+#define CHECK_EVENT_STATUS_ADDR_UCCP(x) ((x) >= HAL_UCCP_GRAM_BASE && (x) <=\
+					 (HAL_UCCP_GRAM_BASE + \
+					 hpriv->uccp_pkd_gram_len))
+
+#define CHECK_EVENT_LEN(x) ((x) < 0x5000)
+#define CHECK_RX_PKT_CNT(x) ((x) >= 1 && (x) <= 16)
+/* #define CHECK_SRC_PTR(x, y) ((x) >= (y) && (x) <= (y) +
+ * HAL_HOST_UCCP_RAM_LEN)
+ */
+#define CHECK_PKT_DESC(x) ((x) < (hpriv->rx_bufs_2k + hpriv->rx_bufs_12k))
+/* MAX_RX_BUFS */
+
+#define DEFAULT_MAC_ADDRESS "001122334455"
+
+static int hal_reset_hal_params(void)
+{
+	hpriv->cmd_cnt = COMMAND_START_MAGIC;
+	hpriv->event_cnt = 0;
+	return 0;
+}
+
+
+static int hal_ready(struct hal_priv *priv)
+{
+	unsigned int value = 0;
+
+	/* Check the ACK register bit */
+	value =  readl((void __iomem *)(HOST_TO_UCCP_CORE_CMD_ADDR));
+
+	if (value & BIT(UCCP_CORE_HOST_INT_SHIFT))
+		return 0;
+	else
+		return 1;
+}
+
+
+static void tx_tasklet_fn(unsigned long data)
+{
+	struct hal_priv *priv = (struct hal_priv *)data;
+	struct sk_buff *skb;
+	unsigned int value = 0;
+	unsigned long start_addr;
+	struct timeval tv_start, tv_now;
+	long usec_diff = 0;
+
+	while ((skb = skb_dequeue(&priv->txq))) {
+#ifdef HAL_DEBUG
+		tx_cnt++;
+		pr_debug("%s: tx_cnt=%ld cmd_cnt=0x%X event_cnt=0x%X\n",
+		       hal_name, tx_cnt, priv->cmd_cnt, priv->event_cnt);
+		pr_debug("%s: xmit dump\n", hal_name);
+		print_hex_dump(KERN_DEBUG, " ", DUMP_PREFIX_NONE, 16, 1,
+			       skb->data, skb->len, 1);
+#endif
+
+		/* Getting current time */
+		do_gettimeofday(&tv_start);
+
+		while (!hal_ready(priv)) {
+			/* Acquisition of the elapsed time */
+			do_gettimeofday(&tv_now);
+
+			if ((tv_now.tv_sec - tv_start.tv_sec) == 0) {
+				usec_diff = tv_now.tv_usec - tv_start.tv_usec;
+			} else {
+				/* Exceeding the second */
+				usec_diff = tv_now.tv_usec + (((1000 * 1000) -
+							 tv_start.tv_usec) + 1);
+			}
+
+			/* Checking the 1st Milestone & time-out(1000000usec) */
+			if (usec_diff > 1000 * 1000)
+				break;
+		}
+
+		if (!hal_ready(priv)) {
+			pr_err("%s: Intf not ready for %ld us, dropping cmd\n",
+			       hal_name, usec_diff);
+			dev_kfree_skb_any(skb);
+			skb = NULL;
+		}
+
+		if (!skb)
+			continue;
+
+		if (usec_diff > 1000) {
+			pr_err("%s: Interface ready took %ld us (> 1000 us)\n",
+			       hal_name, usec_diff);
+		}
+
+		if (priv->hal_disabled)
+			break;
+
+		/* Write the command buffer in GRAM */
+		start_addr = readl((void __iomem *)HAL_GRAM_CMD_START);
+#ifdef HAL_DEBUG
+		pr_debug("%s: Command address = 0x%08x\n",
+			 hal_name, (unsigned int)start_addr);
+#endif
+		start_addr -= HAL_UCCP_GRAM_BASE;
+		start_addr += ((priv->gram_mem_addr)-(priv->shm_offset));
+
+		if ((start_addr < priv->gram_mem_addr) ||
+		    (start_addr > (priv->gram_mem_addr + HAL_WLAN_GRAM_LEN))) {
+			pr_err("%s: Invalid cmd addr 0x%08x, dropping cmd\n",
+			       hal_name, (unsigned int)start_addr);
+			dev_kfree_skb_any(skb);
+			skb = NULL;
+
+			continue;
+		}
+
+		memcpy((unsigned char *)start_addr, skb->data, skb->len);
+
+		writel(skb->len, (void __iomem *)HAL_GRAM_CMD_LEN);
+
+		value = (unsigned int) (priv->cmd_cnt);
+		value |= 0x7fff0000;
+
+		writel(value, (void __iomem *)(HOST_TO_UCCP_CORE_CMD_ADDR));
+
+		priv->cmd_cnt++;
+		hal_cmd_sent++;
+
+		dev_kfree_skb_any(skb);
+	}
+}
+
+
+static void hostport_send(struct hal_priv  *priv,
+			  struct sk_buff   *skb)
+{
+	skb_queue_tail(&priv->txq, skb);
+	tasklet_schedule(&priv->tx_tasklet);
+}
+
+
+static void hal_send(void *nwb,
+		     unsigned char rcv_mod_id,
+		     unsigned char send_mod_id,
+		     void *dataptr)
+	{
+	struct sk_buff *cmd = (struct sk_buff *)nwb, *skb, *tmp;
+	struct sk_buff_head *skb_list;
+	struct hal_hdr *hdr;
+	unsigned long dcp_start_addr;
+	unsigned int pkt = 0, desc_id = 0, frame_id = 0;
+	struct hal_tx_data *hal_tx_data = NULL;
+	struct buf_info *tx_buf_info = NULL;
+	dma_addr_t dma_buf;
+
+	if (dataptr) {
+		hdr = (struct hal_hdr *)cmd->data;
+		skb_list = (struct sk_buff_head *)dataptr;
+
+		/* Struct of CMD's are hal_data + desc_id + payload_len*/
+		desc_id = (*(unsigned int *)(cmd->data + HAL_PRIV_DATA_SIZE)) &
+			   0x0000FFFF;
+
+		skb_queue_walk_safe(skb_list, skb, tmp)
+			{
+			frame_id = (desc_id * NUM_FRAMES_IN_TX_DESC) + pkt;
+			hal_tx_data = &hpriv->hal_tx_data[frame_id];
+			tx_buf_info = &hpriv->tx_buf_info[frame_id];
+
+			hal_tx_data->data_len = tx_buf_info->dma_buf_len;
+
+			dma_buf = tx_buf_info->dma_buf;
+			dma_buf -= uccp_ddr_base;
+
+			hal_tx_data->address = dma_buf >> 2;
+			hal_tx_data->offset = dma_buf & 0x00000003;
+			pkt++;
+			}
+
+		/* WRITE TO GRAM: HAL TX DATA Portion*/
+		dcp_start_addr = HAL_GRAM_TX_DATA_START +
+				 (desc_id * TX_DESC_HAL_SIZE);
+
+		memcpy((void *)dcp_start_addr,
+		       &hpriv->hal_tx_data[(desc_id * NUM_FRAMES_IN_TX_DESC)],
+		       TX_DESC_HAL_SIZE);
+	}
+
+	hostport_send(hpriv, nwb);
+
+}
+
+
+static void rx_tasklet_fn(unsigned long data)
+{
+	struct hal_priv *priv = (struct hal_priv *)data;
+	struct sk_buff  *skb;
+	unsigned char *buf;
+	unsigned long temp;
+	unsigned char *nbuff;
+	struct event_hal *evnt;
+	struct cmd_hal cmd_rx;
+	struct sk_buff *nbuf, *rx_skb, *rfl_skb, *tmp_buf;
+	unsigned char *cmd_data;
+	unsigned int payload_length, length, data_length;
+	void __iomem *src_ptr;
+	int count = 0;
+	unsigned int pkt_desc = 0, max_data_size = MAX_DATA_SIZE_2K;
+	dma_addr_t dma_buf = 0;
+	unsigned long event_addr, event_status_addr, event_len;
+#ifdef PERF_PROFILING
+	struct timeval  tv_start, tv_now, full_tv_start, full_tv_now;
+	long usec_diff = 0, full_usec_diff = 0;
+#endif
+	struct buf_info *rx_buf_info = NULL;
+	struct buf_info temp_rx_buf_info;
+	struct sk_buff *new_skb;
+
+	while ((skb = skb_dequeue(&priv->rxq))) {
+		event_addr = *((unsigned long *)(skb->cb));
+		event_status_addr = *((unsigned long *)(skb->cb + 4));
+		event_len = *(unsigned long *)(skb->cb + 8);
+
+		/* Range check */
+		if (skb->len > event_len) {
+			pr_err("%s: Err! skb->len=%d, event_len =%d\n",
+			       __func__, skb->len, (int)event_len);
+			dev_kfree_skb_any(skb);
+			continue;
+		}
+
+		temp = event_addr;
+		buf = skb_put(skb, event_len);
+		memcpy(buf, (unsigned char *)temp, skb->len);
+
+		/* Mark the buffer free */
+		temp = event_status_addr;
+#ifdef HAL_DEBUG
+		pr_debug("%s: Freeing event buffer at 0x%08x\n",
+			 hal_name, (unsigned int)temp);
+#endif
+		*((unsigned long *)temp) = 0;
+
+#ifdef HAL_DEBUG
+		rx_cnt++;
+		pr_debug("%s:rx_cnt=%ld cmd_cnt=0x%X event_cnt=0x%X\n",
+			 hal_name, rx_cnt, priv->cmd_cnt, priv->event_cnt);
+		pr_debug("%s: recv dump\n", hal_name);
+		print_hex_dump(KERN_DEBUG, " ", DUMP_PREFIX_NONE, 16, 1,
+			       skb->data, skb->len, 1);
+#endif
+		nbuff = skb->data;
+		evnt = (struct event_hal *)nbuff;
+
+		/* Message from HAL after the DMA completion,
+		 * Fetch the buffer addrs from UCCP HOST RAM
+		 * Copy them to the skb
+		 * Pass them up
+		 * Refresh the RX descriptor in firmware
+		 */
+		if (evnt->hdr.id == 0xffffffff) {
+			/* HAL_INTERNAL CMD */
+			memset(&cmd_rx, 0, sizeof(struct cmd_hal));
+
+			if (!CHECK_RX_PKT_CNT(evnt->rx_pkt_cnt)) {
+				/* Range check */
+				pr_err("%s: Error!!! rx_pkt_cnt = %d\n",
+				       __func__, evnt->rx_pkt_cnt);
+				dev_kfree_skb_any(skb);
+				continue;
+			}
+
+#ifdef PERF_PROFILING
+			do_gettimeofday(&full_tv_start);
+
+			/* HAL Profile Stat: Rx Pkts per HAL internal Event */
+			rx_pkts_halint_event[rx_pkt_index] = evnt->rx_pkt_cnt;
+			rx_pkt_index = (rx_pkt_index + 1) % 20;
+#endif
+			for (count = 0; count < evnt->rx_pkt_cnt; count++) {
+				pkt_desc = evnt->rx_pkt_desc[count];
+
+				/* Range check */
+				if (!CHECK_PKT_DESC(pkt_desc)) {
+					pr_err("%s: Error!!! pkt_desc = %d\n",
+					       __func__, pkt_desc);
+
+					/* Drop all the remaining buffers: As
+					 * per Design They will not be reclaimed
+					 * by FW.
+					 */
+					break;
+				}
+
+				if (pkt_desc >= hpriv->rx_bufs_2k)
+					max_data_size = MAX_DATA_SIZE_12K;
+				if (hpriv->rx_buf_info == NULL)
+					break;
+
+				rx_buf_info = hpriv->rx_buf_info + pkt_desc;
+
+				memcpy(&temp_rx_buf_info,
+				       rx_buf_info,
+				       sizeof(struct buf_info));
+
+				dma_unmap_single(NULL,
+						 rx_buf_info->dma_buf,
+						 rx_buf_info->dma_buf_len,
+						 DMA_FROM_DEVICE);
+
+				dma_buf = rx_buf_info->dma_buf;
+				src_ptr = (void __iomem *)phys_to_virt(dma_buf);
+
+
+#ifdef HAL_DEBUG
+				pr_debug("%s: dma_buf = 0x%08X\n",
+					 hal_name, (unsigned int)dma_buf);
+
+				pr_debug("%s:src_ptr dump: size=200\n",
+					 hal_name);
+
+				print_hex_dump(KERN_DEBUG, " ",
+					       DUMP_PREFIX_NONE, 16, 1, src_ptr,
+					       200, 1);
+#endif
+
+				/* Offset in UMAC_LMAC_MSG_HDR, points to
+				 * payload_length
+				 */
+
+				/* 802.11hdr + payload Len*/
+				payload_length = *(((unsigned int *)src_ptr) +
+						   3);
+				length = *(((unsigned int *)src_ptr) + 5);
+
+				/* Control Info Len*/
+				data_length = payload_length + length;
+
+				/* Complete data length to be copied */
+				_HAL_DEBUG("%s: Payload Len =%d(0x%x), ",
+					   hal_name,
+					   payload_length,
+					   payload_length);
+
+				_HAL_DEBUG("Len=%d(0x%x), ",
+					   length,
+					   length);
+
+				_HAL_DEBUG("Data Len = %d(0x%x)\n",
+					   data_length,
+					   data_length);
+
+				if (data_length > max_data_size) {
+					pr_err("Max length exceeded,dumping the event\n");
+
+					tmp_buf = (struct sk_buff *)nbuff;
+
+					print_hex_dump(KERN_ERR,
+						       " ",
+						       DUMP_PREFIX_NONE,
+						       16,
+						       1,
+						       tmp_buf,
+						       tmp_buf->len,
+						       1);
+
+					/* Do not send the packet UP,
+					 * just refill the buffer
+					 * and give it to HW, for
+					 * non-DMA case give the same
+					 * buffer.
+					 */
+					dma_map_single(NULL,
+						       rx_buf_info->src_ptr,
+						       max_data_size,
+						       DMA_FROM_DEVICE);
+					cmd_rx.rx_pkt_data.rx_pkt_cnt++;
+					cmd_rx.rx_pkt_data.rx_pkt[count].desc =
+						evnt->rx_pkt_desc[count];
+					cmd_rx.rx_pkt_data.rx_pkt[count].ptr  =
+						dma_buf - uccp_ddr_base;
+					continue;
+				}
+
+				new_skb = alloc_skb(max_data_size, GFP_ATOMIC);
+
+				if (!new_skb) {
+					pr_err("%s Failed to initialize RX buf %d\n",
+					       hal_name, pkt_desc);
+
+					/* If allocation fails, drop the packet,
+					 * continue
+					 */
+					memcpy(rx_buf_info,
+					       &temp_rx_buf_info,
+					       sizeof(struct buf_info));
+
+					dma_map_single(NULL,
+						       rx_buf_info->src_ptr,
+						       max_data_size,
+						       DMA_FROM_DEVICE);
+
+					dma_buf = rx_buf_info->dma_buf;
+				} else {
+					rx_skb = temp_rx_buf_info.skb;
+
+					if (temp_rx_buf_info.dma_buf_priv) {
+						memcpy(skb_put(rx_skb,
+						       data_length),
+						       src_ptr,
+						       data_length);
+
+					} else {
+						skb_put(rx_skb, data_length);
+					}
+
+					init_rx_buf(pkt_desc, max_data_size,
+						    &dma_buf, new_skb);
+					skb_queue_tail(&hpriv->refillq, rx_skb);
+				}
+
+				cmd_rx.rx_pkt_data.rx_pkt_cnt++;
+				cmd_rx.rx_pkt_data.rx_pkt[count].desc =
+					evnt->rx_pkt_desc[count];
+				cmd_rx.rx_pkt_data.rx_pkt[count].ptr =
+					dma_buf - uccp_ddr_base;
+
+			}
+
+			if (cmd_rx.rx_pkt_data.rx_pkt_cnt != 0) {
+				cmd_rx.hdr.id = 0xffffffff;
+
+				/* Inform HAL about the newly allocated
+				 * buffers
+				 */
+				nbuf = alloc_skb(sizeof(struct cmd_hal),
+						 GFP_ATOMIC);
+				if (!nbuf) {
+					pr_err("%s Out of memory\n", hal_name);
+				} else {
+
+					cmd_data = skb_put(nbuf,
+						   sizeof(struct cmd_hal));
+
+					memcpy(cmd_data,
+					       (unsigned char *)&cmd_rx,
+					       sizeof(struct cmd_hal));
+					hal_cmd_sent--;
+					hostport_send(hpriv, nbuf);
+
+				}
+			}
+
+#ifdef PERF_PROFILING
+			do_gettimeofday(&full_tv_now);
+
+			if ((full_tv_now.tv_sec - full_tv_start.tv_sec) == 0) {
+				full_usec_diff = full_tv_now.tv_usec -
+						 full_tv_start.tv_usec;
+			} else {
+				/* Exceeding the second */
+				full_usec_diff = full_tv_now.tv_usec +
+						 (((1000 * 1000) -
+						  full_tv_start.tv_usec) + 1);
+			}
+
+			spin_lock_irqsave(&timing_lock, pflags);
+
+			halint_event_handling_time[halint_handling_index] =
+			full_usec_diff;
+
+			halint_handling_index = (halint_handling_index +
+						 1) % 20;
+
+			spin_unlock_irqrestore(&timing_lock, pflags);
+
+			/* Start the Timer for RCV Handler Profiling */
+			do_gettimeofday(&tv_start);
+#endif
+			/* As we refilled the buffers, now pass them UP */
+			while ((rfl_skb = skb_dequeue(&hpriv->refillq)))
+				priv->rcv_handler(rfl_skb, LMAC_MOD_ID);
+#ifdef PERF_PROFILING
+			do_gettimeofday(&tv_now);
+
+			if ((tv_now.tv_sec - tv_start.tv_sec) == 0) {
+				usec_diff = tv_now.tv_usec - tv_start.tv_usec;
+			} else {
+				/* exceeding the second */
+				usec_diff = tv_now.tv_usec +
+					    (((1000 * 1000) -
+					      tv_start.tv_usec) + 1);
+			}
+
+			spin_lock_irqsave(&timing_lock, pflags);
+
+			rcv_hdlr_time[rcv_hdlr_index] = usec_diff;
+			rcv_hdlr_index = (rcv_hdlr_index + 1)%20;
+
+			spin_unlock_irqrestore(&timing_lock, pflags);
+#endif
+			/* Internal CMD, Free it */
+			dev_kfree_skb_any(skb);
+
+		} else	{
+			/* MSG from LMAC, non-data*/
+			hal_event_recv++;
+			priv->rcv_handler(skb, LMAC_MOD_ID);
+		}
+	}
+
+	return;
+}
+
+
+static void hal_register_callback(msg_handler handler,
+				  unsigned char mod_id)
+{
+	hpriv->rcv_handler = handler;
+}
+
+
+static irqreturn_t hal_irq_handler(int    irq, void  *p)
+{
+
+	unsigned int value;
+	unsigned long event_addr, event_status_addr, event_len;
+	unsigned char spurious;
+	struct sk_buff *skb;
+	struct hal_priv *priv = (struct hal_priv *)p;
+#ifdef PERF_PROFILING
+	long usec_diff;
+	struct timeval tv_start, tv_now;
+#endif
+	int is_err = 0;
+
+	spurious = 0;
+
+	value = readl((void __iomem *)(UCCP_CORE_TO_HOST_CMD_ADDR)) &
+		0x7fffffff;
+
+	if (value == (0x7fff0000 | priv->event_cnt)) {
+#ifdef PERF_PROFILING
+		do_gettimeofday(&tv_start);
+#endif
+		event_addr = readl((void __iomem *)HAL_GRAM_EVENT_START);
+		event_status_addr = readl((void __iomem *)(HAL_GRAM_EVENT_START
+							   + 4));
+		event_len = readl((void __iomem *)(HAL_GRAM_EVENT_START + 8));
+
+		/* Range check */
+		if (!(CHECK_EVENT_ADDR_UCCP(event_addr)) ||
+		    !(CHECK_EVENT_STATUS_ADDR_UCCP(event_status_addr)) ||
+		    !CHECK_EVENT_LEN(event_len)) {
+			pr_err("%s: Error!!! event_addr = 0x%08x\n",
+			       __func__, (unsigned int)event_addr);
+
+			pr_err("%s: Error!!! event_len =%d\n",
+			       __func__, (int)event_len);
+
+			pr_err("%s: Error!!! event_status_addr = 0x%08x\n",
+			       __func__, (unsigned int)event_status_addr);
+
+			is_err = 1;
+		}
+
+#ifdef HAL_DEBUG
+		pr_debug("%s: event address = 0x%08x\n",
+			 hal_name, (unsigned int)event_addr);
+
+		pr_debug("%s: event status address = 0x%08x\n",
+			 hal_name, (unsigned int)event_status_addr);
+
+		pr_debug("%s: event len = %d\n",
+			 hal_name, (int)event_len);
+#endif
+
+		if (unlikely(is_err)) {
+			/* If addr is valid try to clear */
+			if (CHECK_EVENT_STATUS_ADDR_UCCP(event_status_addr)) {
+				event_status_addr -= HAL_UCCP_GRAM_BASE;
+				event_status_addr += ((priv->gram_mem_addr) -
+						      (priv->shm_offset));
+				*((unsigned long *)event_status_addr) = 0;
+			} else
+				pr_err("%s: UCCP status addr invalid, not clearing it\n",
+				       hal_name);
+
+			return IRQ_HANDLED;
+		}
+
+		event_addr -= HAL_UCCP_GRAM_BASE;
+		event_status_addr -= HAL_UCCP_GRAM_BASE;
+		event_addr += ((priv->gram_mem_addr) - (priv->shm_offset));
+		event_status_addr += ((priv->gram_mem_addr) -
+				      (priv->shm_offset));
+
+		skb = dev_alloc_skb(event_len);
+
+		if (!skb) {
+			pr_err("%s: Alloc SKB Failed for %ld\n",
+			       hal_name, event_len);
+			*((unsigned long *)event_status_addr) = 0;
+		} else {
+			*(unsigned long *)(skb->cb) = event_addr;
+
+			/* Address of event payload */
+			*(unsigned long *)(skb->cb + 4) = event_status_addr;
+
+			/* Address to mark free */
+			*(unsigned long *)(skb->cb + 8) = event_len;
+
+			/* Length of event payload */
+			skb_queue_tail(&priv->rxq, skb);
+			tasklet_schedule(&priv->rx_tasklet);
+		}
+
+		priv->event_cnt++;
+	} else {
+		spurious = 1;
+	}
+
+	if (!spurious) {
+		/* Clear the uccp interrupt */
+		value = 0;
+		value |= BIT(UCCP_CORE_INT_CLR_SHIFT);
+		writel(*((unsigned long   *)&(value)),
+		(void __iomem *)(HOST_TO_UCCP_CORE_ACK_ADDR));
+	} else {
+		pr_warn("%s: Spurious interrupt received\n", hal_name);
+
+	}
+
+#ifdef PERF_PROFILING
+	do_gettimeofday(&tv_now);
+
+	if ((tv_now.tv_sec - tv_start.tv_sec) == 0) {
+		usec_diff = tv_now.tv_usec - tv_start.tv_usec;
+	} else {
+		/* Exceeding the second */
+		usec_diff = tv_now.tv_usec +
+			    (((1000 * 1000) - tv_start.tv_usec) + 1);
+	}
+
+	spin_lock_irqsave(&timing_lock, pflags);
+
+	irq_timestamp[irq_ts_index] = usec_diff;
+	irq_ts_index = (irq_ts_index + 1)%20;
+
+	spin_unlock_irqrestore(&timing_lock, pflags);
+#endif
+	return IRQ_HANDLED;
+}
+
+
+static void hal_enable_int(void  *p)
+{
+	unsigned int   value = 0;
+
+	/* Set external pin irq enable for host_irq and uccp_irq */
+	value = readl((void __iomem *)UCCP_CORE_INT_ENAB_ADDR);
+	value |= BIT(UCCP_CORE_INT_IRQ_ENAB_SHIFT);
+
+	writel(*((unsigned long   *)&(value)),
+	       (void __iomem *)(UCCP_CORE_INT_ENAB_ADDR));
+
+	/* Enable raising uccp_int when UCCP_INT = 1 */
+	value = 0;
+	value |= BIT(UCCP_CORE_INT_EN_SHIFT);
+	writel(*((unsigned long *)&(value)),
+	       (void __iomem *)(UCCP_CORE_INT_ENABLE_ADDR));
+
+	return;
+}
+
+
+static void hal_disable_int(void  *p)
+{
+	unsigned int value = 0;
+
+	/* Reset external pin irq enable for host_irq and uccp_irq */
+	value = readl((void __iomem *)UCCP_CORE_INT_ENAB_ADDR);
+	value &= ~(BIT(UCCP_CORE_INT_IRQ_ENAB_SHIFT));
+	writel(*((unsigned long   *)&(value)),
+	       (void __iomem *)(UCCP_CORE_INT_ENAB_ADDR));
+
+	/* Disable raising uccp_int when UCCP_INT = 1 */
+	value = 0;
+	value &= ~(BIT(UCCP_CORE_INT_EN_SHIFT));
+	writel(*((unsigned long *)&(value)),
+	       (void __iomem *)(UCCP_CORE_INT_ENABLE_ADDR));
+
+	return;
+}
+
+
+#ifdef PERF_PROFILING
+static int ulong_cmp(const void *a, const void *b)
+{
+	return *(unsigned long *)a - *(unsigned long *)b;
+}
+
+
+static int avg_array(unsigned long *arr, unsigned int max_index)
+{
+	unsigned int index;
+	unsigned int avg = 0;
+
+	if (!max_index)
+		return 0;
+
+	for (index = 0; index < max_index; index++)
+		avg += arr[index];
+
+	return avg/max_index;
+}
+
+
+static int max_array(unsigned long *arr, unsigned int max_index)
+{
+	sort(arr, max_index, sizeof(unsigned long), ulong_cmp, NULL);
+	return arr[max_index-1];
+}
+#endif
+
+
+static int proc_read_hal_stats(struct seq_file *m, void *v)
+{
+#ifdef PERF_PROFILING
+	int index, max_index = 20;
+
+	seq_puts(m, "************* Host HAL Stats ***********\n");
+
+	seq_printf(m, "IRQ TIME: AVG: %d, MAX: %d\n",
+		   avg_array(irq_timestamp, 20),
+		   max_array(irq_timestamp, 20));
+
+	for (index = 0; index < max_index; index++)
+		seq_printf(m, "IRQ[%d] = %ld\n",
+			   index,
+			   irq_timestamp[index]);
+
+	seq_printf(m, "RCV Handler TIME: AVG: %d, MAX: %d\n",
+		   avg_array(rcv_hdlr_time, 20),
+		   max_array(rcv_hdlr_time, 20));
+
+	for (index = 0; index < max_index; index++)
+		seq_printf(m, "RH[%d] = %ld\n",
+			   index,
+			   rcv_hdlr_time[index]);
+
+	seq_printf(m, "Packetx Rx with HAL Internal: AVG: %d, MAX: %d\n",
+		   avg_array(rx_pkts_halint_event, 20),
+		   max_array(rx_pkts_halint_event, 20));
+
+	for (index = 0; index < max_index; index++)
+		seq_printf(m, "RXPKT[%d] = %ld\n",
+			   index,
+			   rx_pkts_halint_event[index]);
+
+	seq_printf(m, "HAL Internal Event Handling Time: AVG: %d, MAX: %d\n",
+		   avg_array(halint_event_handling_time, 20),
+		   max_array(halint_event_handling_time, 20));
+
+	for (index = 0; index < max_index; index++)
+		seq_printf(m, "HALINT[%d] = %ld\n",
+			   index,
+			   halint_event_handling_time[index]);
+
+#endif
+
+	seq_printf(m, "Alloc SKB Failures: %d\n",
+		   alloc_skb_failures);
+
+	seq_printf(m, "Alloc SKB in 60 MB DMA Region  %d\n",
+		   alloc_skb_dma_region);
+
+	seq_printf(m, "Alloc SKB in Priv 4 MB Region: %d\n",
+		   alloc_skb_priv_region);
+
+	seq_printf(m, "Alloc SKB Run time: %d\n", alloc_skb_priv_runtime);
+
+	seq_printf(m, "hal_cmd_sent_cnt: %d\n",
+		   hal_cmd_sent);
+
+	seq_printf(m, "hal_event_recv_cnt: %d\n",
+		   hal_event_recv);
+
+	return 0;
+}
+
+
+static int proc_open_hal_stats(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_hal_stats, NULL);
+}
+
+
+static const struct file_operations params_fops_hal_stats = {
+	.open = proc_open_hal_stats,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.write = NULL,
+	.release = single_release
+};
+
+
+static int hal_proc_init(struct proc_dir_entry *hal_proc_dir_entry)
+{
+	struct proc_dir_entry *entry;
+	int err = 0;
+
+	entry = proc_create("hal_stats",
+			    0444,
+			    hal_proc_dir_entry,
+			    &params_fops_hal_stats);
+
+	if (!entry) {
+		pr_err("Failed to create HAL proc entry\n");
+		err = -ENOMEM;
+	}
+
+	return err;
+}
+
+
+#ifdef PERF_PROFILING
+static void stats_timer_expiry(unsigned long data)
+{
+	if (alloc_skb_dma_region) {
+		pr_info("Alloc SKB in 60 MB DMA Region  %d\n",
+			alloc_skb_dma_region);
+
+		alloc_skb_dma_region = 0;
+	}
+
+	if (alloc_skb_priv_region) {
+		pr_info("Alloc SKB in Priv 4 MB Region: %d\n",
+			alloc_skb_priv_region);
+		alloc_skb_priv_region = 0;
+	}
+
+	if (alloc_skb_failures) {
+		pr_info("Alloc SKB Failures: %d\n",
+			alloc_skb_failures);
+		alloc_skb_failures = 0;
+	}
+
+	if (alloc_skb_priv_runtime) {
+		pr_info("Alloc SKB Run time: %d\n",
+			alloc_skb_priv_runtime);
+		alloc_skb_priv_runtime = 0;
+	}
+
+	mod_timer(&stats_timer, jiffies + msecs_to_jiffies(1000));
+}
+#endif
+
+
+int hal_start(struct proc_dir_entry *main_dir_entry)
+{
+	int err = 0;
+
+#ifdef PERF_PROFILING
+	init_timer(&stats_timer);
+	stats_timer.function = stats_timer_expiry;
+	stats_timer.data = (unsigned long) NULL;
+	mod_timer(&stats_timer, jiffies + msecs_to_jiffies(1000));
+#endif
+	err = hal_proc_init(main_dir_entry);
+
+	if (err)
+		return err;
+
+	hpriv->hal_disabled = 0;
+
+	/* Enable host_int and uccp_int */
+	hal_enable_int(NULL);
+
+	return 0;
+}
+
+
+int hal_stop(struct proc_dir_entry *main_dir_entry)
+{
+	/* This is created in hal_start */
+	remove_proc_entry("hal_stats", main_dir_entry);
+
+	/* Disable host_int and uccp_irq */
+	hal_disable_int(NULL);
+	return 0;
+}
+
+
+static int chg_irq_register(int val)
+{
+	pr_debug("%s: change irq regist state %s.\n",
+		 hal_name, ((val == 1) ? "ON" : "OFF"));
+
+	if (val == 0) {
+		/* Unregister irq handler */
+		free_irq(hpriv->irq, hpriv);
+
+	} else if (val == 1) {
+		/* Register irq handler */
+		if (request_irq(hpriv->irq,
+				hal_irq_handler,
+				0,
+				"wlan",
+				hpriv) != 0) {
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static inline int conv_str_to_byte(unsigned char *byte,
+		     unsigned char *str,
+		     int len)
+{
+	int  i, j = 0;
+	unsigned char ch, val = 0;
+
+	for (i = 0; i < (len * 2); i++) {
+		/*convert to lower*/
+		ch = ((str[i] >= 'A' && str[i] <= 'Z') ? str[i] + 32 : str[i]);
+
+		if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f'))
+			return -1;
+
+		if (ch >= '0' && ch <= '9')  /*check is digit*/
+			ch = ch - '0';
+		else
+			ch = ch - 'a' + 10;
+
+		val += ch;
+
+		if (!(i%2))
+			val <<= 4;
+		else {
+			byte[j] = val;
+			j++;
+			val = 0;
+		}
+	}
+
+	return 0;
+}
+
+/* Unmap and release all resoruces*/
+static int cleanup_all_resources(void)
+{
+	/* Unmap UCCP core memory */
+	iounmap((void __iomem *)hpriv->uccp_base_addr);
+	release_mem_region(hpriv->uccp_core_base, hpriv->uccp_core_len);
+
+	/* Unmap UCCP slave memory */
+	iounmap((void __iomem *)hpriv->uccp_slave_base_addr);
+	release_mem_region(hpriv->uccp_slave_base, hpriv->uccp_slave_len);
+
+	/* Unmap GRAM */
+	iounmap((void __iomem *)hpriv->gram_base_addr);
+	release_mem_region(hpriv->uccp_pkd_gram_base,
+			   hpriv->uccp_pkd_gram_len);
+
+	/* Unmap UCCP Host RAM */
+	if (hpriv->base_addr_uccp_host_ram) {
+		kfree (hpriv->base_addr_uccp_host_ram);
+		hpriv->base_addr_uccp_host_ram = NULL;
+	}
+
+	kfree(hpriv);
+	return 0;
+}
+
+static int uccp420_pltfr_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	int irq;
+	struct device_node *np = pdev->dev.of_node;
+	struct property *pp = NULL;
+	struct iio_channel *channels;
+	int ret;
+	int size;
+
+	channels = iio_channel_get_all(&pdev->dev);
+	if (IS_ERR(channels))
+		return PTR_ERR(channels);
+
+	hpriv = kzalloc(sizeof(struct hal_priv), GFP_KERNEL);
+	if (!hpriv)
+		return -ENOMEM;
+
+	irq = platform_get_irq_byname(pdev, "uccpirq");
+
+	hpriv->irq = irq;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+					   "uccp_core_base");
+	if (res == NULL)
+		return pr_err("No dts entry : uccp_core_base");
+
+	hpriv->uccp_core_base = res->start;
+	hpriv->uccp_core_len = res->end - res->start + 1;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+					   "uccp_slave_base");
+	if (res == NULL)
+		return pr_err("No dts entry : uccp_slave_base");
+
+	hpriv->uccp_slave_base = res->start;
+	hpriv->uccp_slave_len = res->end - res->start + 1;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+					   "uccp_pkd_gram_base");
+
+	if (res == NULL)
+		return pr_err("No dts entry : uccp_pkd_gram_base");
+
+	hpriv->uccp_pkd_gram_base = res->start;
+	hpriv->uccp_pkd_gram_len = res->end - res->start + 1;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+					   "uccp_gram_base");
+
+	if (res) {
+		hpriv->uccp_gram_base = res->start;
+		hpriv->uccp_gram_len = res->end - res->start + 1;
+	}
+
+	pp = of_find_property(np, "mac-address0", NULL);
+
+	if (pp && (pp->length == ETH_ALEN) && pp->value)
+		memcpy(&vif_macs[0], (void *)pp->value, ETH_ALEN);
+	else if (mac_addr == NULL)
+		mac_addr = DEFAULT_MAC_ADDRESS;
+
+	pp = of_find_property(np, "mac-address1", NULL);
+
+	if (pp && (pp->length == ETH_ALEN) && pp->value)
+		memcpy(&vif_macs[1], (void *)pp->value, ETH_ALEN);
+
+	if (mac_addr != NULL) {
+
+		conv_str_to_byte(vif_macs[0], mac_addr, ETH_ALEN);
+
+		memcpy(&vif_macs[1], &vif_macs[0], ETH_ALEN);
+		vif_macs[1][5]++;
+	}
+
+	pp = of_find_property(np, "rf-params", &size);
+
+	if (pp && pp->value) {
+		memcpy(rf_params, pp->value, size);
+		rf_params_vpd = rf_params;
+	}
+
+	pp = of_find_property(np, "num_streams", &size);
+
+	if (pp && pp->value)
+		num_streams_vpd = *((int *)pp->value);
+
+	clk_set_rate(devm_clk_get(&pdev->dev, "wifi_pll"), 320000000);
+	clk_set_rate(devm_clk_get(&pdev->dev, "rpu_core_div"), 320000000);
+
+	clk_prepare_enable(devm_clk_get(&pdev->dev, "rpu_core"));
+	clk_prepare_enable(devm_clk_get(&pdev->dev, "rpu_l"));
+	clk_prepare_enable(devm_clk_get(&pdev->dev, "rpu_v"));
+	clk_prepare_enable(devm_clk_get(&pdev->dev, "rpu_sleep"));
+	clk_prepare_enable(devm_clk_get(&pdev->dev, "wifi_adc"));
+	clk_prepare_enable(devm_clk_get(&pdev->dev, "wifi_dac"));
+
+	clk_prepare_enable(devm_clk_get(&pdev->dev, "event_timer"));
+	clk_prepare_enable(devm_clk_get(&pdev->dev, "sys_event_timer"));
+	clk_prepare_enable(devm_clk_get(&pdev->dev, "aux_adc"));
+	clk_prepare_enable(devm_clk_get(&pdev->dev, "aux_adc_internal"));
+
+
+	ret = hal_ops.init(&pdev->dev);
+
+	if (!ret)
+		pr_debug("uccp420 wlan driver registration completed");
+
+	return ret;
+}
+
+
+static const struct of_device_id uccp420_dt_ids[] = {
+	{ .compatible = "img,pistachio-uccp"},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, uccp420_dt_ids);
+
+struct platform_driver img_uccp_driver = {
+	.probe = uccp420_pltfr_probe,
+	.driver = {
+		.name     = "uccp420",
+		.owner    = THIS_MODULE,
+		.of_match_table = of_match_ptr(uccp420_dt_ids),
+	},
+};
+
+
+
+
+static int hal_deinit(void *dev)
+{
+	struct sk_buff *skb;
+
+	(void)(dev);
+
+	_uccp420wlan_80211if_exit();
+	platform_driver_unregister(&img_uccp_driver);
+
+	/* Free irq line */
+	chg_irq_register(0);
+
+	/* Kill the HAL tasklet */
+	tasklet_kill(&hpriv->tx_tasklet);
+	tasklet_kill(&hpriv->rx_tasklet);
+
+	while ((skb = skb_dequeue(&hpriv->rxq)))
+		dev_kfree_skb_any(skb);
+
+	while ((skb = skb_dequeue(&hpriv->refillq)))
+		dev_kfree_skb_any(skb);
+
+	while ((skb = skb_dequeue(&hpriv->txq)))
+		dev_kfree_skb_any(skb);
+
+	cleanup_all_resources();
+
+	return 0;
+}
+
+
+static int hal_init(void *dev)
+{
+	(void) (dev);
+
+	hpriv->shm_offset =  shm_offset;
+
+	if (hpriv->shm_offset != HAL_SHARED_MEM_OFFSET)
+		pr_debug("%s: Using shared memory offset 0x%lx\n",
+			 hal_name, hpriv->shm_offset);
+
+	/* Map UCCP core memory */
+	if (!(request_mem_region(hpriv->uccp_core_base,
+				 hpriv->uccp_core_len,
+				 "uccp"))) {
+		pr_err("%s: request_mem_region failed for UCCP core region\n",
+		       hal_name);
+
+		kfree(hpriv);
+		return -ENOMEM;
+	}
+
+	hpriv->uccp_base_addr =
+	(unsigned long)devm_ioremap(dev, hpriv->uccp_core_base,
+				    hpriv->uccp_core_len);
+
+	if (hpriv->uccp_base_addr == 0) {
+		pr_err("%s: Ioremap failed for UCCP core mem region\n",
+			hal_name);
+
+		release_mem_region(hpriv->uccp_core_base,
+				   hpriv->uccp_core_len);
+		kfree(hpriv);
+
+		return -ENOMEM;
+	}
+
+	hpriv->uccp_mem_addr = hpriv->uccp_base_addr + HAL_UCCP_CORE_REG_OFFSET;
+
+	/* Map UCCP slave memory */
+	if (!(request_mem_region(hpriv->uccp_slave_base,
+				 hpriv->uccp_slave_len,
+				 "uccp"))) {
+		pr_err("%s: request_mem_region failed for UCCP slave region\n",
+		       hal_name);
+
+		kfree(hpriv);
+		return -ENOMEM;
+	}
+
+	hpriv->uccp_slave_base_addr =
+	(unsigned long) devm_ioremap(dev, hpriv->uccp_slave_base,
+				     hpriv->uccp_slave_len);
+
+	if (hpriv->uccp_slave_base_addr == 0) {
+		pr_err("%s: Ioremap failed for UCCP slave mem region\n",
+			hal_name);
+
+		iounmap((void __iomem *)hpriv->uccp_base_addr);
+		release_mem_region(hpriv->uccp_core_base,
+				   hpriv->uccp_core_len);
+		release_mem_region(hpriv->uccp_slave_base,
+				   hpriv->uccp_slave_len);
+		kfree(hpriv);
+
+		return -ENOMEM;
+	}
+
+	/* Map GRAM */
+	if (!request_mem_region(hpriv->uccp_pkd_gram_base,
+				hpriv->uccp_pkd_gram_len,
+				"wlan_gram")) {
+		pr_err("%s: request_mem_region failed for GRAM\n",
+		       hal_name);
+
+		iounmap((void __iomem *)hpriv->uccp_base_addr);
+		release_mem_region(hpriv->uccp_core_base,
+				   hpriv->uccp_core_len);
+
+		kfree(hpriv);
+
+		return -ENOMEM;
+	}
+
+	hpriv->gram_base_addr =
+		(unsigned long)devm_ioremap(dev, hpriv->uccp_pkd_gram_base,
+				       hpriv->uccp_pkd_gram_len);
+	if (hpriv->gram_base_addr == 0) {
+		pr_err("%s: Ioremap failed for g ram region.\n",
+		       hal_name);
+
+		iounmap((void __iomem *)hpriv->uccp_base_addr);
+		release_mem_region(hpriv->uccp_core_base,
+				   hpriv->uccp_core_len);
+		release_mem_region(hpriv->uccp_pkd_gram_base,
+				   hpriv->uccp_pkd_gram_len);
+
+		kfree(hpriv);
+
+		return -ENOMEM;
+	}
+
+	hpriv->gram_mem_addr = hpriv->gram_base_addr + hpriv->shm_offset;
+
+	hpriv->base_addr_uccp_host_ram = kmalloc(HAL_HOST_UCCP_RAM_LEN,
+						 GFP_KERNEL);
+
+	if (!hpriv->base_addr_uccp_host_ram) {
+		pr_err("%s: Alloc for UCCP DMA area failed\n",
+		       __func__);
+
+		iounmap((void __iomem *)hpriv->uccp_base_addr);
+		release_mem_region(hpriv->uccp_core_base,
+				   hpriv->uccp_core_len);
+
+		iounmap((void __iomem *)hpriv->gram_base_addr);
+		release_mem_region(hpriv->uccp_pkd_gram_base,
+				   hpriv->uccp_pkd_gram_len);
+
+		kfree(hpriv);
+
+		return -ENOMEM;
+	}
+
+	pr_debug("%s: kmalloc success: %p an phy: 0x%x\n",
+		 __func__,
+		 hpriv->base_addr_uccp_host_ram,
+		 (unsigned int)virt_to_phys(hpriv->base_addr_uccp_host_ram));
+
+	{
+	unsigned int value = 0;
+	unsigned char *rpusocwrap;
+
+	rpusocwrap = (unsigned char *)(hpriv->uccp_base_addr + 0x38000);
+
+	value = virt_to_phys(hpriv->base_addr_uccp_host_ram) / (4 * 1024);
+	uccp_ddr_base = value * (4 * 1024);
+	value = value << 10;
+	writel(value, rpusocwrap + 0x218);
+	}
+
+	if (hpriv->uccp_gram_base) {
+
+		/* gram_b4_addr */
+		if (!(request_mem_region(hpriv->uccp_gram_base,
+				 hpriv->uccp_gram_len,
+				 "uccp_gram_base"))) {
+			pr_err("%s:uccp_gram_base: request_mem_region failed\n",
+			       hal_name);
+
+			kfree(hpriv);
+			return -ENOMEM;
+		}
+
+		hpriv->gram_b4_addr =
+			(unsigned long)devm_ioremap(dev, hpriv->uccp_gram_base,
+					       hpriv->uccp_gram_len);
+
+		if (hpriv->gram_b4_addr == 0) {
+			pr_err("%s: Ioremap failed for UCCP mem region\n",
+				hal_name);
+
+			release_mem_region(hpriv->uccp_gram_base,
+					   hpriv->uccp_gram_len);
+			kfree(hpriv);
+
+			return -ENOMEM;
+		}
+	}
+
+	/* Register irq handler */
+	if (chg_irq_register(1)) {
+		pr_err("%s: Unable to register Interrupt handler with kernel\n",
+		       hal_name);
+
+		cleanup_all_resources();
+		return -ENOMEM;
+	}
+
+	/*Allocate space do update data pointers to DCP*/
+	hpriv->hal_tx_data = kzalloc((NUM_TX_DESC * NUM_FRAMES_IN_TX_DESC *
+				      sizeof(struct hal_tx_data)), GFP_KERNEL);
+
+	if (!hpriv->hal_tx_data)
+		return -ENOMEM;
+
+	/* Intialize HAL tasklets */
+	tasklet_init(&hpriv->tx_tasklet, tx_tasklet_fn, (unsigned long)hpriv);
+	tasklet_init(&hpriv->rx_tasklet, rx_tasklet_fn, (unsigned long)hpriv);
+	skb_queue_head_init(&hpriv->rxq);
+	skb_queue_head_init(&hpriv->txq);
+	skb_queue_head_init(&hpriv->refillq);
+#ifdef PERF_PROFILING
+	spin_lock_init(&timing_lock);
+#endif
+
+	if (_uccp420wlan_80211if_init() < 0) {
+		pr_err("%s: wlan_init failed\n", hal_name);
+		hal_deinit(NULL);
+		return -ENOMEM;
+	}
+
+	hpriv->cmd_cnt = COMMAND_START_MAGIC;
+	hpriv->event_cnt = 0;
+	return 0;
+
+}
+
+
+static void hal_deinit_bufs(void)
+{
+	int i = 0, j = 0;
+	struct buf_info *info = NULL;
+
+	tasklet_disable(&hpriv->rx_tasklet);
+
+	if (hpriv->rx_buf_info) {
+		for (i = 0; i < hpriv->rx_bufs_2k + hpriv->rx_bufs_12k; i++) {
+			info = &hpriv->rx_buf_info[i];
+
+			if (info->dma_buf) {
+				dma_unmap_single(NULL,
+						 info->dma_buf,
+						 info->dma_buf_len,
+						 DMA_FROM_DEVICE);
+
+				info->dma_buf = 0;
+				info->dma_buf_len = 0;
+			}
+
+			if (hpriv->rx_buf_info[i].skb) {
+				kfree_skb(hpriv->rx_buf_info[i].skb);
+				hpriv->rx_buf_info[i].skb = NULL;
+			}
+		}
+
+		kfree(hpriv->rx_buf_info);
+		hpriv->rx_buf_info = NULL;
+	}
+
+	if (hpriv->tx_buf_info) {
+		for (i = 0; i < hpriv->tx_bufs; i++) {
+			for (j = 0; i < NUM_FRAMES_IN_TX_DESC; i++) {
+				info = &hpriv->tx_buf_info[i + j];
+
+				if (info->dma_buf) {
+					dma_unmap_single(NULL,
+							 info->dma_buf,
+							 info->dma_buf_len,
+							 DMA_TO_DEVICE);
+
+					info->dma_buf = 0;
+					info->dma_buf_len = 0;
+				}
+			}
+		}
+
+		kfree(hpriv->tx_buf_info);
+		hpriv->tx_buf_info = NULL;
+	}
+
+	hpriv->hal_disabled = 1;
+	tasklet_enable(&hpriv->rx_tasklet);
+
+	return;
+}
+
+
+static int hal_init_bufs(unsigned int tx_bufs,
+			 unsigned int rx_bufs_2k,
+			 unsigned int rx_bufs_12k,
+			 unsigned int tx_max_data_size)
+{
+	struct cmd_hal cmd_rx;
+	struct sk_buff *nbuf = NULL;
+	unsigned int count = 0, cmd_count = 0, pkt_desc = 0;
+	unsigned int rx_max_data_size;
+	dma_addr_t dma_buf = 0;
+	unsigned int cmd_buf_count = ((rx_bufs_2k + rx_bufs_12k) /
+				      MAX_RX_BUF_PTR_PER_CMD);
+	int result = -1;
+
+	hpriv->tx_bufs = tx_bufs;
+	hpriv->rx_bufs_2k = rx_bufs_2k;
+	hpriv->rx_bufs_12k = rx_bufs_12k;
+	hpriv->max_data_size = tx_max_data_size;
+	hpriv->tx_base_addr_uccp_host_ram = hpriv->base_addr_uccp_host_ram;
+	hpriv->rx_base_addr_uccp_host_ram = hpriv->base_addr_uccp_host_ram +
+		(tx_bufs * NUM_FRAMES_IN_TX_DESC * tx_max_data_size);
+
+	if (((tx_bufs * NUM_FRAMES_IN_TX_DESC * tx_max_data_size) +
+	     ((rx_bufs_2k * MAX_DATA_SIZE_2K + rx_bufs_12k *
+	       MAX_DATA_SIZE_12K))) > HAL_HOST_UCCP_RAM_LEN) {
+		pr_err("%s Cannot accomodate tx_bufs: %d, frames/desc: %d and rx_bufs_2k: %d rx_bufs_12k: %d in %d UCCP Host RAM\n",
+		       hal_name, tx_bufs, NUM_FRAMES_IN_TX_DESC,
+		       rx_bufs_2k, rx_bufs_12k, HAL_HOST_UCCP_RAM_LEN);
+
+		goto err;
+	}
+
+	hpriv->rx_buf_info = kzalloc(((rx_bufs_2k + rx_bufs_12k) *
+				      sizeof(struct buf_info)), GFP_KERNEL);
+
+	if (!hpriv->rx_buf_info) {
+		pr_err("%s out of memory\n", hal_name);
+		goto err;
+	}
+
+	hpriv->tx_buf_info = kzalloc((tx_bufs * NUM_FRAMES_IN_TX_DESC *
+				      sizeof(struct buf_info)),
+				     GFP_KERNEL);
+
+	if (!hpriv->tx_buf_info) {
+		pr_err("%s out of memory\n", hal_name);
+		goto err;
+	}
+
+	memset(hpriv->tx_buf_info, 0, (tx_bufs * NUM_FRAMES_IN_TX_DESC *
+				       sizeof(struct buf_info)));
+
+	rx_max_data_size = MAX_DATA_SIZE_2K;
+
+	for (cmd_count = 0; cmd_count < cmd_buf_count; cmd_count++) {
+		memset(&cmd_rx, 0, sizeof(struct cmd_hal));
+
+		pr_debug("%s: Loop :%d: rx_max_data_size: %d\n",
+			 hal_name, cmd_count, rx_max_data_size);
+
+		for (count = 0; count < MAX_RX_BUF_PTR_PER_CMD; count++,
+		     pkt_desc++) {
+			if (pkt_desc >= hpriv->rx_bufs_2k)
+				rx_max_data_size = MAX_DATA_SIZE_12K;
+
+			result = init_rx_buf(pkt_desc,
+					     rx_max_data_size,
+					     &dma_buf,
+					     NULL);
+
+			if (result) {
+				pr_err("%s Failed to initialize RX buf %d\n",
+				       hal_name, pkt_desc);
+				goto err;
+			}
+
+			cmd_rx.rx_pkt_data.rx_pkt_cnt++;
+			cmd_rx.rx_pkt_data.rx_pkt[count].desc = pkt_desc;
+			cmd_rx.rx_pkt_data.rx_pkt[count].ptr = dma_buf -
+							       uccp_ddr_base;
+		}
+
+		cmd_rx.hdr.id = 0xFFFFFFFF;
+
+		nbuf = alloc_skb(sizeof(struct cmd_hal), GFP_ATOMIC);
+
+		if (!nbuf) {
+			pr_err("%s out of memory\n", hal_name);
+			goto err;
+		}
+
+		memcpy(skb_put(nbuf, sizeof(struct cmd_hal)),
+		       (unsigned char *)&cmd_rx, sizeof(struct cmd_hal));
+		hal_cmd_sent--;
+		hostport_send(hpriv, nbuf);
+	}
+
+	return 0;
+err:
+	if (nbuf) {
+		kfree_skb(nbuf);
+		nbuf = NULL;
+	}
+
+	hal_deinit_bufs();
+
+	return -1;
+}
+
+
+int hal_map_tx_buf(int pkt_desc, int frame_id, unsigned char *data, int len)
+{
+	unsigned int index = (pkt_desc * NUM_FRAMES_IN_TX_DESC) + frame_id;
+	void __iomem  *tx_address = NULL;
+	int i, j;
+
+	dma_addr_t dma_buf = 0;
+
+	/* Sanity check */
+	dma_buf = ((struct buf_info)(hpriv->tx_buf_info[index])).dma_buf;
+
+	if (dma_buf) {
+		pr_err("%s: Already mapped pkt descriptor: %d and frame: %d dma_buf: 0x%x dma_buf: 0x%x index: %d\n",
+		       __func__,
+		       pkt_desc,
+		       frame_id,
+		       (unsigned int)hpriv->tx_buf_info[index].dma_buf,
+		       (unsigned int)dma_buf,
+		       index);
+
+		for (i = 0; i < NUM_TX_DESC; i++) {
+			for (j = 0; j < NUM_FRAMES_IN_TX_DESC; j++) {
+				pr_debug("%s: TX: descriptor: %d and frame: %d dma_buf: 0x%x\n",
+					 __func__, i, j,
+					 hpriv->tx_buf_info[i + j].dma_buf);
+			}
+		}
+		for (i = 0; i < 80; i++) {
+			pr_debug("%s: RX: descriptor: %d dma_buf: 0x%x\n",
+				 __func__, i , hpriv->rx_buf_info[i].dma_buf);
+		}
+
+		return -1;
+	}
+
+	if (!is_mem_dma(data, len)) {
+		/* Copy SKB to the UCCP Private Area */
+		tx_address = hpriv->tx_base_addr_uccp_host_ram +
+			     (index * hpriv->max_data_size);
+
+		memcpy(tx_address, data, len);
+	} else
+		tx_address = data;
+
+	dma_buf = dma_map_single(NULL,
+				 tx_address,
+				 len,
+				 DMA_TO_DEVICE);
+
+	if (unlikely(dma_mapping_error(NULL,
+				       dma_buf))) {
+		pr_err("%s Unable to map DMA on TX\n", hal_name);
+		return -1;
+	}
+
+	hpriv->tx_buf_info[index].dma_buf = dma_buf;
+
+	hpriv->tx_buf_info[index].dma_buf_len = len;
+
+	return 0;
+}
+
+
+int hal_unmap_tx_buf(int pkt_desc, int frame_id)
+{
+	unsigned int index = (pkt_desc * NUM_FRAMES_IN_TX_DESC) + frame_id;
+
+	/* Sanity check */
+	if (!hpriv->tx_buf_info[index].dma_buf) {
+		pr_err("%s called for unmapped pkt desc: %d , frame: %d\n",
+		       __func__, pkt_desc, frame_id);
+		return -1;
+	}
+
+	dma_unmap_single(NULL,
+			 hpriv->tx_buf_info[index].dma_buf,
+			 hpriv->tx_buf_info[index].dma_buf_len,
+			 DMA_TO_DEVICE);
+
+	memset(&hpriv->tx_buf_info[index], 0, sizeof(struct buf_info));
+
+	return 0;
+}
+
+
+static int is_mem_dma(void *virt_addr, int len)
+{
+	phys_addr_t phy_addr = 0;
+
+	phy_addr = virt_to_phys(virt_addr);
+
+	if (phy_addr >= uccp_ddr_base &&
+	    (phy_addr + len) < (uccp_ddr_base +
+				HAL_HOST_ZONE_DMA_LEN))
+		return 1;
+
+	return 0;
+}
+
+
+static int is_mem_bounce(void *virt_addr, int len)
+{
+	phys_addr_t phy_addr_start = 0;
+	phys_addr_t phy_addr = 0;
+
+	phy_addr = virt_to_phys(virt_addr);
+	phy_addr_start = virt_to_phys(hpriv->base_addr_uccp_host_ram);
+
+	if (phy_addr >= phy_addr_start &&
+	   (phy_addr + len) < (phy_addr_start +
+			       HAL_HOST_UCCP_RAM_LEN))
+		return 1;
+
+	pr_warn("%s: Warning:Address is out of Bounce memory region\n",
+		hal_name);
+
+	return 0;
+}
+
+
+static int init_rx_buf(int pkt_desc,
+		       unsigned int max_data_size,
+		       dma_addr_t *dma_buf,
+		       struct sk_buff *new_skb)
+{
+	struct sk_buff *rx_skb = NULL;
+	void __iomem *src_ptr = NULL;
+
+	memset(&hpriv->rx_buf_info[pkt_desc], 0, sizeof(struct buf_info));
+
+	if (new_skb == NULL) {
+
+		rx_skb = alloc_skb(max_data_size, GFP_ATOMIC);
+
+		if (!rx_skb) {
+			alloc_skb_failures++;
+			return -1;
+		}
+	} else
+		rx_skb = new_skb;
+
+	if ((is_mem_dma(rx_skb->data, max_data_size))) {
+		src_ptr = rx_skb->data;
+		alloc_skb_dma_region++;
+	} else {
+		if (pkt_desc < hpriv->rx_bufs_2k) {
+			src_ptr = hpriv->rx_base_addr_uccp_host_ram +
+				  (pkt_desc * MAX_DATA_SIZE_2K);
+		} else {
+			src_ptr = hpriv->rx_base_addr_uccp_host_ram +
+				  (hpriv->rx_bufs_2k * MAX_DATA_SIZE_2K) +
+				  ((pkt_desc - hpriv->rx_bufs_2k) *
+				   MAX_DATA_SIZE_12K);
+		}
+
+		if (!is_mem_bounce(src_ptr, max_data_size)) {
+			if (rx_skb)
+				dev_kfree_skb_any(rx_skb);
+			return -1;
+		}
+
+		hpriv->rx_buf_info[pkt_desc].dma_buf_priv = 1;
+		alloc_skb_priv_region++;
+	}
+
+	*dma_buf = dma_map_single(NULL,
+				  src_ptr,
+				  max_data_size,
+				  DMA_FROM_DEVICE);
+
+	if (unlikely(dma_mapping_error(NULL,
+				       *dma_buf))) {
+		pr_err("%s Unable to map DMA on RX\n", hal_name);
+
+		if (rx_skb)
+			dev_kfree_skb_any(rx_skb);
+
+		return -1;
+	}
+
+	hpriv->rx_buf_info[pkt_desc].skb = rx_skb;
+	hpriv->rx_buf_info[pkt_desc].src_ptr = src_ptr;
+	hpriv->rx_buf_info[pkt_desc].dma_buf = *dma_buf;
+	hpriv->rx_buf_info[pkt_desc].dma_buf_len = max_data_size;
+
+	return 0;
+}
+void hal_set_mem_region(unsigned int addr)
+{
+	return;
+}
+void hal_request_mem_regions(unsigned char **gram_addr,
+			     unsigned char **slave_addr,
+			     unsigned char **gram_b4_addr)
+{
+	*gram_addr = (unsigned char *)hpriv->gram_base_addr;
+	*slave_addr = (unsigned char *)hpriv->uccp_slave_base_addr;
+	*gram_b4_addr = (unsigned char *)hpriv->gram_b4_addr;
+}
+
+
+struct hal_ops_tag hal_ops = {
+	.init = hal_init,
+	.deinit	= hal_deinit,
+	.start = hal_start,
+	.stop = hal_stop,
+	.register_callback = hal_register_callback,
+	.send = hal_send,
+	.init_bufs = hal_init_bufs,
+	.deinit_bufs = hal_deinit_bufs,
+	.map_tx_buf = hal_map_tx_buf,
+	.unmap_tx_buf = hal_unmap_tx_buf,
+	.reset_hal_params	= hal_reset_hal_params,
+	.set_mem_region	= hal_set_mem_region,
+	.request_mem_regions	= hal_request_mem_regions,
+};
+
+
+static int __init hostport_init(void)
+{
+	return platform_driver_register(&img_uccp_driver);
+}
+
+static void __exit hostport_exit(void)
+{
+	hal_ops.deinit(NULL);
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Imagination Technologies");
+MODULE_DESCRIPTION("Driver for IMG UCCP420 WiFi solution");
+
+module_init(hostport_init);
+module_exit(hostport_exit);
diff --git a/drivers/net/wireless/uccp420wlan/src/hal_hostport.h b/drivers/net/wireless/uccp420wlan/src/hal_hostport.h
new file mode 100644
index 0000000..46adc88
--- /dev/null
+++ b/drivers/net/wireless/uccp420wlan/src/hal_hostport.h
@@ -0,0 +1,255 @@
+/*
+ * File Name  : hal_hostport.h
+ *
+ * This file contains the definitions specific to HOSPORT comms
+ *
+ * Copyright (c) 2011, 2012, 2013, 2014 Imagination Technologies Ltd.
+ * All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#ifndef _UCCP420WLAN_HAL_HOSTPORT_H_
+#define _UCCP420WLAN_HAL_HOSTPORT_H_
+
+#include <linux/skbuff.h>
+#include <linux/interrupt.h>
+
+#include <hal.h>
+
+#define _PACKED_  __attribute__((__packed__))
+
+#define MAX_RX_BUF_PTR_PER_CMD (16)
+#define MAX_DATA_SIZE_12K (12 * 1024)
+#define MAX_DATA_SIZE_8K (8 * 1024)
+#define MAX_DATA_SIZE_2K (2 * 1024)
+
+#define NUM_TX_DESC 12
+#define NUM_FRAMES_IN_TX_DESC 32
+#define NUM_BYTES_PER_FRAME 9
+#define TX_DESC_HAL_SIZE (NUM_FRAMES_IN_TX_DESC * NUM_BYTES_PER_FRAME)
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif /* __cplusplus */
+
+struct buf_info {
+	dma_addr_t dma_buf;
+	void __iomem *src_ptr;
+	unsigned int dma_buf_len;
+	unsigned int dma_buf_priv;   /* Is the DMA buffer in our private area */
+	struct sk_buff *skb;
+} _PACKED_;
+
+struct hal_tx_data {
+	unsigned int data_len:24;
+	unsigned long address:24;
+	unsigned long offset:24;
+} _PACKED_;
+
+struct hal_priv {
+	/* UCCP Host RAM mappings*/
+	void __iomem *base_addr_uccp_host_ram;
+	void __iomem *tx_base_addr_uccp_host_ram;
+	void __iomem *rx_base_addr_uccp_host_ram;
+
+	/* UCCP and GRAM mappings */
+	unsigned long uccp_mem_addr;
+	unsigned long gram_mem_addr;
+	unsigned long uccp_base_addr;
+	unsigned long uccp_slave_base_addr;
+	unsigned long gram_base_addr;
+	unsigned long shm_offset;
+	unsigned long hal_disabled;
+	unsigned long gram_b4_addr;
+
+	/* DTS entries */
+	unsigned long uccp_core_base;		/* HAL_HOST_UCCP_BASE */
+	unsigned long uccp_core_len;		/* HAL_HOST_UCCP_LEN */
+	unsigned long uccp_slave_base;		/* HAL_HOST_SLAVE_PORT_BASE */
+	unsigned long uccp_slave_len;		/* HAL_HOST_SLAVE_PORT_LEN */
+	unsigned long uccp_pkd_gram_base;	/* HAL_HOST_GRAM_BASE */
+	unsigned long uccp_pkd_gram_len;	/* HAL_GRAM_LEN */
+	unsigned long uccp_gram_base;		/* b4addr */
+	unsigned long uccp_gram_len;		/* b4addr length */
+
+	/* TX */
+	struct sk_buff_head txq;
+	struct tasklet_struct tx_tasklet;
+	unsigned short cmd_cnt;
+	struct buf_info *tx_buf_info;
+	struct hal_tx_data *hal_tx_data;
+
+	/* RX */
+	struct sk_buff_head rxq;
+	struct tasklet_struct rx_tasklet;
+	unsigned short event_cnt;
+	msg_handler rcv_handler;
+	struct buf_info *rx_buf_info;
+
+	/* Buffers info from IF layer*/
+	unsigned int tx_bufs;
+	unsigned int rx_bufs_2k;
+	unsigned int rx_bufs_12k;
+	unsigned int max_data_size;
+
+	/* Temp storage to refill first and process next*/
+	struct sk_buff_head refillq;
+	int irq;
+};
+
+struct hal_hdr {
+	/*! 0xffffffff - hal command or hal event
+	 *  0x0 - lmac command or lmac event
+	 */
+	unsigned int id;
+	/*! Data pointer of commands with payload
+	 *  this field is valid only if descriptor id
+	 *  of command header is set to some value
+	 *  other.
+	 */
+	unsigned int data_ptr;
+} _PACKED_;
+
+struct hal_rx_pkt_info {
+	/* Rx descriptor */
+	unsigned int desc;
+	unsigned int ptr;
+} _PACKED_;
+
+struct hal_rx_command {
+	unsigned int rx_pkt_cnt;
+	struct hal_rx_pkt_info rx_pkt[MAX_RX_BUF_PTR_PER_CMD];
+} _PACKED_;
+
+struct cmd_hal {
+	struct hal_hdr hdr;
+	struct hal_rx_command rx_pkt_data;
+} _PACKED_;
+
+struct event_hal {
+	struct hal_hdr hdr;
+	unsigned int rx_pkt_cnt;
+	unsigned int rx_pkt_desc[16];
+} _PACKED_;
+
+
+int _uccp420wlan_80211if_init(void);
+void _uccp420wlan_80211if_exit(void);
+
+/*Porting information:
+ *
+ * HAL_HOST_UCCP_BASE: This is physical address as in the host memory map
+ *		       corresponding to the UCCP register region starting
+ *		       from  0x02000000
+ * HAL_HOST_GRAM_BASE: This is physical address as in the host memory map
+ *                     corresponding to the UCCP GRAM region starting from
+ *                     0xB7000000
+ * HAL_UCCP_IRQ_LINE: This is the interrupt number assigned to UCCP host port
+ *                    interrupt.
+ * HAL_HOST_UCCP_RAM_START: This is the physical address of the start of
+ *                          Host RAM which is reserved for UCCP
+ * HAL_HOST_ZONE_DMA_START: This is the physical address of the start of 64MB
+ *                          ZONE_DMA area which is currently assigned a dummy
+ *                          value of 0xABABABAB. TSB needs to provide the actual
+ *                          value for this.
+ *
+ * These are the only values which need to be modified as per host memory
+ * map and interrupt configuration.
+ * The values for HAL_SHARED_MEM_OFFSET, HAL_WLAN_GRAM_LEN,  HAL_COMMAND_OFFSET,
+ * and  HAL_EVENT_OFFSET can be changed by IMG in future software releases.
+ */
+
+#define HAL_HOST_UCCP_BASE 0x18480000
+#define HAL_HOST_GRAM_BASE 0x1A000000
+#define HAL_HOST_UCCP_LEN 0x0003E800
+#define HAL_GRAM_LEN 0x00066CC0
+#define HAL_UCCP_GRAM_BASE 0xB7000000
+
+#define HAL_UCCP_CORE_REG_OFFSET		0x400
+#define HAL_UCCP_SLAVE_PORT_OFFSET              0x3C000
+
+
+/* Register HOST_TO_UCCP_CORE_CMD */
+#define HOST_TO_UCCP_CORE_CMD 0x0030
+#define HOST_TO_UCCP_CORE_CMD_ADDR ((hpriv->uccp_mem_addr) + \
+				    HOST_TO_UCCP_CORE_CMD)
+#define UCCP_CORE_HOST_INT_SHIFT 31
+
+/* Register UCCP_CORE_TO_HOST_CMD */
+#define UCCP_CORE_TO_HOST_CMD 0x0034
+#define UCCP_CORE_TO_HOST_CMD_ADDR ((hpriv->uccp_mem_addr) + \
+				    UCCP_CORE_TO_HOST_CMD)
+
+/* Register HOST_TO_UCCP_CORE_ACK */
+#define HOST_TO_UCCP_CORE_ACK 0x0038
+#define HOST_TO_UCCP_CORE_ACK_ADDR ((hpriv->uccp_mem_addr) + \
+				    HOST_TO_UCCP_CORE_ACK)
+#define UCCP_CORE_INT_CLR_SHIFT 31
+
+/* Register UCCP_CORE_TO_HOST_ACK */
+#define UCCP_CORE_TO_HOST_ACK 0x003C
+#define UCCP_CORE_TO_HOST_ACK_ADDR ((hpriv->uccp_mem_addr) + \
+				    UCCP_CORE_TO_HOST_ACK)
+
+/* Register UCCP_CORE_INT_ENABLE */
+#define UCCP_CORE_INT_ENABLE 0x0044
+#define UCCP_CORE_INT_ENABLE_ADDR ((hpriv->uccp_mem_addr) + \
+				   UCCP_CORE_INT_ENABLE)
+#define UCCP_CORE_INT_EN_SHIFT 31
+
+#define UCCP_CORE_INT_ENAB 0x0000
+#define UCCP_CORE_INT_ENAB_ADDR ((hpriv->uccp_mem_addr) + UCCP_CORE_INT_ENAB)
+#define UCCP_CORE_INT_IRQ_ENAB_SHIFT 15
+
+/******************************************************************************/
+#define HAL_SHARED_MEM_OFFSET 0x45ffc
+#define HAL_SHARED_MEM_MAX_MSG_SIZE 60
+#define HAL_WLAN_GRAM_LEN 0x1eac0
+
+/* Command, Event, Tx Data and Buff mappping offsets */
+#define HAL_COMMAND_OFFSET (0)
+#define HAL_EVENT_OFFSET (HAL_COMMAND_OFFSET + HAL_SHARED_MEM_MAX_MSG_SIZE)
+#define HAL_TX_DATA_OFFSET (HAL_EVENT_OFFSET   + HAL_SHARED_MEM_MAX_MSG_SIZE)
+
+#define HAL_GRAM_CMD_START ((hpriv->gram_mem_addr) + HAL_COMMAND_OFFSET)
+#define HAL_GRAM_EVENT_START ((hpriv->gram_mem_addr) + HAL_EVENT_OFFSET)
+#define HAL_GRAM_TX_DATA_START ((hpriv->gram_mem_addr) + HAL_TX_DATA_OFFSET)
+
+#define HAL_GRAM_CMD_LEN (HAL_GRAM_CMD_START + 8)
+#define HAL_GRAM_TX_DATA_LEN (HAL_GRAM_TX_DATA_START + 0)
+#define HAL_GRAM_TX_DATA_OFFSET	(HAL_GRAM_TX_DATA_START + 3)
+#define HAL_GRAM_TX_DATA_ADDR (HAL_GRAM_TX_DATA_START + 6)
+
+#define HAL_HOST_UCCP_RAM_LEN (4 * 1024 * 1024)
+
+#define HAL_HOST_ZONE_DMA_START 0xABABABAB
+#define HAL_HOST_ZONE_DMA_LEN (64 * 1024 * 1024)
+
+/* Interrupt number assigned to UCCP host port interrupt */
+#define HAL_IRQ_LINE 74
+
+
+int reset_hal_params(void);
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+#endif /* _UCCP420WLAN_HAL_HOSTPORT_H_ */
+
+/* EOF */
diff --git a/drivers/net/wireless/uccp420wlan/src/tx.c b/drivers/net/wireless/uccp420wlan/src/tx.c
new file mode 100644
index 0000000..c3bab6e
--- /dev/null
+++ b/drivers/net/wireless/uccp420wlan/src/tx.c
@@ -0,0 +1,931 @@
+/*
+ * File Name  : tx.c
+ *
+ * This file contains the source functions UMAC TX logic
+ *
+ * Copyright (c) 2011, 2012, 2013, 2014 Imagination Technologies Ltd.
+ * All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#include "core.h"
+
+#define TX_TO_MACDEV(x) ((struct mac80211_dev *) \
+			 (container_of(x, struct mac80211_dev, tx)))
+
+static void wait_for_tx_complete(struct tx_config *tx)
+{
+	int count = 0;
+	struct mac80211_dev *dev = NULL;
+
+	/* Find_last_bit: Returns the bit number of the first set bit,
+	 * or size.
+	 */
+	while (find_last_bit(tx->buf_pool_bmp,
+			     NUM_TX_DESCS) != NUM_TX_DESCS) {
+		count++;
+
+		if (count < TX_COMPLETE_TIMEOUT_TICKS) {
+			current->state = TASK_INTERRUPTIBLE;
+			schedule_timeout(1);
+		} else {
+			dev = TX_TO_MACDEV(tx);
+
+			DEBUG_LOG("%s-UMACTX:WARNING: TX complete failed!!\n",
+				dev->name);
+			DEBUG_LOG("%s-UMACTX:After %ld: bitmap is: 0x%lx\n",
+			       dev->name,
+			       TX_COMPLETE_TIMEOUT_TICKS,
+			       tx->buf_pool_bmp[0]);
+			break;
+		}
+	}
+
+	if (count && (count < TX_COMPLETE_TIMEOUT_TICKS)) {
+		DEBUG_LOG("%s-UMACTX:TX complete after %d timer ticks\n",
+			dev->name, count);
+	}
+}
+
+
+static inline int tx_queue_map(int queue)
+{
+	unsigned int ac[4] = {WLAN_AC_VO, WLAN_AC_VI, WLAN_AC_BE, WLAN_AC_BK};
+
+	if (queue < 4)
+		return ac[queue];
+
+	return WLAN_AC_VO;
+}
+
+
+static inline int tx_queue_unmap(int queue)
+{
+	unsigned int ac[4] = {3, 2, 1, 0};
+
+	return ac[queue];
+}
+
+static void update_aux_adc_voltage(struct mac80211_dev *dev,
+				   unsigned char pdout)
+{
+	static unsigned int index;
+
+	if (index > MAX_AUX_ADC_SAMPLES)
+		index = 0;
+
+	dev->params->pdout_voltage[index++] = pdout;
+}
+
+static void tx_status(struct sk_buff *skb,
+		      struct umac_event_tx_done *tx_done,
+		      unsigned int frame_idx,
+		      struct mac80211_dev *dev,
+		      struct ieee80211_tx_info tx_info_1st_mpdu)
+{
+	int index, i;
+	char idx = 0;
+	struct ieee80211_tx_rate *txrate;
+	struct ieee80211_tx_rate *tx_inf_rate = NULL;
+	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
+	int tx_fixed_mcs_idx = 0;
+	int tx_fixed_rate = 0;
+	struct ieee80211_supported_band *band = NULL;
+
+	/* Rate info will be retained, except the count*/
+	ieee80211_tx_info_clear_status(tx_info);
+
+	if (tx_done->frm_status[frame_idx] == TX_DONE_STAT_SUCCESS)
+		tx_info->flags |= IEEE80211_TX_STAT_ACK;
+	else if (tx_info->flags & IEEE80211_TX_CTL_AMPDU)
+		tx_info->flags |= IEEE80211_TX_STAT_AMPDU_NO_BACK;
+
+	tx_info->flags &= ~IEEE80211_TX_STAT_AMPDU;
+	tx_info->flags &= ~IEEE80211_TX_CTL_AMPDU;
+
+	band = dev->hw->wiphy->bands[tx_info->band];
+
+	for (index = 0; index < 4; index++) {
+		tx_inf_rate = &tx_info->status.rates[index];
+
+		/* Populate tx_info based on 1st MPDU in an AMPDU */
+		txrate = (&tx_info_1st_mpdu.control.rates[index]);
+
+		if (txrate->idx < 0)
+			break;
+
+		if ((dev->params->production_test == 1) &&
+		    ((dev->params->tx_fixed_mcs_indx != -1) ||
+		     (dev->params->tx_fixed_rate != -1))) {
+			tx_fixed_mcs_idx = dev->params->tx_fixed_mcs_indx;
+			tx_fixed_rate = dev->params->tx_fixed_rate;
+
+			/* This index is always zero */
+			/* TODO: See if we need to send channel bw information
+			 * taken from proc, since in Production mode the bw
+			 * advised by Minstrel can be overwritten by proc
+			 * settings
+			 */
+			tx_inf_rate->flags = txrate->flags;
+
+			if (tx_fixed_mcs_idx != -1) {
+				if (tx_fixed_mcs_idx <= 7) {
+					tx_inf_rate->flags |=
+						IEEE80211_TX_RC_MCS;
+					/* So that actual sent rate is seen in
+					 * sniffer
+					 */
+					idx = tx_done->rate[frame_idx] & 0x7F;
+					tx_inf_rate->idx = idx;
+				} else if (tx_fixed_mcs_idx <= 9) {
+					tx_inf_rate->flags |=
+						IEEE80211_TX_RC_VHT_MCS;
+					/* So that actual sent rate is seen
+					 * in sniffer
+					 */
+					idx = ((dev->params->num_spatial_streams
+					       << 4) & 0xF0);
+					idx |= (tx_done->rate[frame_idx] &
+						0x0F);
+					tx_inf_rate->idx = idx;
+				}
+			} else if (tx_fixed_rate != -1) {
+				for (i = 0; i < band->n_bitrates; i++) {
+					if ((band->bitrates[i]).hw_value ==
+					    tx_done->rate[frame_idx])
+						tx_inf_rate->idx = i;
+				}
+			}
+
+			tx_inf_rate->count = (tx_done->retries_num[frame_idx] +
+					      1);
+			break;
+		}
+
+		if ((tx_done->rate[frame_idx] &
+		     MARK_RATE_AS_MCS_INDEX) == 0x80) {
+			if ((txrate->flags & IEEE80211_TX_RC_VHT_MCS) &&
+			    ((tx_done->rate[frame_idx] & 0x0F) ==
+			     (txrate->idx & 0x0F))) {
+				tx_inf_rate->count =
+					(tx_done->retries_num[frame_idx] + 1);
+			} else if ((txrate->flags & IEEE80211_TX_RC_MCS) &&
+				   ((tx_done->rate[frame_idx] & 0x7F) ==
+				    (txrate->idx & 0x7F))) {
+				tx_inf_rate->count =
+					(tx_done->retries_num[frame_idx] + 1);
+			}
+
+			break;
+		} else if (tx_done->rate[frame_idx] ==
+			   (band->bitrates[tx_inf_rate->idx]).hw_value) {
+			tx_inf_rate->count =
+				(tx_done->retries_num[frame_idx] + 1);
+
+			break;
+		}
+	}
+
+	/* Invalidate the remaining indices */
+	while (((index + 1) < 4)) {
+		tx_info->status.rates[index + 1].idx = -1;
+		tx_info->status.rates[index + 1].count = 0;
+		index++;
+	}
+
+	if ((tx_info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) &&
+	    (atomic_dec_return(&dev->roc_params.roc_mgmt_tx_count) == 0)) {
+		if (dev->roc_params.roc_in_progress) {
+			/* Reuse the delayed workqueue with 1ms delay */
+			ieee80211_queue_delayed_work(dev->hw,
+						     &dev->roc_complete_work,
+						     msecs_to_jiffies(1));
+		}
+	}
+	dev->stats->tx_dones_to_stack++;
+	ieee80211_tx_status(dev->hw, skb);
+}
+
+
+static int get_token(struct tx_config *tx,
+		     int queue)
+{
+	int cnt = 0, spare_tid = NUM_TX_DESCS;
+
+	for (cnt = 0; cnt < NUM_TX_DESCS_PER_AC; cnt++) {
+		if (!test_and_set_bit((queue + (NUM_ACS * cnt)),
+							&tx->buf_pool_bmp[0])) {
+
+			spare_tid = queue + (NUM_ACS * cnt);
+			break;
+		}
+	}
+	if (spare_tid == NUM_TX_DESCS) {
+		for (cnt = NUM_TX_DESCS_PER_AC * NUM_ACS;
+					cnt < NUM_TX_DESCS; cnt++) {
+			/* Do not set, we will queue to the same token */
+			if (!test_and_set_bit((cnt%TX_DESC_BUCKET_BOUND),
+					      &tx->buf_pool_bmp[
+					      (cnt/TX_DESC_BUCKET_BOUND)])) {
+				spare_tid = cnt;
+				break;
+			}
+		}
+	}
+
+	if (spare_tid != NUM_TX_DESCS)
+		tx->outstanding_tokens[queue]++;
+
+	return spare_tid;
+}
+
+
+int uccp420wlan_tx_alloc_buff_req(struct mac80211_dev *dev,
+				  int queue,
+				  unsigned int *id,
+				  struct sk_buff *skb)
+{
+	int spare = 0;
+	struct tx_config *tx = &dev->tx;
+	unsigned long flags, ampdu_len = 0;
+	struct sk_buff *loop_skb;
+	struct sk_buff *tmp, *skb_first = NULL;
+	struct ieee80211_hdr *mac_hdr_first, *mac_hdr;
+	struct ieee80211_tx_info *tx_info_first, *tx_info;
+	unsigned int max_tx_cmds = dev->params->max_tx_cmds;
+	struct umac_vif *uvif;
+	struct ieee80211_vif *ivif;
+	unsigned char *data = NULL;
+
+	spin_lock_irqsave(&tx->lock, flags);
+
+	DEBUG_LOG("%s-UMACTX:Alloc buf Req q = %d,\n", dev->name, queue);
+
+	*id = NUM_TX_DESCS;
+
+	if ((tx->outstanding_tokens[queue] < NUM_TX_DESCS_PER_AC)
+	     || (queue == WLAN_AC_BCN)) {
+		/* Reserved Full and Outstanding < 2*/
+		spare = get_token(tx, queue);
+
+		if (spare != NUM_TX_DESCS) {
+			DEBUG_LOG("%s-UMACTX:Reserved Token, Sending single\n",
+				dev->name);
+			skb_queue_tail(&dev->tx.tx_pkt[spare], skb);
+		}
+
+		*id = spare;
+
+		goto out;
+	}
+
+	skb_queue_tail(&tx->pending_pkt[queue], skb);
+
+	if (skb_queue_len(&tx->pending_pkt[queue]) < max_tx_cmds) {
+		*id = NUM_TX_DESCS;
+		goto out;
+	}
+
+	/* Check Spare Token */
+	spare = get_token(tx, queue);
+
+	if (spare != NUM_TX_DESCS) {
+		skb_first = skb_peek(&tx->pending_pkt[queue]);
+
+		mac_hdr_first = (struct ieee80211_hdr *)skb_first->data;
+
+		tx_info_first = IEEE80211_SKB_CB(skb_first);
+
+		/* Temp Checks for Aggregation: Will be removed later*/
+		if ((tx_info_first->control.rates[0].flags &
+		     IEEE80211_TX_RC_VHT_MCS) && max_tx_cmds > 24)
+			max_tx_cmds = 24;
+		else if ((tx_info_first->control.rates[0].flags &
+			  IEEE80211_TX_RC_MCS) && max_tx_cmds > 16)
+			max_tx_cmds = 16;
+
+		/* Aggregate Only MPDU's with same RA, same Rate,
+		 * same Rate flags, same Tx Info flags
+		 */
+		skb_queue_walk_safe(&tx->pending_pkt[queue],
+				    loop_skb,
+				    tmp) {
+			data = loop_skb->data;
+			mac_hdr = (struct ieee80211_hdr *)data;
+
+			tx_info = IEEE80211_SKB_CB(loop_skb);
+
+			ivif = tx_info->control.vif;
+			uvif = (struct umac_vif *)(ivif->drv_priv);
+
+			ampdu_len += loop_skb->len;
+
+			if (!ieee80211_is_data(mac_hdr->frame_control) ||
+			    !(tx_info->flags & IEEE80211_TX_CTL_AMPDU) ||
+			    (skb_queue_len(&dev->tx.tx_pkt[spare]) >=
+			     max_tx_cmds) ||
+#if 0
+			    (memcmp(&tx_info_first->control.rates[0],
+				    &tx_info->control.rates[0],
+				    sizeof(struct ieee80211_tx_rate) *
+				    IEEE80211_TX_MAX_RATES) != 0) ||
+			    (tx_info_first->flags != tx_info->flags) ||
+#endif
+			    (memcmp(mac_hdr->addr1,
+				    mac_hdr_first->addr1,
+				    ETH_ALEN) == 0))
+				break;
+
+			__skb_unlink(loop_skb, &tx->pending_pkt[queue]);
+
+			skb_queue_tail(&dev->tx.tx_pkt[spare], loop_skb);
+		}
+
+		/* If our criterion rejects all pending frames, send only 1 */
+		if (!skb_queue_len(&dev->tx.tx_pkt[spare]))
+			skb_queue_tail(&dev->tx.tx_pkt[spare],
+				       skb_dequeue(&tx->pending_pkt[queue]));
+
+		DEBUG_LOG("%s-UMACTX:Max_pkt_thresh: send spare: %d with %d\n",
+		       dev->name,
+		       spare,
+		       skb_queue_len(&dev->tx.tx_pkt[spare]));
+
+		/* We can send only list here, but when the count
+		 * reaches 32 again we send another
+		 */
+	}
+
+	/* No spare token, so make sure queue is not overflowing */
+	if ((queue != WLAN_AC_BCN) &&
+	    (skb_queue_len(&tx->pending_pkt[queue]) >= MAX_TX_QUEUE_LEN)) {
+		ieee80211_stop_queue(dev->hw,
+				     skb->queue_mapping);
+		tx->queue_stopped_bmp |= (1 << queue);
+	}
+
+	*id = spare;
+
+out:
+	DEBUG_LOG("%s-UMACTX:Alloc buf Result *id = %d\n", dev->name, *id);
+
+	spin_unlock_irqrestore(&tx->lock, flags);
+
+	/* If token is available, just return tokenid, list will be sent*/
+	return *id;
+}
+
+
+int uccp420wlan_tx_free_buff_req(struct mac80211_dev *dev,
+				 struct umac_event_tx_done *tx_done,
+				 unsigned char *queue,
+				 int *vif_index_bitmap)
+{
+	int i;
+	unsigned long flags, ampdu_len;
+	unsigned int pkts_pend = 0;
+	struct tx_config *tx = &dev->tx;
+	struct ieee80211_hdr *mac_hdr_first, *mac_hdr;
+	struct ieee80211_tx_info *tx_info_first, *tx_info, *tx_info_bcn;
+	struct ieee80211_tx_info tx_info_1st_mpdu;
+	struct sk_buff *skb, *tmp, *skb_first = NULL;
+	struct sk_buff_head *skb_list, tx_done_list;
+	int vif_index;
+	unsigned int pkt = 0, cnt = 0;
+	unsigned int descriptor_id = tx_done->descriptor_id;
+	unsigned int max_tx_cmds = dev->params->max_tx_cmds;
+	struct umac_vif *uvif;
+	struct ieee80211_vif *ivif;
+	unsigned long bcn_int = 0;
+
+	skb_queue_head_init(&tx_done_list);
+
+	DEBUG_LOG("%s-UMACTX:Free buf Req q = %d, desc_id: %d\n",
+	       dev->name,
+	       tx_done->queue,
+	       descriptor_id);
+
+	spin_lock_irqsave(&tx->lock, flags);
+	tx->outstanding_tokens[tx_done->queue]--;
+
+	for (i = 0; i < NUM_ACS; i++) {
+		if (skb_peek(&tx->pending_pkt[i]))
+			break;
+	}
+
+	if (i == NUM_ACS) {
+		/* No pending packets */
+		__clear_bit((descriptor_id % TX_DESC_BUCKET_BOUND),
+			    &tx->buf_pool_bmp[(descriptor_id /
+					       TX_DESC_BUCKET_BOUND)]);
+	} else if (descriptor_id < (NUM_TX_DESCS_PER_AC * NUM_ACS)) {
+		/* Reserved token */
+		*queue = tx_done->queue;
+		if (*queue != WLAN_AC_BCN) {
+			pkts_pend = skb_queue_len(&tx->pending_pkt[*queue]);
+
+			if (!pkts_pend)
+				__clear_bit(descriptor_id,
+					    &tx->buf_pool_bmp[0]);
+		} else {
+			__clear_bit(descriptor_id, &tx->buf_pool_bmp[0]);
+		}
+	} else if (descriptor_id >= (NUM_TX_DESCS_PER_AC * NUM_ACS)) {
+		/* Spare token */
+		for (cnt = WLAN_AC_VO; cnt >= 0; cnt--) {
+			pkts_pend = skb_queue_len(&tx->pending_pkt[cnt]);
+
+			if (pkts_pend) {
+				*queue = cnt;
+				break;
+			}
+		}
+
+		/* If beacon queue has pending and
+		 * no other AC has pending
+		 */
+		if (!pkts_pend) {
+			__clear_bit((descriptor_id %
+				     TX_DESC_BUCKET_BOUND),
+				    &tx->buf_pool_bmp[(descriptor_id /
+						       TX_DESC_BUCKET_BOUND)]);
+			}
+	}
+
+	DEBUG_LOG("%s-UMACTX:%spending_q = %d, desc_id: %d pending:%d\n",
+	       dev->name,
+	       __func__,
+	       *queue,
+	       descriptor_id,
+	       pkts_pend);
+
+	/* Defer Tx Done Processsing */
+	skb_list = &dev->tx.tx_pkt[descriptor_id];
+
+	if (skb_queue_len(skb_list)) {
+		/* Cut the list to new one, tx_pkt will be re-initialized */
+		skb_queue_splice_tail_init(skb_list, &tx_done_list);
+	} else {
+		DEBUG_LOG("%s-UMACTX:Got Empty List: list_addr: %p\n",
+			dev->name, skb_list);
+	}
+
+	if (pkts_pend > 0) {
+		skb_first = skb_peek(&tx->pending_pkt[*queue]);
+		mac_hdr_first = (struct ieee80211_hdr *)skb_first->data;
+		tx_info_first = IEEE80211_SKB_CB(skb_first);
+
+		/* Temp Checks for Aggregation: Will be removed later */
+		if ((tx_info_first->control.rates[0].flags &
+		     IEEE80211_TX_RC_VHT_MCS) && max_tx_cmds > 24)
+			max_tx_cmds = 24;
+		else if ((tx_info_first->control.rates[0].flags &
+			  IEEE80211_TX_RC_MCS) && max_tx_cmds > 16)
+			max_tx_cmds = 16;
+
+		skb_queue_walk_safe(&tx->pending_pkt[*queue], skb, tmp) {
+			mac_hdr = (struct ieee80211_hdr *)skb->data;
+			tx_info =
+			     (struct ieee80211_tx_info *)IEEE80211_SKB_CB(skb);
+
+			ivif = tx_info->control.vif;
+			uvif = (struct umac_vif *)(ivif->drv_priv);
+			ampdu_len += skb->len;
+
+			/* Aggregate Only AMPDU's with same RA, same Rate,
+			 * same Rate Falgs, same Tx info flags
+			 */
+			if (!ieee80211_is_data(mac_hdr->frame_control) ||
+			    !(tx_info->flags & IEEE80211_TX_CTL_AMPDU) ||
+			    skb_queue_len(skb_list) >= max_tx_cmds ||
+#if 0
+			    (memcmp(&tx_info_first->control.rates[0],
+				    &tx_info->control.rates[0],
+				    sizeof(struct ieee80211_tx_rate) *
+				    IEEE80211_TX_MAX_RATES) != 0) ||
+			    tx_info_first->flags != tx_info->flags ||
+#endif
+			    (memcmp(mac_hdr->addr1,
+				    mac_hdr_first->addr1,
+				    ETH_ALEN) != 0))
+					break;
+
+			/*Always queue the first skb*/
+			__skb_unlink(skb, &tx->pending_pkt[*queue]);
+			skb_queue_tail(skb_list, skb);
+		}
+
+		/* If our criterion rejects all pending frames, send only 1 */
+		if (!skb_queue_len(skb_list)) {
+			skb_queue_tail(skb_list,
+				       skb_dequeue(&tx->pending_pkt[*queue]));
+		}
+
+		tx->outstanding_tokens[*queue]++;
+
+		DEBUG_LOG("%s-UMACTX:Pending packets: %d, Total: %d\n",
+		       dev->name,
+		       pkts_pend,
+		       skb_queue_len(skb_list));
+	} else {
+		DEBUG_LOG("%s-UMACTX:No Pending Packets\n", dev->name);
+	}
+
+	if ((*queue != WLAN_AC_BCN) &&
+	    (tx->queue_stopped_bmp & (1 << *queue)) &&
+	    skb_queue_len(&tx->pending_pkt[*queue]) < (MAX_TX_QUEUE_LEN / 2)) {
+		ieee80211_wake_queue(dev->hw, tx_queue_unmap(*queue));
+		tx->queue_stopped_bmp &= ~(1 << (*queue));
+	}
+	/*Unmap here before release lock to avoid race*/
+	if (skb_queue_len(&tx_done_list)) {
+		skb_queue_walk_safe(&tx_done_list, skb, tmp) {
+			hal_ops.unmap_tx_buf(tx_done->descriptor_id, pkt);
+			DEBUG_LOG("%s-UMACTX:TXDONE: ID=%d, Stat=%d (%d, %d)\n",
+				dev->name,
+				tx_done->descriptor_id,
+				tx_done->frm_status[pkt],
+				tx_done->rate[pkt],
+				tx_done->retries_num[pkt]);
+			pkt++;
+		}
+	}
+	/*Unlock: Give a chance for Tx to add to pending lists*/
+	spin_unlock_irqrestore(&tx->lock, flags);
+
+	/* Protection from mac80211 _ops especially stop */
+	if (dev->state != STARTED)
+		return 0;
+
+	if (!skb_queue_len(&tx_done_list))
+		goto out;
+
+	skb_first = skb_peek(&tx_done_list);
+
+	memcpy(&tx_info_1st_mpdu,
+	       (struct ieee80211_tx_info *)IEEE80211_SKB_CB(skb_first),
+	       sizeof(struct ieee80211_tx_info));
+	pkt = 0;
+	skb_queue_walk_safe(&tx_done_list, skb, tmp) {
+		__skb_unlink(skb, &tx_done_list);
+
+		if (!skb)
+			continue;
+		/* In the Tx path we move the .11hdr from skb to CMD_TX
+		 * Hence pushing it here, not required for loopback case
+		 */
+		skb_push(skb,
+			 dev->tx.tx_pkt_hdr_len[tx_done->descriptor_id]);
+		mac_hdr = (struct ieee80211_hdr *)(skb->data);
+
+		if (!ieee80211_is_beacon(mac_hdr->frame_control)) {
+			vif_index = vif_addr_to_index(mac_hdr->addr2,
+						      dev);
+			if (vif_index > -1)
+				*vif_index_bitmap |= (1 << vif_index);
+
+			/* Same Rate info for all packets */
+			tx_status(skb,
+				  tx_done,
+				  pkt,
+				  dev,
+				  tx_info_1st_mpdu);
+		} else {
+
+			if (tx_done->frm_status[pkt] ==
+			    TX_DONE_STAT_DISCARD_BCN) {
+				/*We did not send beacon*/
+				dev->tx_last_beacon = 0;
+			} else if (tx_done->frm_status[pkt] ==
+				   TX_DONE_STAT_SUCCESS) {
+				/*We did send beacon*/
+				dev->tx_last_beacon = 1;
+			}
+
+			tx_info_bcn = IEEE80211_SKB_CB(skb);
+			ivif = tx_info_bcn->control.vif;
+			uvif = (struct umac_vif *)(ivif->drv_priv);
+			bcn_int = uvif->vif->bss_conf.beacon_int - 10;
+			bcn_int = msecs_to_jiffies(bcn_int);
+
+			/* Beacon Time Stamp */
+			if (tx_done->frm_status[pkt] == TX_DONE_STAT_SUCCESS) {
+				unsigned int ts2;
+				int bts_vif = uvif->vif_index;
+				spin_lock(&tsf_lock);
+				dev->params->sync[bts_vif].status = 1;
+				memcpy(dev->params->sync[bts_vif].bssid,
+					ivif->bss_conf.bssid, ETH_ALEN);
+				memcpy(dev->params->sync[bts_vif].ts1,
+					tx_done->reserved, 8);
+				memcpy(&dev->params->sync[bts_vif].ts2,
+					(tx_done->reserved + 8), 4);
+				ts2 = dev->params->sync[bts_vif].ts2;
+				dev->params->sync[bts_vif].atu = 0;
+				if (frc_to_atu)
+					frc_to_atu(ts2,
+					&dev->params->sync[bts_vif].atu, 0);
+				spin_unlock(&tsf_lock);
+			}
+
+			for (i = 0; i < MAX_VIFS; i++) {
+				if (dev->active_vifs & (1 << i)) {
+					if (dev->vifs[i] == ivif)
+						mod_timer(&uvif->bcn_timer,
+							  jiffies +
+							  bcn_int);
+				}
+			}
+
+			dev_kfree_skb_any(skb);
+		}
+
+		pkt++;
+	}
+out:
+	return min(pkts_pend, max_tx_cmds);
+}
+
+
+#ifdef PERF_PROFILING
+static void print_persec_stats(unsigned long data)
+{
+	struct mac80211_dev *dev = (struct mac80211_dev *)data;
+	struct tx_config *tx = &dev->tx;
+
+	if (dev->stats->tx_cmds_from_stack != 0) {
+		pr_info("%s: %d The persec stats from stack: %d outstanding_tokens: [%d = %d = %d = %d = %d]\n",
+			__func__,
+			__LINE__,
+			dev->stats->tx_cmds_from_stack,
+			tx->outstanding_tokens[0],
+			tx->outstanding_tokens[1],
+			tx->outstanding_tokens[2],
+			tx->outstanding_tokens[3],
+			tx->outstanding_tokens[4]);
+
+		dev->stats->tx_cmds_from_stack = 0;
+	}
+
+	mod_timer(&tx->persec_timer, jiffies + msecs_to_jiffies(1000));
+}
+#endif
+
+
+void uccp420wlan_tx_init(struct mac80211_dev *dev)
+{
+	int cnt = 0;
+	struct tx_config *tx = &dev->tx;
+
+	memset(&tx->buf_pool_bmp,
+	       0,
+	       sizeof(long) * ((NUM_TX_DESCS/TX_DESC_BUCKET_BOUND) + 1));
+
+	tx->queue_stopped_bmp = 0;
+	tx->next_spare_token_ac = WLAN_AC_BE;
+
+	for (cnt = 0; cnt < NUM_ACS; cnt++) {
+		skb_queue_head_init(&tx->pending_pkt[cnt]);
+		tx->outstanding_tokens[cnt] = 0;
+	}
+
+	for (cnt = 0; cnt < NUM_TX_DESCS; cnt++)
+		skb_queue_head_init(&tx->tx_pkt[cnt]);
+
+#ifdef PERF_PROFILING
+	init_timer(&tx->persec_timer);
+	tx->persec_timer.data = (unsigned long)dev;
+	tx->persec_timer.function = print_persec_stats;
+	mod_timer(&tx->persec_timer, jiffies + msecs_to_jiffies(1000));
+#endif
+	spin_lock_init(&tx->lock);
+	ieee80211_wake_queues(dev->hw);
+
+	DEBUG_LOG("%s-UMACTX:Initialization successful\n", dev->name);
+}
+
+
+void uccp420wlan_tx_deinit(struct mac80211_dev *dev)
+{
+	int cnt = 0;
+	unsigned long flags = 0;
+	struct tx_config *tx = &dev->tx;
+	struct sk_buff *skb;
+	ieee80211_stop_queues(dev->hw);
+
+	wait_for_tx_complete(tx);
+
+	spin_lock_irqsave(&tx->lock, flags);
+
+	for (cnt = 0; cnt < NUM_TX_DESCS; cnt++) {
+		while ((skb = skb_dequeue(&tx->tx_pkt[cnt])) != NULL)
+			dev_kfree_skb_any(skb);
+	}
+
+	for (cnt = 0; cnt < NUM_ACS; cnt++) {
+		while ((skb = skb_dequeue(&tx->pending_pkt[cnt])) != NULL)
+			dev_kfree_skb_any(skb);
+	}
+
+	spin_unlock_irqrestore(&tx->lock, flags);
+
+	DEBUG_LOG("%s-UMACTX:Deinitialization successful\n", dev->name);
+}
+
+
+int __uccp420wlan_tx_frame(struct ieee80211_sta *sta,
+			   unsigned int queue,
+			   unsigned int buff_pool_id,
+			   unsigned int more_frames,
+			   struct mac80211_dev *dev)
+{
+	return uccp420wlan_prog_tx(queue, more_frames, buff_pool_id);
+}
+
+
+int uccp420wlan_tx_frame(struct sk_buff *skb,
+			 struct ieee80211_sta *sta,
+			 struct mac80211_dev *dev,
+			 bool bcast)
+{
+	unsigned int queue, descriptor_id, pkt, more_frames;
+	int ret = 0;
+	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
+
+	if (bcast == false) {
+		queue = tx_queue_map(skb->queue_mapping);
+		more_frames = 0;
+	} else {
+		queue = WLAN_AC_BCN;
+		/* Hack: skb->priority is used to indicate more frames */
+		more_frames = skb->priority;
+	}
+
+	dev->stats->tx_cmds_from_stack++;
+
+	if (dev->params->production_test == 1)
+		tx_info->flags |= IEEE80211_TX_CTL_AMPDU;
+
+	if (tx_info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) {
+		/*These are high priority frames, send them in VO*/
+		queue = WLAN_AC_VO;
+		atomic_inc(&dev->roc_params.roc_mgmt_tx_count);
+	}
+
+	DEBUG_LOG("%s-UMACTX:%s:%d Waiting for Allocation:queue: %d qmap: %d\n",
+		dev->name,
+		__func__, __LINE__, queue, skb->queue_mapping);
+
+	uccp420wlan_tx_alloc_buff_req(dev, queue, &descriptor_id, skb);
+
+	if (descriptor_id == NUM_TX_DESCS) {
+		DEBUG_LOG("%s-UMACTX:%s:%d Token Busy Queued:\n",
+			dev->name, __func__, __LINE__);
+		return NETDEV_TX_OK;
+	}
+	ret = __uccp420wlan_tx_frame(sta, queue, descriptor_id, more_frames,
+				     dev);
+	if (ret < 0) {
+		struct umac_event_tx_done tx_done;
+
+		pr_err("%s-UMACTX: Unable to send frame, dropping ..%d\n",
+		       dev->name, ret);
+
+		tx_done.descriptor_id = descriptor_id;
+		tx_done.queue = queue;
+
+		for (pkt = 0; pkt <
+		     skb_queue_len(&dev->tx.tx_pkt[descriptor_id]); pkt++) {
+			tx_done.frm_status[pkt] =
+				TX_DONE_STAT_ERR_RETRY_LIM;
+			tx_done.rate[pkt] = 0;
+		}
+
+		uccp420wlan_tx_complete(&tx_done, dev);
+	}
+
+	return NETDEV_TX_OK;
+}
+
+
+void uccp420wlan_proc_tx_complete(struct umac_event_tx_done *tx_done,
+			     void *context)
+{
+
+	struct mac80211_dev *dev = (struct mac80211_dev *)context;
+	struct sk_buff *skb, *tmp;
+	struct sk_buff_head *tx_done_list;
+	unsigned int pkt = 0;
+
+	tx_done_list = &dev->tx.proc_tx_list[tx_done->descriptor_id];
+	dev->stats->tx_done_recv_count++;
+	update_aux_adc_voltage(dev, tx_done->pdout_voltage);
+	skb_queue_walk_safe(tx_done_list, skb, tmp) {
+		__skb_unlink(skb, tx_done_list);
+		if (!skb)
+			continue;
+		hal_ops.unmap_tx_buf(tx_done->descriptor_id, pkt);
+		dev_kfree_skb_any(skb);
+		pkt++;
+	}
+
+	/*send NEXT packet list*/
+	if ((dev->params->pkt_gen_val == -1) ||
+	    (--dev->params->pkt_gen_val > 0))
+		tasklet_schedule(&dev->proc_tx_tasklet);
+}
+
+void uccp420wlan_tx_complete(struct umac_event_tx_done *tx_done,
+			     void *context)
+{
+	struct mac80211_dev *dev = (struct mac80211_dev *)context;
+	unsigned int  more_frames;
+	int vif_index = 0, vif_index_bitmap = 0, ret = 0;
+	unsigned int pkt = 0, pkts_pending = 0;
+	unsigned char queue = 0;
+	struct umac_event_noa noa_event;
+
+	/*for (i = 0; i < 32; i++)*/
+	{
+		/* increment tx_done_recv_count to keep track of number of
+		 * tx_done received do not count tx dones from host.
+		 */
+		dev->stats->tx_done_recv_count++;
+tx_complete:
+
+		DEBUG_LOG("%s-UMACTX:TX Done Rx for desc_id: %d qlen: %d\n",
+		       dev->name,
+		       tx_done->descriptor_id,
+		       skb_queue_len(&dev->tx.tx_pkt[
+				     tx_done->descriptor_id]));
+		update_aux_adc_voltage(dev, tx_done->pdout_voltage);
+		pkts_pending = uccp420wlan_tx_free_buff_req(dev,
+							    tx_done,
+							    &queue,
+							    &vif_index_bitmap);
+
+
+		if (pkts_pending) {
+			/*TODO..Do we need to check each skb for more_frames??*/
+#if 0
+			if ((queue == WLAN_AC_BCN) && (skb->priority == 1))
+				more_frames = 1;
+			else
+				more_frames = 0;
+#endif
+			more_frames = 0;
+
+			DEBUG_LOG("%s-UMACTX:%s:%d Transfer Pending Frames:\n",
+			       dev->name,
+			       __func__, __LINE__);
+
+			ret = __uccp420wlan_tx_frame(NULL,
+						     queue,
+						     tx_done->descriptor_id,
+						     more_frames, dev);
+
+			if (ret < 0) {
+				DEBUG_LOG("%s-UMACTX:TX (pending) failed %d\n",
+				       dev->name,
+				       ret);
+
+				tx_done->queue = queue;
+
+				for (pkt = 0; pkt < pkts_pending; pkt++) {
+					tx_done->frm_status[pkt] =
+						TX_DONE_STAT_ERR_RETRY_LIM;
+					tx_done->rate[pkt] = 0;
+				}
+
+				goto tx_complete;
+			}
+		} else {
+			DEBUG_LOG("%s-UMACTX:No Pending Packets\n", dev->name);
+		}
+	}
+
+	for (vif_index = 0; vif_index < MAX_VIFS; vif_index++) {
+		if (vif_index_bitmap & (1 << vif_index)) {
+			memset(&noa_event, 0, sizeof(noa_event));
+			noa_event.if_index = vif_index;
+			uccp420wlan_noa_event(FROM_TX_DONE,
+					      &noa_event,
+					      (void *)dev,
+					      NULL);
+		}
+	}
+}
diff --git a/drivers/net/wireless/uccp420wlan/src/umac_if.c b/drivers/net/wireless/uccp420wlan/src/umac_if.c
new file mode 100644
index 0000000..b02f782
--- /dev/null
+++ b/drivers/net/wireless/uccp420wlan/src/umac_if.c
@@ -0,0 +1,2121 @@
+/*
+ * File Name  : umac_if.c
+ *
+ * This file contains the defintions of helper functions for UMAC comms
+ *
+ * Copyright (c) 2011, 2012, 2013, 2014 Imagination Technologies Ltd.
+ * All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#include <linux/spinlock.h>
+#include <linux/rcupdate.h>
+#include <linux/slab.h>
+#include <linux/netdevice.h>
+
+#include "umac_if.h"
+#include "core.h"
+
+unsigned char wildcard_ssid[7] = "DIRECT-";
+
+struct cmd_send_recv_cnt cmd_info;
+
+struct lmac_if_data {
+	char *name;
+	void *context;
+};
+
+static struct lmac_if_data __rcu *lmac_if;
+
+static void update_mcs_packet_stat(int mcs_rate_num,
+				   int rate_flags,
+				   struct mac80211_dev *dev)
+{
+	if (rate_flags & ENABLE_11N_FORMAT) {
+		switch (mcs_rate_num) {
+		case 0:
+			dev->stats->ht_tx_mcs0_packet_count++;
+			break;
+		case 1:
+			dev->stats->ht_tx_mcs1_packet_count++;
+			break;
+		case 2:
+			dev->stats->ht_tx_mcs2_packet_count++;
+			break;
+		case 3:
+			dev->stats->ht_tx_mcs3_packet_count++;
+			break;
+		case 4:
+			dev->stats->ht_tx_mcs4_packet_count++;
+			break;
+		case 5:
+			dev->stats->ht_tx_mcs5_packet_count++;
+			break;
+		case 6:
+			dev->stats->ht_tx_mcs6_packet_count++;
+			break;
+		case 7:
+			dev->stats->ht_tx_mcs7_packet_count++;
+			break;
+		case 8:
+			dev->stats->ht_tx_mcs8_packet_count++;
+			break;
+		case 9:
+			dev->stats->ht_tx_mcs9_packet_count++;
+			break;
+		case 10:
+			dev->stats->ht_tx_mcs10_packet_count++;
+			break;
+		case 11:
+			dev->stats->ht_tx_mcs11_packet_count++;
+			break;
+		case 12:
+			dev->stats->ht_tx_mcs12_packet_count++;
+			break;
+		case 13:
+			dev->stats->ht_tx_mcs13_packet_count++;
+			break;
+		case 14:
+			dev->stats->ht_tx_mcs14_packet_count++;
+			break;
+		case 15:
+			dev->stats->ht_tx_mcs15_packet_count++;
+			break;
+		default:
+			break;
+		}
+	} else if (rate_flags & ENABLE_VHT_FORMAT) {
+		switch (mcs_rate_num) {
+		case 0:
+			dev->stats->vht_tx_mcs0_packet_count++;
+			break;
+		case 1:
+			dev->stats->vht_tx_mcs1_packet_count++;
+			break;
+		case 2:
+			dev->stats->vht_tx_mcs2_packet_count++;
+			break;
+		case 3:
+			dev->stats->vht_tx_mcs3_packet_count++;
+			break;
+		case 4:
+			dev->stats->vht_tx_mcs4_packet_count++;
+			break;
+		case 5:
+			dev->stats->vht_tx_mcs5_packet_count++;
+			break;
+		case 6:
+			dev->stats->vht_tx_mcs6_packet_count++;
+			break;
+		case 7:
+			dev->stats->vht_tx_mcs7_packet_count++;
+			break;
+		case 8:
+			dev->stats->vht_tx_mcs8_packet_count++;
+			break;
+		case 9:
+			dev->stats->vht_tx_mcs9_packet_count++;
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+
+static void get_rate(struct sk_buff *skb,
+		     struct cmd_tx_ctrl *txcmd,
+		     struct mac80211_dev *dev)
+{
+	struct ieee80211_rate *rate;
+	struct ieee80211_tx_info *c;
+	unsigned int index;
+	bool is_mcs = false, is_mgd = false;
+	struct ieee80211_tx_rate *txrate;
+	unsigned char mcs_rate_num = 0;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	int mcs_indx;
+	int mgd_rate;
+	int prot_type;
+
+	/* Normal Mode*/
+	rate = ieee80211_get_tx_rate(dev->hw, IEEE80211_SKB_CB(skb));
+
+	if (rate == NULL) {
+		rate = &dev->hw->wiphy->bands[
+				dev->hw->conf.chandef.chan->band]->bitrates[0];
+		txcmd->num_rates = 1;
+		txcmd->rate[0] = rate->hw_value;
+		txcmd->rate_retries[0] = 5;
+		txcmd->rate_protection_type[0] = USE_PROTECTION_NONE;
+		txcmd->rate_preamble_type[0] = DONT_USE_SHORT_PREAMBLE;
+
+		return;
+	}
+
+	c = IEEE80211_SKB_CB(skb);
+	/* Some defaults*/
+	txcmd->num_rates = 0;
+	txcmd->stbc_enabled = 0;
+
+	/* BCC (or) LDPC */
+	if (c->flags & IEEE80211_TX_CTL_LDPC)
+		txcmd->bcc_or_ldpc = 1;
+	else
+		txcmd->bcc_or_ldpc = 0;
+
+	if (ieee80211_is_data(hdr->frame_control) &&
+	    c->flags & IEEE80211_TX_CTL_AMPDU) {
+		txcmd->aggregate_mpdu = AMPDU_AGGR_ENABLED;
+	}
+
+	for (index = 0; index < 4; index++) {
+		txrate = (&c->control.rates[index]);
+		txcmd->rate_flags[index] = 0;
+
+		if (txrate->idx < 0)
+			continue;
+
+		txcmd->num_spatial_streams[index] = 1;
+
+		/* production test*/
+		if (dev->params->production_test == 1 &&
+		    dev->params->tx_fixed_mcs_indx != -1) {
+			txcmd->rate_preamble_type[index] =
+				dev->params->prod_mode_rate_preamble_type;
+			txcmd->rate_flags[index] =
+				dev->params->prod_mode_rate_flag;
+			txcmd->rate[index] = 0x80;
+			txcmd->rate[index] |=
+			    (dev->params->tx_fixed_mcs_indx);
+			txcmd->num_spatial_streams[index] =
+			    dev->params->num_spatial_streams;
+			txcmd->bcc_or_ldpc =
+			    dev->params->prod_mode_bcc_or_ldpc;
+			txcmd->stbc_enabled =
+			    dev->params->prod_mode_stbc_enabled;
+			update_mcs_packet_stat(
+			    dev->params->tx_fixed_mcs_indx,
+			    txcmd->rate_flags[index], dev);
+			txcmd->num_rates++;
+			break;
+		} else if (dev->params->production_test == 1 &&
+			   dev->params->tx_fixed_rate != -1) {
+			txcmd->rate_preamble_type[index] =
+				dev->params->prod_mode_rate_preamble_type;
+			txcmd->rate_flags[index] =
+				dev->params->prod_mode_rate_flag;
+
+			txcmd->rate[index] = 0x00;
+			if (dev->params->tx_fixed_rate == 55)
+				txcmd->rate[index] |=
+				 ((dev->params->tx_fixed_rate) /
+				  5);
+			else
+				txcmd->rate[index] |=
+				  ((dev->params->tx_fixed_rate *
+				    10) / 5);
+			txcmd->num_spatial_streams[index] = 1;
+			txcmd->bcc_or_ldpc = 0;
+			txcmd->stbc_enabled = 0;
+			txcmd->num_rates++;
+			break;
+		}
+		/* No input from production_test proc, continue and use
+		 * info from mac80211 RC
+		 */
+
+		/* It is an VHT MCS rate */
+		if (((txrate->flags & IEEE80211_TX_RC_MCS) ||
+		     (txrate->flags & IEEE80211_TX_RC_VHT_MCS)) &&
+		    txrate->flags & IEEE80211_TX_RC_VHT_MCS) {
+			/*idx field is split
+			 * into a higher 4 bits (Nss), starts
+			 * with 0 and lower 4 bits (MCS number)
+			 */
+			is_mcs = true;
+			mcs_rate_num = (txrate->idx & 0x0F);
+			txcmd->num_spatial_streams[index] =
+				((txrate->idx & 0xF0) >> 4) + 1;
+			/* STBC Enabled/Disabled: valid Nss = 1 */
+			if (txcmd->num_spatial_streams[index] == 1 &&
+			    (c->flags & IEEE80211_TX_CTL_STBC))
+				txcmd->stbc_enabled = 1;
+
+		} else if (((txrate->flags & IEEE80211_TX_RC_MCS) ||
+			    (txrate->flags & IEEE80211_TX_RC_VHT_MCS)) &&
+			   txrate->flags & IEEE80211_TX_RC_MCS) { /*HT rate */
+			is_mcs = true;
+			mcs_rate_num  = txrate->idx;
+
+			/* Update No of Spatial streams*/
+			if (mcs_rate_num < 8) {
+				txcmd->num_spatial_streams[index] = 1;
+			} else if (mcs_rate_num > 7  &&
+				 mcs_rate_num < 16) {
+				txcmd->num_spatial_streams[index] = 2;
+			} else  {
+				pr_err("UCCP420_WIFI: Invalid MCS index: %d, Supports only 2 spatial streams\n",
+			       mcs_rate_num);
+			}
+
+			/* Ensures good throughput */
+			if (mcs_rate_num > 15 &&
+			    dev->params->uccp_num_spatial_streams == 1) {
+				mcs_rate_num = 7;
+				txcmd->num_spatial_streams[index] = 1;
+			} else if (mcs_rate_num > 15 &&
+				   dev->params->uccp_num_spatial_streams == 2) {
+				mcs_rate_num = 15;
+				txcmd->num_spatial_streams[index] = 2;
+			}
+
+			/* STBC Enabled/Disabled: valid for Nss=1 */
+			if (mcs_rate_num < 8 &&
+			    (c->flags & IEEE80211_TX_CTL_STBC))
+				txcmd->stbc_enabled = 1;
+
+		} else if (((txrate->flags & IEEE80211_TX_RC_MCS) ||
+			    (txrate->flags & IEEE80211_TX_RC_VHT_MCS))) {
+			is_mcs = true;
+			WARN_ON(1);
+		}
+
+		/* Rate FORMAT*/
+		if (txrate->flags & IEEE80211_TX_RC_VHT_MCS)
+			txcmd->rate_flags[index] |= ENABLE_VHT_FORMAT;
+		else if (txrate->flags & IEEE80211_TX_RC_MCS)
+			txcmd->rate_flags[index] |= ENABLE_11N_FORMAT;
+
+		mcs_indx = dev->params->mgd_mode_tx_fixed_mcs_indx;
+		mgd_rate = dev->params->mgd_mode_tx_fixed_rate;
+
+		/* Rate Index:
+		 * From proc (only for data packets)
+		 * From RC in mac80211
+		 * Can be MCS(HT/VHT) or Rate (11abg)
+		 */
+		if (ieee80211_is_data(hdr->frame_control) && mcs_indx != -1) {
+			is_mgd = true;
+
+			txcmd->rate[index] = 0x80;
+			txcmd->rate[index] |= (mcs_indx);
+			txcmd->rate_flags[index] =
+				dev->params->prod_mode_rate_flag;
+			txcmd->num_spatial_streams[index] =
+				dev->params->num_spatial_streams;
+			txcmd->bcc_or_ldpc =
+				dev->params->prod_mode_bcc_or_ldpc;
+			txcmd->stbc_enabled =
+				dev->params->prod_mode_stbc_enabled;
+
+			update_mcs_packet_stat(mcs_indx,
+					       txcmd->rate_flags[index] ,
+					       dev);
+		} else if (ieee80211_is_data(hdr->frame_control) &&
+			   mgd_rate != -1) {
+			is_mgd = true;
+			txcmd->rate[index] = 0x80;
+			txcmd->rate[index] = 0x00;
+
+			if (mgd_rate == 55)
+				txcmd->rate[index] |= ((mgd_rate) / 5);
+			else
+				txcmd->rate[index] |= ((mgd_rate * 10) / 5);
+
+			txcmd->rate_flags[index] = 0;
+			txcmd->num_spatial_streams[index]  = 1;
+			txcmd->bcc_or_ldpc         = 0;
+			txcmd->stbc_enabled        = 0;
+		} else if (is_mcs) { /* idx is MCS */
+			/* Now mark MSB to tell LMAC that it is a MCS Index */
+			txcmd->rate[index] = 0x80;
+			txcmd->rate[index] |= mcs_rate_num;
+			update_mcs_packet_stat(mcs_rate_num,
+					      txcmd->rate_flags[index] ,
+					      dev);
+		} else if (!is_mcs) { /* idx is RATE...*/
+			rate = &dev->hw->wiphy->bands[
+				c->band]->bitrates[
+				c->control.rates[index].idx];
+			/* Now mark MSB to tell LMAC that it is a rate*/
+			txcmd->rate[index] = 0x00;
+			txcmd->rate[index] |= rate->hw_value;
+			/* using rate so 11g/11b/11a */
+			txcmd->num_spatial_streams[index] = 1;
+		}
+
+		if (txcmd->rate_flags[index] & ENABLE_VHT_FORMAT) {
+			/*Enabled for all ucast/bcast/mcast frames*/
+			txcmd->aggregate_mpdu = AMPDU_AGGR_ENABLED;
+		}
+
+		txcmd->rate_retries[index] =
+			c->control.rates[index].count;
+		if (c->control.rates[index].flags &
+		    IEEE80211_TX_RC_USE_SHORT_PREAMBLE)
+			txcmd->rate_preamble_type[index] =
+				USE_SHORT_PREAMBLE;
+		else
+			txcmd->rate_preamble_type[index] =
+				DONT_USE_SHORT_PREAMBLE;
+
+		prot_type = USE_PROTECTION_NONE;
+
+		if (dev->params->rate_protection_type == 1) {
+			/* Protection*/
+			if (c->control.rates[index].flags &
+			    IEEE80211_TX_RC_USE_CTS_PROTECT)
+				prot_type = USE_PROTECTION_CTS2SELF;
+			else if (c->control.rates[index].flags &
+				 IEEE80211_TX_RC_USE_RTS_CTS)
+				prot_type = USE_PROTECTION_RTS;
+			else
+				prot_type = USE_PROTECTION_NONE;
+
+			if (txcmd->aggregate_mpdu == AMPDU_AGGR_ENABLED)
+				prot_type = USE_PROTECTION_RTS;
+
+			if (c->control.rates[index].flags &
+			    IEEE80211_TX_RC_40_MHZ_WIDTH)
+				prot_type = USE_PROTECTION_RTS;
+
+			/*RTS threshold: Check for PSDU length
+			 * Need to add all HW added lenghts to skb,
+			 * sw added lengths are already part of skb->len
+			 * IV ==> Always SW
+			 * MIC for CCMP ==> HW (MMIC for TKIP ==> SW)
+			 * ICV ==> HW
+			 * FCS ==> HW
+			*/
+			if (ieee80211_is_data(hdr->frame_control) &&
+			    !is_multicast_ether_addr(hdr->addr1) &&
+			    ieee80211_has_protected(hdr->frame_control)) {
+				if (skb->len +
+				    c->control.hw_key->icv_len +
+				    FCS_LEN > dev->rts_threshold)
+					prot_type = USE_PROTECTION_RTS;
+			}
+
+			if (ieee80211_is_data(hdr->frame_control) &&
+			    !is_multicast_ether_addr(hdr->addr1) &&
+			    !ieee80211_has_protected(hdr->frame_control) &&
+			    (skb->len + FCS_LEN > dev->rts_threshold))
+				prot_type = USE_PROTECTION_RTS;
+
+		}
+
+		/*No 3rd party device is using this, so diable for now*/
+		if (txcmd->rate_flags[index] & ENABLE_VHT_FORMAT)
+			prot_type = USE_PROTECTION_NONE;
+
+		txcmd->rate_protection_type[index] = prot_type;
+
+
+		/* Do not set the flags for Managed Mode, they will come
+		 * from proc
+		 */
+		if (!is_mgd) {
+			if (c->control.rates[index].flags &
+					IEEE80211_TX_RC_GREEN_FIELD)
+				txcmd->rate_flags[index] |=
+						ENABLE_GREEN_FIELD;
+			if (c->control.rates[index].flags &
+					IEEE80211_TX_RC_40_MHZ_WIDTH)
+				txcmd->rate_flags[index] |=
+						ENABLE_CHNL_WIDTH_40MHZ;
+			if (c->control.rates[index].flags &
+					IEEE80211_TX_RC_80_MHZ_WIDTH)
+				txcmd->rate_flags[index] |=
+					ENABLE_CHNL_WIDTH_80MHZ;
+			if (c->control.rates[index].flags &
+					IEEE80211_TX_RC_SHORT_GI)
+				txcmd->rate_flags[index] |= ENABLE_SGI;
+		}
+
+		/*Some Sanity Checks*/
+		/* Nss-1/2 */
+		if (txcmd->num_spatial_streams[index] <= 0 ||
+				txcmd->num_spatial_streams[index] > 2)
+			txcmd->num_spatial_streams[index] = 1;
+
+		/* VHT 20MHz MCS9 is not valid*/
+		if (txrate->flags & IEEE80211_TX_RC_VHT_MCS &&
+			((txcmd->rate[index] & 0x7F) == 9) &&
+			!(txcmd->rate_flags[index] &
+			  ENABLE_CHNL_WIDTH_40MHZ) &&
+			!(txcmd->rate_flags[index] &
+			  ENABLE_CHNL_WIDTH_80MHZ))
+				/* Downgrade to VHT-MCS8-Nss-1 */
+				txcmd->rate[index] = 0x88;
+
+		txcmd->num_rates++;
+	}
+	return;
+}
+
+
+static int uccp420wlan_send_cmd(unsigned char *buf,
+				unsigned int len,
+				unsigned char id)
+{
+	struct host_mac_msg_hdr *hdr = (struct host_mac_msg_hdr *)buf;
+	struct sk_buff *nbuf;
+	struct lmac_if_data *p;
+	struct mac80211_dev *dev;
+	unsigned long irq_flags;
+
+	rcu_read_lock();
+	p = (struct lmac_if_data *)(rcu_dereference(lmac_if));
+
+	if (!p) {
+		WARN_ON(1);
+		rcu_read_unlock();
+		return -1;
+	}
+	dev = p->context;
+	nbuf = alloc_skb(len, GFP_ATOMIC);
+
+	if (!nbuf) {
+		rcu_read_unlock();
+		return -1;
+	}
+	hdr->id = id;
+	hdr->length = len;
+	DEBUG_LOG("%s-UMACIF: Sending command:%d, outstanding_cmds: %d\n",
+		     p->name, hdr->id, cmd_info.outstanding_ctrl_req);
+	hdr->descriptor_id = 0;
+	hdr->descriptor_id |= 0x0000ffff;
+	memcpy(skb_put(nbuf, len), buf, len);
+
+	dev->stats->outstanding_cmd_cnt = cmd_info.outstanding_ctrl_req;
+
+	/* Take lock to make the control commands sequential in case of SMP*/
+	spin_lock_irqsave(&cmd_info.control_path_lock, irq_flags);
+
+	if (cmd_info.outstanding_ctrl_req < MAX_OUTSTANDING_CTRL_REQ) {
+		DEBUG_LOG("Sending the CMD, got Access\n");
+		hal_ops.send((void *)nbuf, HOST_MOD_ID, UMAC_MOD_ID, 0);
+		dev->stats->gen_cmd_send_count++;
+	} else {
+		DEBUG_LOG("Sending the CMD, Waiting in Queue: %d\n",
+			     cmd_info.outstanding_ctrl_req);
+		skb_queue_tail(&cmd_info.outstanding_cmd, nbuf);
+	}
+
+	/* sent but still no proc_done / unsent due to pending requests */
+	cmd_info.outstanding_ctrl_req++;
+	spin_unlock_irqrestore(&cmd_info.control_path_lock, irq_flags);
+	rcu_read_unlock();
+
+	return 0;
+}
+
+
+int uccp420wlan_prog_reset(unsigned int reset_type, unsigned int lmac_mode)
+{
+	struct cmd_reset reset;
+	struct mac80211_dev *dev;
+	struct lmac_if_data *p;
+	unsigned int i;
+
+	rcu_read_lock();
+	p = (struct lmac_if_data *)(rcu_dereference(lmac_if));
+
+	if (!p) {
+		WARN_ON(1);
+		rcu_read_unlock();
+		return -1;
+	}
+	rcu_read_unlock();
+	dev = p->context;
+
+	memset(&reset, 0, sizeof(struct cmd_reset));
+
+	reset.type = reset_type;
+
+	if (reset_type == LMAC_ENABLE) {
+		DEBUG_LOG("ed = %d auto = %d\n", dev->params->ed_sensitivity,
+			     dev->params->auto_sensitivity);
+		reset.ed_sensitivity = dev->params->ed_sensitivity;
+		reset.auto_sensitivity = dev->params->auto_sensitivity;
+		reset.include_rxmac_hdr = 0;
+		reset.num_spatial_streams =
+			dev->params->uccp_num_spatial_streams;
+		reset.lmac_mode = lmac_mode;
+		reset.antenna_sel = dev->params->antenna_sel;
+
+		if (dev->params->production_test == 0) {
+			memcpy(reset.rf_params, dev->params->rf_params_vpd,
+			       RF_PARAMS_SIZE);
+		} else {
+			memcpy(reset.rf_params, dev->params->rf_params,
+			       RF_PARAMS_SIZE);
+		}
+
+		reset.system_rev = dev->stats->system_rev;
+		reset.bg_scan.enabled = dev->params->bg_scan_enable;
+
+		if (reset.bg_scan.enabled) {
+			for (i = 0; i < dev->params->bg_scan_num_channels;
+			     i++) {
+				reset.bg_scan.channel_list[i] =
+					dev->params->bg_scan_channel_list[i];
+				reset.bg_scan.channel_flags[i] =
+					dev->params->bg_scan_channel_flags[i];
+			}
+			reset.bg_scan.num_channels =
+				dev->params->bg_scan_num_channels;
+			reset.bg_scan.scan_intval =
+				dev->params->bg_scan_intval;
+			reset.bg_scan.channel_dur =
+				/* Channel spending time */
+				dev->params->bg_scan_chan_dur;
+
+			reset.bg_scan.serv_channel_dur =
+				/* operating channel spending time */
+				dev->params->bg_scan_serv_chan_dur;
+		}
+	}
+
+	return uccp420wlan_send_cmd((unsigned char *) &reset,
+				    sizeof(struct cmd_reset), UMAC_CMD_RESET);
+}
+
+int uccp420wlan_proc_tx(void)
+{
+	struct cmd_tx_ctrl tx_cmd;
+	struct sk_buff *nbuf, *nbuf_start, *tmp, *skb;
+	unsigned char *data;
+	struct lmac_if_data *p;
+	struct mac80211_dev *dev;
+	struct sk_buff_head *skb_list;
+	struct ieee80211_hdr *mac_hdr;
+	unsigned int index = 0, descriptor_id = 0, queue = WLAN_AC_BE, pkt = 0;
+	u16 hdrlen = 26;
+	rcu_read_lock();
+	p = (struct lmac_if_data *)(rcu_dereference(lmac_if));
+
+	memset(&tx_cmd, 0, sizeof(struct cmd_tx_ctrl));
+	if (!p) {
+		WARN_ON(1);
+		rcu_read_unlock();
+		return -1;
+	}
+	dev = p->context;
+	skb_list = &dev->tx.proc_tx_list[descriptor_id];
+	tx_cmd.hdr.id = UMAC_CMD_TX;
+	/* Keep the queue num and pool id in descriptor id */
+	tx_cmd.hdr.descriptor_id = 0;
+	tx_cmd.hdr.descriptor_id |= ((queue & 0x0000FFFF) << 16);
+	tx_cmd.hdr.descriptor_id |= (descriptor_id & 0x0000FFFF);
+	/* Not used anywhere currently */
+	tx_cmd.hdr.length = sizeof(struct cmd_tx_ctrl);
+
+	/* UMAC_CMD_TX*/
+	tx_cmd.if_index = 0;
+	tx_cmd.queue_num = queue;
+	tx_cmd.more_frms = 0;
+	tx_cmd.descriptor_id = descriptor_id;
+	tx_cmd.num_frames_per_desc = skb_queue_len(skb_list);
+	tx_cmd.pkt_gram_payload_len = hdrlen;
+	tx_cmd.aggregate_mpdu = AMPDU_AGGR_DISABLED;
+
+	/* production test*/
+	tx_cmd.num_rates = 1;
+	if (dev->params->tx_fixed_mcs_indx != -1) {
+		tx_cmd.rate_preamble_type[index] =
+			dev->params->prod_mode_rate_preamble_type;
+		tx_cmd.rate_flags[index] =
+			dev->params->prod_mode_rate_flag;
+		tx_cmd.rate[index] = 0x80;
+		tx_cmd.rate[index] |=
+		    (dev->params->tx_fixed_mcs_indx);
+		tx_cmd.num_spatial_streams[index] =
+		    dev->params->num_spatial_streams;
+		tx_cmd.bcc_or_ldpc =
+		    dev->params->prod_mode_bcc_or_ldpc;
+		tx_cmd.stbc_enabled =
+		    dev->params->prod_mode_stbc_enabled;
+		update_mcs_packet_stat(
+		    dev->params->tx_fixed_mcs_indx,
+		    tx_cmd.rate_flags[index], dev);
+		tx_cmd.num_rates++;
+	} else if (dev->params->tx_fixed_rate != -1) {
+		tx_cmd.rate_preamble_type[index] =
+			dev->params->prod_mode_rate_preamble_type;
+		tx_cmd.rate_flags[index] =
+			dev->params->prod_mode_rate_flag;
+
+		tx_cmd.rate[index] = 0x00;
+		if (dev->params->tx_fixed_rate == 55)
+			tx_cmd.rate[index] |=
+			 ((dev->params->tx_fixed_rate) /
+			  5);
+		else
+			tx_cmd.rate[index] |=
+			  ((dev->params->tx_fixed_rate *
+			    10) / 5);
+		tx_cmd.num_spatial_streams[index] = 1;
+		tx_cmd.bcc_or_ldpc = 0;
+		tx_cmd.stbc_enabled = 0;
+		tx_cmd.num_rates++;
+	}
+
+	nbuf = alloc_skb(sizeof(struct cmd_tx_ctrl) +
+			 tx_cmd.num_frames_per_desc *
+			 MAX_GRAM_PAYLOAD_LEN, GFP_ATOMIC);
+
+	data = skb_put(nbuf, sizeof(struct cmd_tx_ctrl));
+	memset(data, 0, sizeof(struct cmd_tx_ctrl));
+	/*store the start for later use*/
+	nbuf_start = (struct sk_buff *)data;
+	memcpy(data, &tx_cmd,  sizeof(struct cmd_tx_ctrl));
+	pkt = 0;
+	skb_queue_walk_safe(skb_list, skb, tmp) {
+		if (!skb || (pkt > tx_cmd.num_frames_per_desc))
+			break;
+
+		mac_hdr = (struct ieee80211_hdr *)skb->data;
+		/* Complete packet length*/
+		((struct cmd_tx_ctrl *)nbuf_start)->pkt_length[pkt] = skb->len;
+		skb_put(nbuf, MAX_GRAM_PAYLOAD_LEN);
+		memcpy((unsigned char *)nbuf_start +
+			sizeof(struct cmd_tx_ctrl)+
+			(pkt * MAX_GRAM_PAYLOAD_LEN),
+			mac_hdr, hdrlen);
+
+		skb_pull(skb, hdrlen);
+		if (hal_ops.map_tx_buf(descriptor_id, pkt,
+				       skb->data, skb->len)) {
+			rcu_read_unlock();
+			dev_kfree_skb_any(nbuf);
+			return -30;
+		}
+		pkt++;
+	}
+	hal_ops.send((void *)nbuf, HOST_MOD_ID, UMAC_MOD_ID,
+			(void *) skb_list);
+	/* increment tx_cmd_send_count to keep track of number of
+	 * tx_cmd send
+	 */
+	if (skb_queue_len(skb_list) == 1)
+		dev->stats->tx_cmd_send_count_single++;
+	else if (skb_queue_len(skb_list) > 1)
+		dev->stats->tx_cmd_send_count_multi++;
+
+	rcu_read_unlock();
+
+	return 0;
+}
+
+int uccp420wlan_prog_txpower(unsigned int txpower)
+{
+	struct cmd_tx_pwr power;
+
+	memset(&power, 0, sizeof(struct cmd_tx_pwr));
+	power.tx_pwr = txpower;
+	power.if_index = 0;
+
+	return uccp420wlan_send_cmd((unsigned char *) &power,
+				    sizeof(struct cmd_tx_pwr),
+				    UMAC_CMD_TX_POWER);
+}
+
+
+int uccp420wlan_prog_btinfo(unsigned int bt_state)
+{
+	struct cmd_bt_info bt_info;
+	memset(&bt_info, 0, sizeof(struct cmd_bt_info));
+	bt_info.bt_state = bt_state;
+
+	return uccp420wlan_send_cmd((unsigned char *) &bt_info,
+					sizeof(struct cmd_bt_info),
+					UMAC_CMD_BT_INFO);
+}
+
+
+int uccp420wlan_prog_vif_ctrl(int index,
+		unsigned char *mac_addr,
+		unsigned int vif_type,
+		unsigned int op)
+{
+	struct cmd_vifctrl vif_ctrl;
+
+	memset(&vif_ctrl, 0, sizeof(struct cmd_vifctrl));
+	vif_ctrl.mode = vif_type;
+	memcpy(vif_ctrl.mac_addr, mac_addr, 6);
+	vif_ctrl.if_index = index;
+	vif_ctrl.if_ctrl = op;
+
+	return uccp420wlan_send_cmd((unsigned char *) &vif_ctrl,
+				    sizeof(struct cmd_vifctrl),
+				    UMAC_CMD_VIF_CTRL);
+}
+
+
+int uccp420wlan_prog_mcast_addr_cfg(unsigned char *mcast_addr,
+				    unsigned int op)
+{
+	struct cmd_mcst_addr_cfg mcast_config;
+
+	memset(&mcast_config, 0, sizeof(struct cmd_mcst_addr_cfg));
+
+	mcast_config.op = op;
+	memcpy(mcast_config.mac_addr, mcast_addr, 6);
+
+	return uccp420wlan_send_cmd((unsigned char *) &mcast_config,
+				    sizeof(struct cmd_mcst_addr_cfg),
+				    UMAC_CMD_MCST_ADDR_CFG);
+}
+
+
+int uccp420wlan_prog_mcast_filter_control(unsigned int mcast_filter_enable)
+{
+	struct cmd_mcst_filter_ctrl mcast_ctrl;
+
+	memset(&mcast_ctrl, 0, sizeof(struct cmd_mcst_filter_ctrl));
+	mcast_ctrl.ctrl = mcast_filter_enable;
+
+	return uccp420wlan_send_cmd((unsigned char *) &mcast_ctrl,
+				    sizeof(struct cmd_mcst_filter_ctrl),
+				    UMAC_CMD_MCST_FLTR_CTRL);
+}
+
+
+int uccp420wlan_prog_vht_bform(unsigned int vht_beamform_status,
+				  unsigned int vht_beamform_period)
+{
+	struct cmd_vht_beamform vht_beamform;
+
+	memset(&vht_beamform, 0, sizeof(struct cmd_vht_beamform));
+
+	vht_beamform.vht_beamform_status = vht_beamform_status;
+	vht_beamform.vht_beamform_period = vht_beamform_period;
+
+	return uccp420wlan_send_cmd((unsigned char *) &vht_beamform,
+				    sizeof(struct cmd_vht_beamform),
+				    UMAC_CMD_VHT_BEAMFORM_CTRL);
+}
+
+
+int uccp420wlan_prog_roc(unsigned int roc_status,
+			 unsigned int roc_channel,
+			 unsigned int roc_duration)
+{
+	struct cmd_roc cmd_roc;
+	memset(&cmd_roc, 0, sizeof(struct cmd_roc));
+
+	cmd_roc.roc_status	= roc_status;
+	cmd_roc.roc_channel	= roc_channel;
+	cmd_roc.roc_duration	= roc_duration;
+
+	return uccp420wlan_send_cmd((unsigned char *) &cmd_roc,
+			sizeof(struct cmd_roc), UMAC_CMD_ROC_CTRL);
+}
+
+
+int uccp420wlan_prog_nw_selection(unsigned int nw_select_enabled,
+				  unsigned char *mac_addr)
+{
+	struct cmd_nw_selection nw_select;
+	unsigned char req_ie[] = {0xdd, 0x7d, 0x00, 0x50, 0xf2, 0x04, 0x10,
+				  0x4a, 0x00, 0x01, 0x10, 0x10, 0x3a, 0x00,
+				  0x01, 0x01, 0x10, 0x08, 0x00, 0x02, 0x23,
+				  0x88, 0x10, 0x47, 0x00, 0x10, 0x09, 0x0d,
+				  0xf9, 0x4b, 0xf7, 0xab, 0x54, 0x75, 0x8b,
+				  0x4b, 0x91, 0x94, 0x5a, 0x3c, 0xb0, 0xda,
+				  0x10, 0x54, 0x00, 0x08, 0x00, 0x01, 0x00,
+				  0x50, 0xf2, 0x04, 0x00, 0x01, 0x10, 0x3c,
+				  0x00, 0x01, 0x01, 0x10, 0x02, 0x00, 0x02,
+				  0x00, 0x00, 0x10, 0x09, 0x00, 0x02, 0x00,
+				  0x00, 0x10, 0x12, 0x00, 0x02, 0x00, 0x00,
+				  0x10, 0x21, 0x00, 0x09, 0x48, 0x65, 0x6c,
+				  0x6c, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x10,
+				  0x23, 0x00, 0x06, 0x57, 0x50, 0x53, 0x32,
+				  0x2e, 0x30, 0x10, 0x24, 0x00, 0x04, 0x30,
+				  0x2e, 0x38, 0x78, 0x10, 0x11, 0x00, 0x02,
+				  0x4d, 0x4d, 0x10, 0x49, 0x00, 0x09, 0x00,
+				  0x37, 0x2a, 0x00, 0x01, 0x20, 0x03, 0x01,
+				  0x01, 0xdd, 0x11, 0x50, 0x6f, 0x9a, 0x09,
+				  0x02, 0x02, 0x00, 0x23, 0x00, 0x06, 0x05,
+				  0x00, 0x58, 0x58, 0x04, 0x51, 0x0b};
+
+	unsigned char resp_ie[] = {0xdd, 0x70, 0x00, 0x50, 0xf2, 0x04, 0x10,
+				  0x4a, 0x00, 0x01, 0x10, 0x10, 0x44, 0x00,
+				  0x01, 0x01, 0x10, 0x3b, 0x00, 0x01, 0x00,
+				  0x10, 0x47, 0x00, 0x10, 0x09, 0x0d, 0xf9,
+				  0x4b, 0xf7, 0xab, 0x54, 0x75, 0x8b, 0x4b,
+				  0x91, 0x94, 0x5a, 0x3c, 0xb0, 0xda, 0x10,
+				  0x21, 0x00, 0x09, 0x48, 0x65, 0x6c, 0x6c,
+				  0x6f, 0x73, 0x6f, 0x66, 0x74, 0x10, 0x23,
+				  0x00, 0x06, 0x57, 0x50, 0x53, 0x32, 0x2e,
+				  0x30, 0x10, 0x24, 0x00, 0x04, 0x30, 0x2e,
+				  0x38, 0x78, 0x10, 0x42, 0x00, 0x04, 0x30,
+				  0x30, 0x31, 0x34, 0x10, 0x54, 0x00, 0x08,
+				  0x00, 0x01, 0x00, 0x50, 0xf2, 0x04, 0x00,
+				  0x01, 0x10, 0x11, 0x00, 0x02, 0x4d, 0x4d,
+				  0x10, 0x08, 0x00, 0x02, 0x23, 0x88, 0x10,
+				  0x49, 0x00, 0x06, 0x00, 0x37, 0x2a, 0x00,
+				  0x01, 0x20, 0xdd, 0x23, 0x50, 0x6f, 0x9a,
+				  0x09, 0x02, 0x02, 0x00, 0x23, 0x00, 0x0d,
+				  0x17, 0x00, mac_addr[0], mac_addr[1],
+				  mac_addr[2], mac_addr[3], mac_addr[4],
+				  mac_addr[5], 0x01, 0x88, 0x00, 0x01, 0x00,
+				  0x50, 0xf2, 0x04, 0x00, 0x01, 0x00, 0x10,
+				  0x11, 0x00, 0x02, 0x4d, 0x4d};
+
+	memset(&nw_select, 0, sizeof(struct cmd_nw_selection));
+	nw_select.p2p_selection = nw_select_enabled;
+	memcpy(nw_select.ssid.ssid, wildcard_ssid, 7);
+	nw_select.ssid.len = 7;
+	nw_select.scan_req_ie_len = sizeof(req_ie);
+	nw_select.scan_resp_ie_len = sizeof(resp_ie);
+
+	pr_err("req_len = %d, resp_len = %d\n",
+	       nw_select.scan_req_ie_len, nw_select.scan_resp_ie_len);
+
+	memcpy(nw_select.scan_req_ie, req_ie, nw_select.scan_req_ie_len);
+	memcpy(nw_select.scan_resp_ie, resp_ie, nw_select.scan_resp_ie_len);
+
+	return uccp420wlan_send_cmd((unsigned char *) &nw_select,
+				    sizeof(struct cmd_nw_selection),
+				    UMAC_CMD_NW_SELECTION);
+
+}
+
+
+int uccp420wlan_prog_peer_key(int vif_index,
+			      unsigned char *vif_addr,
+			      unsigned int op,
+			      unsigned int key_id,
+			      unsigned int key_type,
+			      unsigned int cipher_type,
+			      struct umac_key *key)
+{
+	struct cmd_setkey peer_key;
+
+	memset(&peer_key, 0, sizeof(struct cmd_setkey));
+
+	peer_key.if_index = vif_index;
+	/* memcpy(peer_key.vif_addr, vif_addr, ETH_ALEN); */
+	peer_key.ctrl = op;
+	peer_key.key_id = key_id;
+	ether_addr_copy(peer_key.mac_addr, key->peer_mac);
+
+	peer_key.key_type = key_type;
+	peer_key.cipher_type = cipher_type;
+	memcpy(peer_key.key, key->key, MAX_KEY_LEN);
+	peer_key.key_len = MAX_KEY_LEN;
+
+	if (key->tx_mic) {
+		memcpy(peer_key.key + MAX_KEY_LEN, key->tx_mic, TKIP_MIC_LEN);
+		peer_key.key_len += TKIP_MIC_LEN;
+	}
+	if (key->rx_mic) {
+		memcpy(peer_key.key + MAX_KEY_LEN + TKIP_MIC_LEN , key->rx_mic,
+		       TKIP_MIC_LEN);
+		peer_key.key_len += TKIP_MIC_LEN;
+	}
+	peer_key.rsc_len = 6;
+	memset(peer_key.rsc, 0, 6);
+
+	return uccp420wlan_send_cmd((unsigned char *) &peer_key,
+				    sizeof(struct cmd_setkey), UMAC_CMD_SETKEY);
+}
+
+
+int uccp420wlan_prog_if_key(int vif_index,
+			    unsigned char *vif_addr,
+			    unsigned int op,
+			    unsigned int key_id,
+			    unsigned int cipher_type,
+			    struct umac_key *key)
+	{
+	struct cmd_setkey if_key;
+
+	memset(&if_key, 0, sizeof(struct cmd_setkey));
+
+	if_key.if_index = vif_index;
+	/* memcpy(if_key.vif_addr, vif_addr, 6); */
+	if_key.key_id = key_id;
+	if_key.ctrl = op;
+
+	if (op == KEY_CTRL_ADD) {
+		if_key.cipher_type = cipher_type;
+
+		if (cipher_type == CIPHER_TYPE_TKIP ||	cipher_type ==
+		    CIPHER_TYPE_CCMP) {
+			memcpy(if_key.key, key->key, MAX_KEY_LEN);
+			if_key.key_len = MAX_KEY_LEN;
+
+			if (key->tx_mic) {
+				memcpy(if_key.key + MAX_KEY_LEN, key->tx_mic,
+				       TKIP_MIC_LEN);
+				if_key.key_len += TKIP_MIC_LEN;
+			}
+		} else {
+			if_key.key_len =
+				(cipher_type == CIPHER_TYPE_WEP40) ? 5 : 13;
+			memcpy(if_key.key, key->key, if_key.key_len);
+		}
+	}
+
+	if_key.rsc_len = 6;
+	if_key.key_type = KEY_TYPE_BCAST;
+	memset(if_key.rsc, 0, 6);
+	memset(if_key.mac_addr, 0xff, 6);
+
+	return uccp420wlan_send_cmd((unsigned char *) &if_key,
+				    sizeof(struct cmd_setkey), UMAC_CMD_SETKEY);
+}
+
+int uccp420wlan_prog_ba_session_data(unsigned int op,
+				     unsigned short tid,
+				     unsigned short *ssn,
+				     unsigned short ba_policy,
+				     unsigned char *vif_addr,
+				     unsigned char *peer_addr)
+{
+	struct cmd_ht_ba ba_cmd;
+	int index;
+	struct mac80211_dev *dev;
+	struct lmac_if_data *p;
+
+	rcu_read_lock();
+	p = (struct lmac_if_data *)(rcu_dereference(lmac_if));
+
+	if (!p) {
+		WARN_ON(1);
+		rcu_read_unlock();
+		return -1;
+	}
+
+	rcu_read_unlock();
+	dev = p->context;
+
+	memset(&ba_cmd, 0, sizeof(struct cmd_ht_ba));
+
+	for (index = 0; index < dev->params->num_vifs; index++) {
+		if (dev->if_mac_addresses[index].addr[5] == vif_addr[5])
+			break;
+	}
+
+	if (index == dev->params->num_vifs) {
+		DEBUG_LOG("no VIF found\n");
+		return -1;
+	}
+
+	ba_cmd.if_index = index;
+	ba_cmd.op = op;
+	ba_cmd.policy = ba_policy;
+	ba_cmd.tid = tid;
+	ba_cmd.ssn = *ssn;
+	ether_addr_copy(ba_cmd.vif_addr, vif_addr);
+	ether_addr_copy(ba_cmd.peer_addr, peer_addr);
+
+	return uccp420wlan_send_cmd((unsigned char *) &ba_cmd,
+				    sizeof(struct cmd_ht_ba),
+				    UMAC_CMD_BA_SESSION_INFO);
+}
+
+
+int uccp420wlan_scan(int index,
+		     struct scan_req *req)
+{
+	struct cmd_scan *scan;
+	unsigned char i;
+	struct mac80211_dev *dev;
+	struct lmac_if_data *p;
+
+	rcu_read_lock();
+	p = (struct lmac_if_data *)(rcu_dereference(lmac_if));
+
+	if (!p) {
+		WARN_ON(1);
+		rcu_read_unlock();
+		return -1;
+	}
+
+	rcu_read_unlock();
+	dev = p->context;
+
+	scan = kmalloc(sizeof(struct cmd_scan) +
+		       req->ie_len, GFP_KERNEL);
+
+	if (scan == NULL) {
+		DEBUG_LOG("%s: Failed to allocate memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	memset(scan, 0, sizeof(struct cmd_scan));
+
+	scan->if_index = index;
+
+	/* We support 4 SSIDs */
+	scan->n_ssids = req->n_ssids;
+	scan->n_channel = req->n_channels;
+	scan->type = dev->params->scan_type;
+
+	for (i = 0; i < scan->n_channel; i++) {
+		scan->channel_list[i] =
+			(ieee80211_frequency_to_channel(req->center_freq[i]));
+		scan->chan_max_power[i] = req->freq_max_power[i];
+
+		/* scan->chan_max_antenna_gain[i] =
+		 * req->freq_max_antenna_gain[i];
+		 */
+
+		/* In mac80211 the flags are u32 but for scanning we need
+		 * only first PASSIVE_SCAN flag, remaining flags may be used
+		 * in future.
+		 */
+		if ((req->chan_flags[i] & IEEE80211_CHAN_NO_IR) ||
+		    (req->chan_flags[i] & IEEE80211_CHAN_RADAR)) {
+			scan->chan_flags[i] = PASSIVE;
+		} else {
+			scan->chan_flags[i] = ACTIVE;
+		}
+	}
+
+	scan->p2p_probe = req->p2p_probe;
+
+	scan->extra_ies_len = req->ie_len;
+
+	if (req->ie_len)
+		memcpy(scan->extra_ies, req->ie, req->ie_len);
+
+	if (req->n_ssids > 0) {
+		for (i = 0; i < scan->n_ssids; i++) {
+			scan->ssids[i].len = req->ssids[i].ssid_len;
+			if (scan->ssids[i].len > 0)
+				memcpy(scan->ssids[i].ssid, req->ssids[i].ssid,
+				       req->ssids[i].ssid_len);
+		}
+	}
+	DEBUG_LOG("Scan request ie\n");
+	DEBUG_LOG("	len = %d n_channel = %d, n_ssids = %d\n",
+			req->ie_len,
+			scan->n_channel,
+			scan->n_ssids);
+	DEBUG_LOG("	if_index = %d type = %d p2p = %d\n",
+			scan->if_index,
+			scan->type,
+			scan->p2p_probe);
+
+	for (i = 0; i < scan->n_ssids; i++) {
+		if (scan->ssids[i].len != 0)
+			DEBUG_LOG("SSID: %s\n", scan->ssids[i].ssid);
+		else
+			DEBUG_LOG("SSID: EMPTY\n");
+	}
+
+	DEBUG_LOG("CHANNEL_LIST: Channel ==> Channel Flags\n");
+
+	for (i = 0; i < scan->n_channel; i++)
+		DEBUG_LOG("Index %d: %d ==> %d\n", i,
+				scan->channel_list[i], scan->chan_flags[i]);
+
+	dev->stats->umac_scan_req++;
+
+	uccp420wlan_send_cmd((unsigned char *)scan, sizeof(struct cmd_scan) +
+			     req->ie_len, UMAC_CMD_SCAN);
+	kfree(scan);
+
+	return 0;
+}
+
+
+int uccp420wlan_scan_abort(int index)
+{
+	struct cmd_scan_abort *scan_abort = NULL;
+
+	scan_abort = (struct cmd_scan_abort *)
+		kmalloc(sizeof(struct cmd_scan_abort), GFP_KERNEL);
+
+	if (scan_abort == NULL) {
+		DEBUG_LOG("%s: Failed to allocate memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	memset(scan_abort, 0, sizeof(struct cmd_scan_abort));
+
+	scan_abort->if_index = index;
+
+	uccp420wlan_send_cmd((unsigned char *)scan_abort,
+			     sizeof(struct cmd_scan_abort),
+			     UMAC_CMD_SCAN_ABORT);
+
+	kfree(scan_abort);
+	scan_abort = NULL;
+
+	return 0;
+}
+
+
+int uccp420wlan_prog_channel(unsigned int prim_ch,
+			     unsigned int ch_no1,
+			     unsigned int ch_no2,
+			     unsigned int ch_width,
+			     unsigned int freq_band)
+{
+	struct cmd_channel channel;
+
+	memset(&channel, 0, sizeof(struct cmd_channel));
+	channel.primary_ch_number = prim_ch;
+	channel.channel_number1 = ch_no1;
+	channel.channel_number2 = ch_no2;
+
+	switch (ch_width) {
+	case 0:
+	case 1:
+		channel.channel_bw = 0;
+		break;
+	case 2:
+		channel.channel_bw = 1;
+		break;
+	case 3:
+		channel.channel_bw = 2;
+		break;
+	case 4:
+	case 5:
+		channel.channel_bw = 3;
+		break;
+	default:
+		break;
+	}
+
+	channel.freq_band = freq_band;
+
+	return uccp420wlan_send_cmd((unsigned char *) &channel,
+				    sizeof(struct cmd_channel),
+				    UMAC_CMD_CHANNEL);
+}
+
+
+int uccp420wlan_prog_ps_state(int index,
+			      unsigned char *vif_addr,
+			      unsigned int powersave_state)
+{
+	struct cmd_ps ps_cfg;
+
+	memset(&ps_cfg, 0, sizeof(struct cmd_ps));
+	ps_cfg.mode = powersave_state;
+	ps_cfg.if_index = index;
+
+	return uccp420wlan_send_cmd((unsigned char *)&ps_cfg,
+				    sizeof(struct cmd_ps), UMAC_CMD_PS);
+}
+
+
+int uccp420wlan_prog_tx(unsigned int queue,
+			unsigned int more_frms,
+			unsigned int descriptor_id)
+{
+	struct cmd_tx_ctrl tx_cmd;
+	struct sk_buff *nbuf, *nbuf_start;
+	unsigned char *data;
+	struct lmac_if_data *p;
+	struct mac80211_dev *dev;
+	struct umac_vif *uvif;
+	struct sk_buff *skb, *skb_first, *tmp;
+	struct sk_buff_head *tx_skb_list;
+	struct ieee80211_hdr *mac_hdr;
+	struct ieee80211_tx_info *tx_info_first;
+	unsigned int hdrlen, pkt = 0;
+	int vif_index;
+	__u16 fc;
+	unsigned long irq_flags, tx_irq_flags;
+
+	memset(&tx_cmd, 0, sizeof(struct cmd_tx_ctrl));
+
+	rcu_read_lock();
+	p = (struct lmac_if_data *)(rcu_dereference(lmac_if));
+
+	if (!p) {
+		WARN_ON(1);
+		rcu_read_unlock();
+		return -1;
+	}
+
+	dev = p->context;
+	spin_lock_irqsave(&dev->tx.lock, tx_irq_flags);
+	tx_skb_list = &dev->tx.tx_pkt[descriptor_id];
+	skb_first = skb_peek(tx_skb_list);
+
+	if (!skb_first) {
+		spin_unlock_irqrestore(&dev->tx.lock, tx_irq_flags);
+		rcu_read_unlock();
+		return -10;
+	}
+
+	tx_info_first = IEEE80211_SKB_CB(skb_first);
+
+	mac_hdr = (struct ieee80211_hdr *)skb_first->data;
+	fc = mac_hdr->frame_control;
+	hdrlen = ieee80211_hdrlen(fc);
+	vif_index = vif_addr_to_index(mac_hdr->addr2, dev);
+
+	/* GET The security Header Length only for data/qos-data/unicast PMF
+	 * for 11W case.
+	 */
+	if ((ieee80211_is_data(fc) ||
+	     ieee80211_is_data_qos(fc))
+	    && ieee80211_has_protected(fc)) {
+		DEBUG_LOG("%s:cipher: %d,icv_len: %d,iv_len: %d,keylen:%d\n",
+			     __func__,
+			     tx_info_first->control.hw_key->cipher,
+			     tx_info_first->control.hw_key->icv_len,
+			     tx_info_first->control.hw_key->iv_len,
+			     tx_info_first->control.hw_key->keylen);
+
+		/* iv_len is always the header ahd
+		 * icv_len is always the trailer
+		 * include only iv_len
+		 */
+		hdrlen += tx_info_first->control.hw_key->iv_len;
+	}
+
+	/* For injected frames (wlantest) hw_key is not set,as PMF uses
+	 * CCMP always so hardcode this to CCMP IV LEN 8.
+	 * For Auth3: It is completely handled in SW (mac80211).
+	 */
+	if (ieee80211_is_unicast_robust_mgmt_frame(skb_first) &&
+	    ieee80211_has_protected(fc)) {
+		hdrlen += 8;
+		tx_cmd.force_encrypt = 1;
+	}
+
+	/* separate in to up to TSF and From TSF*/
+	if (ieee80211_is_beacon(fc) || ieee80211_is_probe_resp(fc))
+		hdrlen += 8; /* Timestamp*/
+
+	/* HAL UMAC-LMAC HDR*/
+	tx_cmd.hdr.id = UMAC_CMD_TX;
+	/* Keep the queue num and pool id in descriptor id */
+	tx_cmd.hdr.descriptor_id = 0;
+	tx_cmd.hdr.descriptor_id |= ((queue & 0x0000FFFF) << 16);
+	tx_cmd.hdr.descriptor_id |= (descriptor_id & 0x0000FFFF);
+	/* Not used anywhere currently */
+	tx_cmd.hdr.length = sizeof(struct cmd_tx_ctrl);
+
+	/* UMAC_CMD_TX*/
+	tx_cmd.if_index = vif_index;
+	tx_cmd.queue_num = queue;
+	tx_cmd.more_frms = more_frms;
+	tx_cmd.descriptor_id = descriptor_id;
+	tx_cmd.num_frames_per_desc = skb_queue_len(tx_skb_list);
+	tx_cmd.pkt_gram_payload_len = hdrlen;
+	tx_cmd.aggregate_mpdu = AMPDU_AGGR_DISABLED;
+
+	uvif = (struct umac_vif *) (tx_info_first->control.vif->drv_priv);
+
+	nbuf = alloc_skb(sizeof(struct cmd_tx_ctrl) +
+			 tx_cmd.num_frames_per_desc *
+			 MAX_GRAM_PAYLOAD_LEN, GFP_ATOMIC);
+
+	if (!nbuf) {
+		spin_unlock_irqrestore(&dev->tx.lock, tx_irq_flags);
+		rcu_read_unlock();
+		return -20;
+	}
+
+	 /* Get the rate for first packet as all packets have same rate */
+	get_rate(skb_first, &tx_cmd, dev);
+
+	data = skb_put(nbuf, sizeof(struct cmd_tx_ctrl));
+	memset(data, 0, sizeof(struct cmd_tx_ctrl));
+	/*store the start for later use*/
+	nbuf_start = (struct sk_buff *)data;
+	memcpy(data, &tx_cmd,  sizeof(struct cmd_tx_ctrl));
+
+	DEBUG_LOG("%s-UMACTX: TX Frame, Queue = %d, descriptord_id = %d\n",
+		     dev->name,
+		     tx_cmd.queue_num, tx_cmd.descriptor_id);
+	DEBUG_LOG("		num_frames= %d qlen: %d len = %d\n",
+		     tx_cmd.num_frames_per_desc, skb_queue_len(tx_skb_list),
+		     nbuf->len);
+
+	DEBUG_LOG("%s-UMACTX: Num rates = %d, %x, %x, %x, %x\n",
+		     dev->name,
+		     tx_cmd.num_rates,
+		     tx_cmd.rate[0],
+		     tx_cmd.rate[1],
+		     tx_cmd.rate[2],
+		     tx_cmd.rate[3]);
+
+	skb_queue_walk_safe(tx_skb_list, skb, tmp) {
+		if (!skb || (pkt > tx_cmd.num_frames_per_desc))
+			break;
+
+		mac_hdr = (struct ieee80211_hdr *)skb->data;
+
+		/* Only for Non-Qos and MGMT frames, for Qos-Data
+		 * mac80211 handles the sequence no generation
+		 */
+		if (tx_info_first->flags &
+		    IEEE80211_TX_CTL_ASSIGN_SEQ) {
+			if (tx_info_first->flags &
+			    IEEE80211_TX_CTL_FIRST_FRAGMENT) {
+				uvif->seq_no += 0x10;
+			}
+
+			mac_hdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);
+			mac_hdr->seq_ctrl |= cpu_to_le16(uvif->seq_no);
+		}
+
+		/* Need it for tx_status later */
+		dev->tx.tx_pkt_hdr_len[descriptor_id] = hdrlen;
+
+		/* Complete packet length*/
+		((struct cmd_tx_ctrl *)nbuf_start)->pkt_length[pkt] = skb->len;
+
+		/* We move the 11hdr from skb to UMAC_CMD_TX, this is part of
+		 * online DMA changes, HW expects only data portion
+		 * While DMA. Not requried for loopback
+		 */
+		skb_put(nbuf, MAX_GRAM_PAYLOAD_LEN);
+
+		memcpy((unsigned char *)nbuf_start +
+			sizeof(struct cmd_tx_ctrl)+
+			(pkt * MAX_GRAM_PAYLOAD_LEN),
+			mac_hdr, hdrlen);
+
+		skb_pull(skb, hdrlen);
+		if (hal_ops.map_tx_buf(descriptor_id, pkt,
+				       skb->data, skb->len)) {
+			spin_unlock_irqrestore(&dev->tx.lock, tx_irq_flags);
+			rcu_read_unlock();
+			dev_kfree_skb_any(nbuf);
+			return -30;
+		}
+
+		pkt++;
+	}
+
+#ifdef PERF_PROFILING
+	if (dev->params->driver_tput == 0) {
+#endif
+		spin_lock_irqsave(&cmd_info.control_path_lock, irq_flags);
+		hal_ops.send((void *)nbuf, HOST_MOD_ID, UMAC_MOD_ID,
+			     (void *)&dev->tx.tx_pkt[descriptor_id]);
+		spin_unlock_irqrestore(&cmd_info.control_path_lock, irq_flags);
+
+		/* increment tx_cmd_send_count to keep track of number of
+		 * tx_cmd send
+		 */
+		if (skb_queue_len(&dev->tx.tx_pkt[descriptor_id]) == 1)
+			dev->stats->tx_cmd_send_count_single++;
+		else if (skb_queue_len(&dev->tx.tx_pkt[descriptor_id]) > 1)
+			dev->stats->tx_cmd_send_count_multi++;
+#ifdef PERF_PROFILING
+	}
+#endif
+
+	spin_unlock_irqrestore(&dev->tx.lock, tx_irq_flags);
+	rcu_read_unlock();
+
+	return 0;
+}
+
+
+int uccp420wlan_prog_vif_short_slot(int index,
+				    unsigned char *vif_addr,
+				    unsigned int use_short_slot)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = SHORTSLOT_CHANGED;
+	vif_cfg.use_short_slot = use_short_slot;
+	vif_cfg.if_index = index;
+	memcpy(vif_cfg.vif_addr, vif_addr, 6);
+
+	return uccp420wlan_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    UMAC_CMD_VIF_CFG);
+}
+
+
+int uccp420wlan_prog_vif_atim_window(int index,
+				     unsigned char *vif_addr,
+				     unsigned int atim_window)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = ATIMWINDOW_CHANGED;
+	vif_cfg.atim_window = atim_window;
+	vif_cfg.if_index = index;
+	memcpy(vif_cfg.vif_addr, vif_addr, 6);
+
+	return uccp420wlan_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    UMAC_CMD_VIF_CFG);
+}
+
+
+int uccp420wlan_prog_long_retry(int index,
+				unsigned char *vif_addr,
+				unsigned int long_retry)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = LONGRETRY_CHANGED;
+	vif_cfg.long_retry = long_retry;
+	vif_cfg.if_index = index;
+	memcpy(vif_cfg.vif_addr, vif_addr, 6);
+
+	return uccp420wlan_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    UMAC_CMD_VIF_CFG);
+
+}
+
+
+int uccp420wlan_prog_short_retry(int index,
+				 unsigned char *vif_addr,
+				 unsigned int short_retry)
+{
+
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = SHORTRETRY_CHANGED;
+	vif_cfg.short_retry = short_retry;
+	vif_cfg.if_index = index;
+	memcpy(vif_cfg.vif_addr, vif_addr, 6);
+
+	return uccp420wlan_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    UMAC_CMD_VIF_CFG);
+
+
+}
+
+
+int uccp420wlan_prog_vif_basic_rates(int index,
+				     unsigned char *vif_addr,
+				     unsigned int basic_rate_set)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = BASICRATES_CHANGED;
+	vif_cfg.basic_rate_set = basic_rate_set;
+	vif_cfg.if_index = index;
+	memcpy(vif_cfg.vif_addr, vif_addr, 6);
+
+	return uccp420wlan_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    UMAC_CMD_VIF_CFG);
+
+
+}
+
+
+int uccp420wlan_prog_vif_aid(int index,
+			     unsigned char *vif_addr,
+			     unsigned int aid)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = AID_CHANGED;
+	vif_cfg.aid = aid;
+	vif_cfg.if_index = index;
+	memcpy(vif_cfg.vif_addr, vif_addr, 6);
+
+	return uccp420wlan_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    UMAC_CMD_VIF_CFG);
+}
+
+
+int uccp420wlan_prog_vif_op_channel(int index,
+				    unsigned char *vif_addr,
+				    unsigned char op_channel)
+{
+
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = OP_CHAN_CHANGED;
+	vif_cfg.op_channel = op_channel;
+	vif_cfg.if_index = index;
+	memcpy(vif_cfg.vif_addr, vif_addr, 6);
+
+	return uccp420wlan_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    UMAC_CMD_VIF_CFG);
+}
+
+
+int uccp420wlan_prog_vif_conn_state(int index,
+				       unsigned char *vif_addr,
+				       unsigned int connect_state)
+{
+
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = CONNECT_STATE_CHANGED;
+	vif_cfg.connect_state = connect_state;
+	vif_cfg.if_index = index;
+	memcpy(vif_cfg.vif_addr, vif_addr, 6);
+	return uccp420wlan_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    UMAC_CMD_VIF_CFG);
+}
+
+
+int uccp420wlan_prog_vif_assoc_cap(int index,
+				   unsigned char *vif_addr,
+				   unsigned int caps)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = CAPABILITY_CHANGED;
+	vif_cfg.capability = caps;
+	vif_cfg.if_index = index;
+	memcpy(vif_cfg.vif_addr, vif_addr, 6);
+
+	return uccp420wlan_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    UMAC_CMD_VIF_CFG);
+
+}
+
+
+int uccp420wlan_prog_vif_beacon_int(int index,
+				    unsigned char *vif_addr,
+				    unsigned int bcn_int)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+
+	vif_cfg.changed_bitmap = BCN_INT_CHANGED;
+	vif_cfg.beacon_interval = bcn_int;
+	vif_cfg.if_index = index;
+	memcpy(vif_cfg.vif_addr, vif_addr, 6);
+
+	return uccp420wlan_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    UMAC_CMD_VIF_CFG);
+}
+
+
+int uccp420wlan_prog_vif_dtim_period(int index,
+				     unsigned char *vif_addr,
+				     unsigned int dtim_period)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+
+	vif_cfg.changed_bitmap = DTIM_PERIOD_CHANGED;
+	vif_cfg.beacon_interval = dtim_period;
+	vif_cfg.if_index = index;
+	memcpy(vif_cfg.vif_addr, vif_addr, 6);
+
+	return uccp420wlan_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    UMAC_CMD_VIF_CFG);
+}
+
+
+int uccp420wlan_prog_vif_bssid(int index,
+			       unsigned char *vif_addr,
+			       unsigned char *bssid)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = BSSID_CHANGED;
+	memcpy(vif_cfg.bssid, bssid, 6);
+	memcpy(vif_cfg.vif_addr, vif_addr, 6);
+	vif_cfg.if_index = index;
+
+	return uccp420wlan_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    UMAC_CMD_VIF_CFG);
+}
+
+
+int uccp420wlan_prog_vif_smps(int index,
+			      unsigned char *vif_addr,
+			      unsigned char smps_mode)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = SMPS_CHANGED;
+	vif_cfg.if_index = index;
+	memcpy(vif_cfg.vif_addr, vif_addr, 6);
+
+	switch (smps_mode) {
+	case IEEE80211_SMPS_STATIC:
+		vif_cfg.smps_info |= SMPS_ENABLED;
+		break;
+	case IEEE80211_SMPS_DYNAMIC:
+		vif_cfg.smps_info |= SMPS_ENABLED;
+		vif_cfg.smps_info |= SMPS_MODE;
+		break;
+	case IEEE80211_SMPS_AUTOMATIC:/* will be one of the above*/
+	case IEEE80211_SMPS_OFF:
+		break;
+	default:
+		WARN(1, "Invalid SMPS Mode: %d\n", smps_mode);
+	}
+
+	return uccp420wlan_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    UMAC_CMD_VIF_CFG);
+}
+
+
+int uccp420wlan_sta_add(int index, struct peer_sta_info *st)
+{
+	struct cmd_sta sta;
+	int i;
+
+	memset(&sta, 0, (sizeof(struct cmd_sta)));
+	sta.op = ADD;
+
+	for (i = 0; i < STA_NUM_BANDS; i++)
+		sta.supp_rates[i] = st->supp_rates[i];
+
+	/*HT info*/
+	sta.if_index = index;
+	sta.ht_cap = st->ht_cap;
+	sta.ht_supported = st->ht_supported;
+	sta.vht_supported = st->vht_supported;
+	sta.vht_cap = st->vht_cap;
+	sta.ampdu_factor = st->ampdu_factor;
+	sta.ampdu_density = st->ampdu_density;
+	sta.rx_highest = st->rx_highest;
+	sta.tx_params = st->tx_params;
+
+	/*Enable it when FW supports it*/
+	/* sta.uapsd_queues = st->uapsd_queues; */
+	for (i = 0; i < HT_MCS_MASK_LEN; i++)
+		sta.rx_mask[i] = st->rx_mask[i];
+
+	for (i = 0; i < ETH_ALEN; i++)
+		sta.addr[i] = st->addr[i];
+
+	return uccp420wlan_send_cmd((unsigned char *)&sta,
+				    sizeof(struct cmd_sta), UMAC_CMD_STA);
+}
+
+
+int uccp420wlan_sta_remove(int index, struct peer_sta_info *st)
+{
+	struct cmd_sta sta;
+	int i;
+
+	memset(&sta, 0, (sizeof(struct cmd_sta)));
+	sta.op = REM;
+
+	for (i = 0; i < ETH_ALEN; i++)
+		sta.addr[i] = st->addr[i];
+
+	return uccp420wlan_send_cmd((unsigned char *)&sta,
+				    sizeof(struct cmd_sta), UMAC_CMD_STA);
+
+}
+
+
+int uccp420wlan_prog_txq_params(int index,
+				unsigned char *addr,
+				unsigned int queue,
+				unsigned int aifs,
+				unsigned int txop,
+				unsigned int cwmin,
+				unsigned int cwmax,
+				unsigned int uapsd)
+{
+	struct cmd_txq_params params;
+
+	memset(&params, 0, (sizeof(struct cmd_txq_params)));
+
+	params.if_index = index;
+	ether_addr_copy(params.vif_addr, addr);
+	params.queue_num = queue;
+	params.aifsn = aifs;
+	params.txop = txop;
+	params.cwmin = cwmin;
+	params.cwmax = cwmax;
+	params.uapsd = uapsd;
+
+	return uccp420wlan_send_cmd((unsigned char *) &params,
+				    sizeof(struct cmd_txq_params),
+				    UMAC_CMD_TXQ_PARAMS);
+}
+
+
+int uccp420wlan_set_rate(int rate, int mcs)
+{
+	struct cmd_rate cmd_rate;
+	memset(&cmd_rate, 0, (sizeof(struct cmd_rate)));
+	DEBUG_LOG("mcs = %d rate = %d\n", mcs, rate);
+	cmd_rate.is_mcs = mcs;
+	cmd_rate.rate = rate;
+	return uccp420wlan_send_cmd((unsigned char *) &cmd_rate,
+				    sizeof(struct cmd_rate),
+				    UMAC_CMD_RATE);
+}
+
+
+int uccp420wlan_prog_rcv_bcn_mode(unsigned int bcn_rcv_mode)
+{
+	struct cmd_vif_cfg vif_cfg;
+
+	memset(&vif_cfg, 0, sizeof(struct cmd_vif_cfg));
+	vif_cfg.changed_bitmap = RCV_BCN_MODE_CHANGED;
+	vif_cfg.bcn_mode = bcn_rcv_mode;
+
+	return uccp420wlan_send_cmd((unsigned char *)&vif_cfg,
+				    sizeof(struct cmd_vif_cfg),
+				    UMAC_CMD_VIF_CFG);
+
+}
+
+int uccp420wlan_prog_aux_adc_chain(unsigned int chain_id)
+{
+	struct cmd_aux_adc_chain_sel aadc_chain_sel;
+	memset(&aadc_chain_sel, 0 , sizeof(struct cmd_aux_adc_chain_sel));
+	aadc_chain_sel.chain_id = chain_id;
+
+	return uccp420wlan_send_cmd((unsigned char *)&aadc_chain_sel,
+				    sizeof(struct cmd_aux_adc_chain_sel),
+				    UMAC_CMD_AUX_ADC_CHAIN_SEL);
+}
+
+
+int uccp420wlan_prog_mib_stats(void)
+{
+	struct host_mac_msg_hdr mib_stats_cmd;
+
+	DEBUG_LOG("cmd mib stats\n");
+	memset(&mib_stats_cmd, 0, sizeof(struct host_mac_msg_hdr));
+
+	return uccp420wlan_send_cmd((unsigned char *)&mib_stats_cmd,
+				    sizeof(struct host_mac_msg_hdr),
+				    UMAC_CMD_MIB_STATS);
+}
+
+
+int uccp420wlan_prog_clear_stats(void)
+{
+	struct host_mac_msg_hdr clear_stats_cmd;
+
+	DEBUG_LOG("cmd clear stats\n");
+	memset(&clear_stats_cmd, 0, sizeof(struct host_mac_msg_hdr));
+
+	return uccp420wlan_send_cmd((unsigned char *)&clear_stats_cmd,
+				    sizeof(struct host_mac_msg_hdr),
+				    UMAC_CMD_CLEAR_STATS);
+}
+
+
+int uccp420wlan_prog_phy_stats(void)
+{
+	struct host_mac_msg_hdr phy_stats_cmd;
+
+	DEBUG_LOG("cmd phy stats\n");
+	memset(&phy_stats_cmd, 0, sizeof(struct host_mac_msg_hdr));
+
+	return uccp420wlan_send_cmd((unsigned char *)&phy_stats_cmd,
+				    sizeof(struct host_mac_msg_hdr),
+				    UMAC_CMD_PHY_STATS);
+}
+
+
+int uccp420wlan_prog_global_cfg(unsigned int rx_msdu_lifetime,
+				unsigned int tx_msdu_lifetime,
+				unsigned int sensitivity,
+				unsigned int dyn_ed_enable,
+				unsigned char *rf_params)
+{
+	/*DUMMY*/
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+int uccp420wlan_prog_econ_ps_state(int if_index,
+				   unsigned int ps_state)
+{
+	struct cmd_ps ps_cfg;
+
+	memset(&ps_cfg, 0, sizeof(struct cmd_ps));
+	ps_cfg.mode = ps_state;
+	ps_cfg.if_index = if_index;
+
+	return uccp420wlan_send_cmd((unsigned char *)&ps_cfg,
+				    sizeof(struct cmd_ps),
+				    UMAC_CMD_PS_ECON_CFG);
+}
+#endif
+
+
+int uccp420wlan_msg_handler (void *nbuff,
+			     unsigned char sender_id)
+{
+	unsigned int event;
+	unsigned char *buff;
+	struct host_mac_msg_hdr *hdr;
+	struct lmac_if_data *p;
+	struct sk_buff *skb = (struct sk_buff *)nbuff;
+	struct sk_buff *pending_cmd;
+	unsigned long irq_flags;
+	struct mac80211_dev *dev;
+
+	rcu_read_lock();
+
+	p = (struct lmac_if_data *)(rcu_dereference(lmac_if));
+
+	if (!p) {
+		WARN_ON(1);
+		dev_kfree_skb_any(skb);
+		rcu_read_unlock();
+		return 0;
+	}
+
+	buff = skb->data;
+	hdr = (struct host_mac_msg_hdr *)buff;
+
+	event = hdr->id & 0xffff;
+
+	dev = (struct mac80211_dev *)p->context;
+
+	/* DEBUG_LOG("%s-UMACIF: event %d received\n", p->name, event); */
+	if (event == UMAC_EVENT_RESET_COMPLETE) {
+		struct host_event_reset_complete *r =
+				(struct host_event_reset_complete *)buff;
+
+		uccp420wlan_reset_complete(r->version, p->context);
+		spin_lock_irqsave(&cmd_info.control_path_lock, irq_flags);
+
+		if (cmd_info.outstanding_ctrl_req == 0) {
+			pr_err("%s-UMACIF: Unexpected: Spurious proc_done received. Ignoring and continuing.\n",
+			       p->name);
+		} else {
+			cmd_info.outstanding_ctrl_req--;
+
+			DEBUG_LOG("After DEC: outstanding cmd: %d\n",
+				     cmd_info.outstanding_ctrl_req);
+			pending_cmd = skb_dequeue(&cmd_info.outstanding_cmd);
+
+			if (unlikely(pending_cmd != NULL)) {
+				DEBUG_LOG("Send 1 outstanding cmd\n");
+				hal_ops.send((void *)pending_cmd, HOST_MOD_ID,
+					     UMAC_MOD_ID, 0);
+				dev->stats->gen_cmd_send_count++;
+			}
+		}
+
+		spin_unlock_irqrestore(&cmd_info.control_path_lock, irq_flags);
+	} else if (event == UMAC_EVENT_SCAN_ABORT_COMPLETE) {
+		dev->scan_abort_done = 1;
+#ifdef CONFIG_PM
+	} else if (event == UMAC_EVENT_PS_ECON_CFG_DONE) {
+		struct umac_event_ps_econ_cfg_complete *econ_cfg_complete_data =
+				(struct umac_event_ps_econ_cfg_complete *)buff;
+		dev->econ_ps_cfg_stats.completed = 1;
+		dev->econ_ps_cfg_stats.result = econ_cfg_complete_data->status;
+	} else if (event == UMAC_EVENT_PS_ECON_WAKE) {
+		struct umac_event_ps_econ_wake *econ_wake_data =
+					(struct umac_event_ps_econ_wake *)buff;
+		dev->econ_ps_cfg_stats.wake_trig = econ_wake_data->trigger;
+#endif
+	} else if (event == UMAC_EVENT_SCAN_COMPLETE) {
+		uccp420wlan_scan_complete(p->context,
+			(struct host_event_scanres *) buff,
+			buff +  sizeof(struct host_event_scanres), skb->len);
+
+	} else if (event == UMAC_EVENT_RX /* ||
+		   event == EVENT_RX_MIC_FAILURE*/) {
+		if (dev->params->production_test) {
+			dev->stats->rx_packet_data_count++;
+			dev_kfree_skb_any(skb);
+		} else {
+			uccp420wlan_rx_frame(skb, p->context);
+
+		}
+
+	} else if (event == UMAC_EVENT_TX_DONE) {
+		if (dev->params->production_test &&
+		    dev->params->start_prod_mode)
+			uccp420wlan_proc_tx_complete((void *)buff,
+						     p->context);
+		else
+			uccp420wlan_tx_complete((void *)buff,
+						p->context);
+
+		cmd_info.tx_done_recv_count++;
+
+	} else if (event == UMAC_EVENT_DISCONNECTED) {
+		struct host_event_disconnect *dis =
+			(struct host_event_disconnect *)buff;
+		int i = 0;
+
+		if (dis->reason_code == REASON_NW_LOST) {
+			while (i < MAX_VIFS) {
+				if (dev->vifs[i]) {
+					if ((memcmp(dev->vifs[i]->addr,
+						    dis->mac_addr,
+						    ETH_ALEN)) == 0) {
+						ieee80211_connection_loss(
+								dev->vifs[i]);
+						break;
+					}
+				}
+				i++;
+			}
+		}
+
+	} else if (event == UMAC_EVENT_MIB_STAT) {
+		struct umac_event_mib_stats  *mib_stats =
+			(struct umac_event_mib_stats *) buff;
+
+		uccp420wlan_mib_stats(mib_stats, p->context);
+	} else if (event == UMAC_EVENT_MAC_STATS) {
+		struct umac_event_mac_stats  *mac_stats =
+			(struct umac_event_mac_stats *) buff;
+
+		uccp420wlan_mac_stats(mac_stats, p->context);
+	} else if (event == UMAC_EVENT_NW_FOUND) {
+		DEBUG_LOG("received event_found\n");
+	} else if (event == UMAC_EVENT_PHY_STAT) {
+		int i;
+#ifdef DRIVER_DEBUG
+		struct host_event_phy_stats *phy =
+			(struct host_event_phy_stats *)buff;
+#endif
+		DEBUG_LOG("received phy stats event\n");
+		DEBUG_LOG("phy stats are\n");
+
+		for (i = 0; i < 32; i++)
+			DEBUG_LOG("%x ", phy->phy_stats[i]);
+
+		DEBUG_LOG("\n\n\n");
+	} else if (event == UMAC_EVENT_NOA) {
+		uccp420wlan_noa_event(FROM_EVENT_NOA, (void *)buff,
+				      p->context, NULL);
+
+	} else if (event == UMAC_EVENT_COMMAND_PROC_DONE) {
+		/*struct host_event_command_complete *cmd =
+		 * (struct host_event_command_complete*)buff;
+		 */
+		DEBUG_LOG("Received  PROC_DONE\n");
+
+		spin_lock_irqsave(&cmd_info.control_path_lock, irq_flags);
+
+		if (cmd_info.outstanding_ctrl_req == 0) {
+			pr_err("%s-UMACIF: Unexpected: Spurious proc_done received. Ignoring and continuing\n",
+			       p->name);
+		} else {
+			cmd_info.outstanding_ctrl_req--;
+
+			DEBUG_LOG("After DEC: outstanding cmd: %d\n",
+				     cmd_info.outstanding_ctrl_req);
+
+			pending_cmd = skb_dequeue(&cmd_info.outstanding_cmd);
+
+			if (unlikely(pending_cmd != NULL)) {
+				DEBUG_LOG("Send 1 outstanding cmd\n");
+				hal_ops.send((void *)pending_cmd, HOST_MOD_ID,
+					     UMAC_MOD_ID, 0);
+				dev->stats->gen_cmd_send_count++;
+			}
+		}
+		spin_unlock_irqrestore(&cmd_info.control_path_lock, irq_flags);
+
+	} else if (event == UMAC_EVENT_CH_PROG_DONE) {
+		uccp420wlan_ch_prog_complete(event,
+			(struct umac_event_ch_prog_complete *)buff, p->context);
+	} else if (event == UMAC_EVENT_RF_CALIB_DATA) {
+		struct umac_event_rf_calib_data  *rf_data = (void *) buff;
+		uccp420wlan_rf_calib_data(rf_data, p->context);
+	} else {
+		pr_warn("%s: Unknown event received %d\n", __func__, event);
+	}
+
+	if (event != UMAC_EVENT_RX)
+		dev_kfree_skb_any(skb);
+
+	rcu_read_unlock();
+
+	return 0;
+}
+
+
+int uccp420wlan_lmac_if_init(void *context, const char *name)
+{
+	struct lmac_if_data *p;
+
+	DEBUG_LOG("%s-UMACIF: lmac_if init called\n", name);
+
+	p = kzalloc(sizeof(struct lmac_if_data), GFP_KERNEL);
+
+	if (!p)
+		return -ENOMEM;
+
+	p->name = (char *)name;
+	p->context = context;
+	hal_ops.register_callback(uccp420wlan_msg_handler, UMAC_MOD_ID);
+	rcu_assign_pointer(lmac_if, p);
+	skb_queue_head_init(&cmd_info.outstanding_cmd);
+	spin_lock_init(&cmd_info.control_path_lock);
+	cmd_info.outstanding_ctrl_req = 0;
+
+	return 0;
+}
+
+
+void uccp420wlan_lmac_if_deinit(void)
+{
+	struct lmac_if_data *p;
+
+	DEBUG_LOG("%s-UMACIF: Deinit called\n", lmac_if->name);
+
+	p = rcu_dereference(lmac_if);
+	rcu_assign_pointer(lmac_if, NULL);
+	synchronize_rcu();
+	kfree(p);
+}
+
+
+void uccp420_lmac_if_free_outstnding(void)
+{
+
+	struct sk_buff *skb;
+
+	/* First free the outstanding commands, we are not sending
+	 * anymore commands to the FW except RESET.
+	 */
+	while ((skb = __skb_dequeue(&cmd_info.outstanding_cmd)))
+		dev_kfree_skb_any(skb);
+
+	cmd_info.outstanding_ctrl_req = 0;
+}
-- 
1.9.1

