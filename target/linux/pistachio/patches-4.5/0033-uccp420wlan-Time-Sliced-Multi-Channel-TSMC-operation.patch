From 293a38c6e8dfeba6db73743a6ce730d28ac13d6f Mon Sep 17 00:00:00 2001
From: sridhar nuvusetty <Sridhar.Nuvusetty@imgtec.com>
Date: Fri, 3 Jul 2015 16:30:33 +0530
Subject: uccp420wlan: Time Sliced Multi Channel (TSMC) operation changes

This commit adds the Time Sliced Multi Channel (TSMC) operation support to
WiFi. With this feature we can now support simultaneous operation on two
different channels.

Change-Id: Iad116615604db7f5d1a3527685d29b7472e3cf69
Signed-off-by: Sridhar Nuvusetty <Sridhar.Nuvusetty@imgtec.com>
---
 .../bindings/uccp/uccp-img-pistachio.txt           |   73 ++
 drivers/net/wireless/uccp420wlan/Makefile          |    1 +
 drivers/net/wireless/uccp420wlan/inc/core.h        |   97 +-
 .../net/wireless/uccp420wlan/inc/host_umac_if.h    |   52 +-
 drivers/net/wireless/uccp420wlan/inc/umac_if.h     |   13 +
 drivers/net/wireless/uccp420wlan/inc/version.h     |    2 +-
 drivers/net/wireless/uccp420wlan/src/80211_if.c    |  421 +++++++-
 drivers/net/wireless/uccp420wlan/src/core.c        |  265 ++++-
 drivers/net/wireless/uccp420wlan/src/fwldr.c       |    9 +-
 .../net/wireless/uccp420wlan/src/hal_hostport.c    |   77 +-
 drivers/net/wireless/uccp420wlan/src/tx.c          | 1050 ++++++++++++++------
 drivers/net/wireless/uccp420wlan/src/umac_if.c     |  167 +++-
 12 files changed, 1780 insertions(+), 447 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/uccp/uccp-img-pistachio.txt

diff --git a/Documentation/devicetree/bindings/uccp/uccp-img-pistachio.txt b/Documentation/devicetree/bindings/uccp/uccp-img-pistachio.txt
new file mode 100644
index 0000000..9c9e721
--- /dev/null
+++ b/Documentation/devicetree/bindings/uccp/uccp-img-pistachio.txt
@@ -0,0 +1,73 @@
+IMG UCCP420 driver properties
+
+Required Properties:
+- compatible: "img,pistachio-uccp"
+- reg: RPU registers
+- reg-names : Should containt the names of the registers used by the driver
+- interrupts: Interrupt number used by the RPU
+- clocks : Should contain a clock specifier for each entry in clock-names
+- clock-names : Should contain the clock names used by the driver
+- io-channels : Names of the channels used by the driver
+
+Example:
+
+wifi: uccp@18480000 {
+	      status = "disabled";
+	      compatible = "img,pistachio-uccp";
+	      reg = <0x18480000 0x38000>, <0x184BC000 0x2800>, <0x1a000000 0x00066cc0>;
+	      reg-names = "uccp_core_base", "uccp_slave_base" , "uccp_pkd_gram_base";
+	      interrupts = <GIC_SHARED 67 IRQ_TYPE_LEVEL_HIGH>;
+	      interrupt-names = "uccpirq";
+	      clocks = <&clk_core CLK_RPU_CORE>,
+		     <&clk_core CLK_RPU_CORE_DIV>,
+		     <&clk_core CLK_RPU_V>,
+		     <&clk_core CLK_RPU_L>,
+		     <&clk_core CLK_RPU_SLEEP>,
+		     <&clk_core CLK_WIFI_PLL>,
+		     <&clk_core CLK_WIFI_ADC>,
+		     <&clk_core CLK_WIFI_DAC>,
+		     <&clk_core CLK_EVENT_TIMER>,
+		     <&cr_periph SYS_CLK_EVENT_TIMER>,
+		     <&clk_core CLK_AUX_ADC>,
+		     <&clk_core CLK_AUX_ADC_INTERNAL>;
+	      clock-names = "rpu_core", "rpu_core_div", "rpu_v", "rpu_l", "rpu_sleep",
+		      "wifi_pll", "wifi_adc", "wifi_dac", "event_timer",
+		      "sys_event_timer", "aux_adc", "aux_adc_internal";
+	      assigned-clocks = <&clk_core CLK_RPU_L_DIV>,
+		      <&clk_core CLK_RPU_L_MUX>,
+		      <&clk_core CLK_RPU_L_PLL_MUX>,
+		      <&clk_core CLK_RPU_V_DIV>,
+		      <&clk_core CLK_RPU_V_PLL_MUX>,
+		      <&clk_core CLK_RPU_CORE_DIV>,
+		      <&clk_core CLK_WIFI_PLL_MUX>,
+		      <&clk_core CLK_WIFI_DIV4_MUX>,
+		      <&clk_core CLK_WIFI_DIV8_MUX>,
+		      <&clk_core CLK_RPU_SLEEP_DIV>,
+		      <&clk_core CLK_WIFI_PLL>,
+		      <&clk_core CLK_RPU_CORE>;
+	      assigned-clock-parents = <0>,
+		      <&clk_core CLK_RPU_L_PLL_MUX>,
+		      <&clk_core CLK_RPU_L_PLL>,
+		      <0>,
+		      <&clk_core CLK_RPU_V_PLL>,
+		      <0>,
+		      <&clk_core CLK_WIFI_PLL>,
+		      <&clk_core CLK_WIFI_DIV4>,
+		      <&clk_core CLK_WIFI_DIV8>,
+		      <0>,
+		      <0>,
+		      <0>;
+	      assigned-clock-rates = <559000000>,
+		      <0>,
+		      <0>,
+		      <598000000>,
+		      <0>,
+		      <320000000>,
+		      <0>,
+		      <0>,
+		      <0>,
+		      <52000>,
+		      <320000000>,
+		      <320000000>;
+	      io-channels = <&adc 4>, <&adc 5>;
+      };
diff --git a/drivers/net/wireless/uccp420wlan/Makefile b/drivers/net/wireless/uccp420wlan/Makefile
index e142a9b..d9d0c16 100644
--- a/drivers/net/wireless/uccp420wlan/Makefile
+++ b/drivers/net/wireless/uccp420wlan/Makefile
@@ -1,4 +1,5 @@
 uccp420wlan-objs		:= src/80211_if.o src/core.o src/umac_if.o src/tx.o src/hal_hostport.o src/fwldr.o
+ccflags-y += -DMULTI_CHAN_SUPPORT
 obj-$(CONFIG_UCCP420WLAN)	+= uccp420wlan.o
 ccflags-y += -I$(src)/inc
 
diff --git a/drivers/net/wireless/uccp420wlan/inc/core.h b/drivers/net/wireless/uccp420wlan/inc/core.h
index 82bb9ef..e0ef584 100644
--- a/drivers/net/wireless/uccp420wlan/inc/core.h
+++ b/drivers/net/wireless/uccp420wlan/inc/core.h
@@ -42,6 +42,7 @@
 #include <linux/atomic.h>
 #include <linux/etherdevice.h>
 
+#include "host_umac_if.h"
 #include "umac_if.h"
 #include "descriptors.h"
 
@@ -67,6 +68,7 @@ extern spinlock_t tsf_lock;
 #define DEBUG_LOG(...) do { } while (0)
 #endif
 
+
 #define MAX_OUTSTANDING_CTRL_REQ 2
 #define RESET_TIMEOUT 5000   /* In milli-seconds*/
 #define RESET_TIMEOUT_TICKS msecs_to_jiffies(RESET_TIMEOUT)
@@ -85,7 +87,6 @@ extern spinlock_t tsf_lock;
 #define SCAN_ABORT_TIMEOUT_TICKS msecs_to_jiffies(SCAN_ABORT_TIMEOUT)
 
 
-#define MAX_VIFS 2
 #define DEFAULT_TX_ANT_SELECT 3 /* bitmap of antennas for tx, 3=> both first and
 				 * second antenna to be used
 				 */
@@ -104,9 +105,8 @@ extern spinlock_t tsf_lock;
 #define   MAX_RSSI_SAMPLES 10
 
 #define CLOCK_MASK 0x3FFFFFFF
-#define TICK_NUMRATOR 1000 /* 1 MHz */
-#define TICK_DENOMINATOR 12288 /* 12288000 Hz */
-
+#define TICK_NUMRATOR 12288 /* 12288 KHz  */
+#define TICK_DENOMINATOR 1000 /* 1000 KHz */
 
 enum noa_triggers {
 	FROM_TX = 0,
@@ -376,6 +376,14 @@ struct wifi_stats {
 	unsigned char rf_calib_data[MAX_RF_CALIB_DATA];
 };
 
+
+struct tx_pkt_info {
+	struct sk_buff_head pkt;
+	unsigned int hdr_len;
+	unsigned int queue;
+};
+
+
 struct tx_config {
 	/* Used to protect the TX pool */
 	spinlock_t lock;
@@ -390,13 +398,24 @@ struct tx_config {
 	unsigned int next_spare_token_ac;
 
 	/* Used to store the address of pending skbs per ac */
-	struct sk_buff_head pending_pkt[NUM_ACS];
+	struct sk_buff_head pending_pkt[MAX_PEND_Q_PER_AC][NUM_ACS];
+
+#ifdef MULTI_CHAN_SUPPORT
+	/* Peer which has the opportunity to xmit next on a queue */
+	unsigned int curr_peer_opp[MAX_CHANCTX][NUM_ACS];
+#else
+	unsigned int curr_peer_opp[NUM_ACS];
+#endif
 
 	/* Used to store the address of tx'ed skb and len of 802.11 hdr
 	 * it will be used in tx complete.
 	 */
-	struct sk_buff_head tx_pkt[NUM_TX_DESCS];
-	unsigned int tx_pkt_hdr_len[NUM_TX_DESCS];
+#ifdef MULTI_CHAN_SUPPORT
+	unsigned char desc_chan_map[NUM_TX_DESCS];
+	struct tx_pkt_info pkt_info[MAX_CHANCTX][NUM_TX_DESCS];
+#else
+	struct tx_pkt_info pkt_info[NUM_TX_DESCS];
+#endif
 
 	unsigned int queue_stopped_bmp;
 	struct sk_buff_head proc_tx_list[NUM_TX_DESCS];
@@ -444,6 +463,7 @@ struct roc_params {
 	unsigned char roc_chan_changed;
 	atomic_t roc_mgmt_tx_count;
 };
+
 struct mac80211_dev {
 	struct proc_dir_entry *umac_proc_dir_entry;
 	struct device *dev;
@@ -478,6 +498,7 @@ struct mac80211_dev {
 			 * STA mode is active
 			 */
 	struct ieee80211_vif *vifs[MAX_VIFS];
+	struct ieee80211_sta *peers[MAX_PEERS];
 	struct ieee80211_hw *hw;
 	struct sta_tid_info  tid_info[32];
 	spinlock_t bcast_lock; /* Used to ensure more_frames bit is set properly
@@ -487,6 +508,12 @@ struct mac80211_dev {
 	unsigned char tx_antenna;
 	unsigned char tx_last_beacon;
 	unsigned int rts_threshold;
+#ifdef MULTI_CHAN_SUPPORT
+	spinlock_t chanctx_lock;
+	struct ieee80211_chanctx_conf *chanctx[MAX_CHANCTX];
+	int curr_chanctx_idx;
+	int num_active_chanctx;
+#endif
 };
 
 struct edca_params {
@@ -521,13 +548,39 @@ struct umac_vif {
 
 	/*Global Sequence no for non-qos and mgmt frames/vif*/
 	__u16 seq_no;
+
+#ifdef MULTI_CHAN_SUPPORT
+	struct list_head list;
+	struct umac_chanctx *chanctx;
+#endif
 };
 
+struct umac_sta {
+	int index;
+#ifdef MULTI_CHAN_SUPPORT
+	struct umac_chanctx *chanctx;
+#endif
+};
+
+#ifdef MULTI_CHAN_SUPPORT
+struct umac_chanctx {
+	int index;
+
+	struct list_head vifs;
+	short nvifs;
+};
+
+#endif
+
 
 extern int wait_for_scan_abort(struct mac80211_dev *dev);
 extern int wait_for_channel_prog_complete(struct mac80211_dev *dev);
 extern int uccp420wlan_prog_nw_selection(unsigned int nw_select_enabled,
 					 unsigned char *mac_addr);
+#ifdef MULTI_CHAN_SUPPORT
+void uccp420wlan_proc_ch_sw_event(struct umac_event_ch_switch *ch_sw_info,
+				  void *context);
+#endif
 extern int  uccp420wlan_core_init(struct mac80211_dev *dev, unsigned int ftm);
 extern void uccp420wlan_core_deinit(struct mac80211_dev *dev, unsigned int ftm);
 extern void uccp420wlan_vif_add(struct umac_vif  *uvif);
@@ -539,8 +592,20 @@ extern void uccp420wlan_vif_set_edca_params(unsigned short queue,
 extern void uccp420wlan_vif_bss_info_changed(struct umac_vif *uvif,
 					     struct ieee80211_bss_conf
 					     *bss_conf, unsigned int changed);
-extern int  uccp420wlan_tx_frame(struct sk_buff *skb, struct ieee80211_sta *sta,
-				 struct mac80211_dev *dev, bool bcast);
+extern int  uccp420wlan_tx_frame(struct sk_buff *skb,
+				 struct ieee80211_sta *sta,
+				 struct mac80211_dev *dev,
+#ifdef MULTI_CHAN_SUPPORT
+				 int curr_chanctx_idx,
+#endif
+				 bool bcast);
+extern int __uccp420wlan_tx_frame(struct mac80211_dev *dev,
+				  unsigned int queue,
+				  unsigned int token_id,
+#ifdef MULTI_CHAN_SUPPORT
+				  int curr_chanctx_idx,
+#endif
+				  unsigned int more_frames);
 extern void uccp420wlan_tx_init(struct mac80211_dev *dev);
 extern void uccp420wlan_tx_deinit(struct mac80211_dev *dev);
 
@@ -548,6 +613,19 @@ extern void proc_bss_info_changed(unsigned char *mac_addr, int value);
 extern void packet_generation(unsigned long data);
 extern int wait_for_reset_complete(struct mac80211_dev *dev);
 
+extern void uccp420wlan_tx_proc_pend_frms(struct mac80211_dev *dev,
+				   int queue,
+#ifdef MULTI_CHAN_SUPPORT
+				   int curr_chanctx_idx,
+#endif
+				   int peer_id,
+				   int token_id);
+int get_curr_peer_opp(struct mac80211_dev *dev,
+#ifdef MULTI_CHAN_SUPPORT
+		      int curr_chanctx_idx,
+#endif
+		      int queue);
+
 /* Beacon TimeStamp */
 __s32 __attribute__((weak)) frc_to_atu(__u32 frccnt, __u64 *patu, s32 dir);
 int __attribute__((weak)) get_evt_timer_freq(unsigned int *mask,
@@ -561,6 +639,7 @@ static inline int vif_addr_to_index(unsigned char *addr,
 				    struct mac80211_dev *dev)
 {
 	int i;
+
 	for (i = 0; i < MAX_VIFS; i++)
 		if (ether_addr_equal(addr, dev->if_mac_addresses[i].addr))
 			break;
diff --git a/drivers/net/wireless/uccp420wlan/inc/host_umac_if.h b/drivers/net/wireless/uccp420wlan/inc/host_umac_if.h
index 86343fe..c142450 100644
--- a/drivers/net/wireless/uccp420wlan/inc/host_umac_if.h
+++ b/drivers/net/wireless/uccp420wlan/inc/host_umac_if.h
@@ -31,6 +31,17 @@
 #define TKIP_MIC_LEN 8
 #define MICHAEL_LEN 16
 #define MAX_KEY_LEN 16
+#define MAX_VIFS 2
+
+#define MAX_PEERS 3
+/* Additional queue for unicast frames directed to non-associated peers (for
+ * e.g. Probe Responses etc)
+ */
+#define MAX_PEND_Q_PER_AC (MAX_PEERS + MAX_VIFS)
+
+#ifdef MULTI_CHAN_SUPPORT
+#define MAX_CHANCTX 2
+#endif
 
 #define WEP40_KEYLEN 5
 #define WEP104_KEYLEN 13
@@ -100,6 +111,9 @@ struct umac_event_tx_done {
 #define TX_DONE_STAT_KEY_NOT_FOUND (3)
 #define TX_DONE_STAT_DISCARD (4)
 #define TX_DONE_STAT_DISCARD_BCN (5)
+#ifdef MULTI_CHAN_SUPPORT
+#define TX_DONE_STAT_DISCARD_CHSW (6)
+#endif
 	unsigned char frm_status[MAX_TX_CMDS];
 	unsigned char retries_num[MAX_TX_CMDS];
 	/* rate = Units of 500 Kbps or mcs index = 0 to 7*/
@@ -113,6 +127,13 @@ struct umac_event_ch_prog_complete {
 	struct host_mac_msg_hdr hdr;
 } __packed;
 
+#ifdef MULTI_CHAN_SUPPORT
+struct umac_event_ch_switch {
+	struct host_mac_msg_hdr hdr;
+	int chan;
+} __packed;
+#endif
+
 struct umac_event_noa {
 	struct host_mac_msg_hdr hdr;
 	unsigned int if_index;
@@ -289,7 +310,13 @@ struct wlan_rx_pkt {
 	unsigned char ldpc_enabled;
 	unsigned char link_margin;
 	unsigned char channel;
-	unsigned char reserved[14];
+/* Currently size of reserved =
+ * sizeof(beacon_time_stamp = 8) +
+ * sizeof(ets_timer = 4) +
+ * sizeof(delta_timer_diff = 4) +
+ * (qos_padding = 2)
+ */
+	unsigned char reserved[18];
 	/*payload bytes */
 	unsigned char payload[0];
 } __packed;
@@ -350,7 +377,10 @@ enum UMAC_CMD_TAG {
 	UMAC_CMD_DISCARD_PKTS,
 	UMAC_CMD_MEASURE,
 	UMAC_CMD_BT_INFO,
-	UMAC_CMD_CLEAR_STATS
+	UMAC_CMD_CLEAR_STATS,
+#ifdef MULTI_CHAN_SUPPORT
+	UMAC_CMD_CHANCTX_TIME_INFO,
+#endif
 };
 
 enum UMAC_EVENT_TAG {
@@ -379,6 +409,9 @@ enum UMAC_EVENT_TAG {
 	UMAC_EVENT_RF_CALIB_DATA,
 	UMAC_EVENT_RADAR_DETECTED,
 	UMAC_EVENT_MSRMNT_COMPLETE,
+#ifdef MULTI_CHAN_SUPPORT
+	UMAC_EVENT_CHAN_SWITCH,
+#endif
 };
 
 enum CONNECT_RESULT_TAG {
@@ -735,6 +768,9 @@ struct cmd_channel {
 	 * 1 - 5ghz
 	 */
 	unsigned int freq_band;
+#ifdef MULTI_CHAN_SUPPORT
+	unsigned int vif_index;
+#endif
 } __packed;
 
 struct cmd_vif_cfg {
@@ -902,6 +938,18 @@ struct cmd_msrmnt_start {
 } __packed;
 
 
+#ifdef MULTI_CHAN_SUPPORT
+struct chanctx_time_info {
+	int chan;
+	int percentage;
+};
+
+struct cmd_chanctx_time_config {
+	struct host_mac_msg_hdr hdr;
+	struct chanctx_time_info info[MAX_CHANCTX];
+} __packed;
+#endif
+
 /* Events */
 
 struct nw_found_event {
diff --git a/drivers/net/wireless/uccp420wlan/inc/umac_if.h b/drivers/net/wireless/uccp420wlan/inc/umac_if.h
index 3676c63..6a75385 100644
--- a/drivers/net/wireless/uccp420wlan/inc/umac_if.h
+++ b/drivers/net/wireless/uccp420wlan/inc/umac_if.h
@@ -83,6 +83,9 @@ extern int uccp420wlan_proc_tx(void);
 
 extern int uccp420wlan_prog_tx(unsigned int queue,
 			       unsigned int more_data,
+#ifdef MULTI_CHAN_SUPPORT
+			       int curr_chanctx_idx,
+#endif
 			       unsigned int tokenid);
 
 extern int uccp420wlan_sta_add(int index,
@@ -193,6 +196,9 @@ extern int uccp420wlan_prog_channel(unsigned int prim_ch,
 				    unsigned int ch_no1,
 				    unsigned int ch_no2,
 				    unsigned int ch_width,
+#ifdef MULTI_CHAN_SUPPORT
+				    unsigned int vif_index,
+#endif
 				    unsigned int freq_band);
 
 extern int uccp420wlan_prog_peer_key(int index,
@@ -251,6 +257,9 @@ extern void uccp420wlan_proc_tx_complete(struct umac_event_tx_done *txdone,
 				    void *context);
 
 extern void uccp420wlan_tx_complete(struct umac_event_tx_done *txdone,
+#ifdef MULTI_CHAN_SUPPORT
+				    int curr_chanctx_idx,
+#endif
 				    void *context);
 
 extern void uccp420wlan_rx_frame(struct sk_buff *skb,
@@ -280,6 +289,10 @@ extern void uccp420wlan_lmac_if_deinit(void);
 
 extern void uccp420_lmac_if_free_outstnding(void);
 
+#ifdef MULTI_CHAN_SUPPORT
+extern int uccp420wlan_prog_chanctx_time_info(void);
+#endif
+
 #endif /* _UCCP420WLAN_UMAC_IF_H_ */
 
 /* EOF */
diff --git a/drivers/net/wireless/uccp420wlan/inc/version.h b/drivers/net/wireless/uccp420wlan/inc/version.h
index 53a92ff..fb545e9 100644
--- a/drivers/net/wireless/uccp420wlan/inc/version.h
+++ b/drivers/net/wireless/uccp420wlan/inc/version.h
@@ -23,7 +23,7 @@
  */
 #ifndef _UCCP420WLAN_VERSION_H
 #define _UCCP420WLAN_VERSION_H
-#define UCCP_DRIVER_VERSION "4_5_4"
+#define UCCP_DRIVER_VERSION "4_5_6"
 #define UCCP_DRIVER_NAME "UCCP420WIFI"
 #endif /* _UCCP420WLAN_VERSION_H */
 
diff --git a/drivers/net/wireless/uccp420wlan/src/80211_if.c b/drivers/net/wireless/uccp420wlan/src/80211_if.c
index e04367c..1e75587 100644
--- a/drivers/net/wireless/uccp420wlan/src/80211_if.c
+++ b/drivers/net/wireless/uccp420wlan/src/80211_if.c
@@ -200,6 +200,12 @@ static const struct ieee80211_iface_limit if_limit4[] = {
 		{ .max = 1, .types = BIT(NL80211_IFTYPE_P2P_CLIENT)}
 };
 
+#ifdef MULTI_CHAN_SUPPORT
+static const struct ieee80211_iface_limit if_limit5[] = {
+		{ .max = 1, .types = BIT(NL80211_IFTYPE_STATION)},
+		{ .max = 1, .types = BIT(NL80211_IFTYPE_AP)}
+};
+#endif
 
 static const struct ieee80211_iface_combination if_comb[] = {
 	{ .limits = if_limit1,
@@ -214,6 +220,12 @@ static const struct ieee80211_iface_combination if_comb[] = {
 	  .n_limits = ARRAY_SIZE(if_limit3),
 	  .max_interfaces = 2,
 	  .num_different_channels = 1},
+#ifdef MULTI_CHAN_SUPPORT
+	{ .limits = if_limit5,
+	  .n_limits = ARRAY_SIZE(if_limit5),
+	  .max_interfaces = 2,
+	  .num_different_channels = 2},
+#endif
 	{ .limits = if_limit4,
 	  .n_limits = ARRAY_SIZE(if_limit4),
 	  .max_interfaces = 2,
@@ -275,6 +287,9 @@ static void tx(struct ieee80211_hw *hw,
 	unsigned char *pktgen_magic;
 	unsigned int orig_pktgen_magic = 0x55e99bbe; /*Endianness 0xbe9be955*/
 	struct umac_event_noa noa_event;
+#ifdef MULTI_CHAN_SUPPORT
+	int curr_chanctx_idx = -1;
+#endif
 
 	if (tx_info->control.vif == NULL) {
 		pr_debug("%s: Dropping injected TX frame\n",
@@ -323,14 +338,26 @@ static void tx(struct ieee80211_hw *hw,
 		return;
 	}
 
-	uccp420wlan_tx_frame(skb, txctl->sta, dev, false);
+#ifdef MULTI_CHAN_SUPPORT
+	spin_lock_bh(&dev->chanctx_lock);
+	curr_chanctx_idx = dev->curr_chanctx_idx;
+	spin_unlock_bh(&dev->chanctx_lock);
+#endif
+
+	uccp420wlan_tx_frame(skb,
+			     txctl->sta,
+			     dev,
+#ifdef MULTI_CHAN_SUPPORT
+			     curr_chanctx_idx,
+#endif
+			     false);
+
 	return;
 
 tx_status:
 	tx_info->flags |= IEEE80211_TX_STAT_ACK;
 	tx_info->status.rates[0].count = 1;
 	ieee80211_tx_status(hw, skb);
-	return;
 }
 
 static int start(struct ieee80211_hw *hw)
@@ -352,7 +379,7 @@ static int start(struct ieee80211_hw *hw)
 	}
 	INIT_DELAYED_WORK(&dev->roc_complete_work, uccp420_roc_complete_work);
 	dev->state = STARTED;
-	memset(dev->params->pdout_voltage, 0 ,
+	memset(dev->params->pdout_voltage, 0,
 	       sizeof(char) * MAX_AUX_ADC_SAMPLES);
 	mutex_unlock(&dev->mutex);
 
@@ -401,9 +428,19 @@ static int add_interface(struct ieee80211_hw *hw,
 			return -EBUSY;
 		}
 	}
+
 	for (vif_index = 0; vif_index < wifi->params.num_vifs; vif_index++)
-		if (dev->if_mac_addresses[vif_index].addr[5] == vif->addr[5])
+		if (memcmp(dev->if_mac_addresses[vif_index].addr,
+			   vif->addr,
+			   ETH_ALEN) == 0)
 			break;
+
+	if (vif_index == wifi->params.num_vifs) {
+		pr_err("Failed to lookup vif_index\n");
+		mutex_unlock(&dev->mutex);
+		return -EINVAL;
+	}
+
 	uvif = (struct umac_vif *)&v->drv_priv;
 	uvif->vif_index = vif_index;
 	uvif->vif = v;
@@ -429,6 +466,7 @@ static void remove_interface(struct ieee80211_hw *hw,
 	struct mac80211_dev    *dev = hw->priv;
 	struct ieee80211_vif *v;
 	int vif_index;
+
 	v = vif;
 	vif_index = ((struct umac_vif *)&v->drv_priv)->vif_index;
 
@@ -541,8 +579,14 @@ static int config(struct ieee80211_hw *hw,
 		dev->cur_chan.freq_band = freq_band;
 
 		dev->chan_prog_done = 0;
-		uccp420wlan_prog_channel(pri_chnl_num, chnl_num1, chnl_num2,
-					 ch_width, freq_band);
+		uccp420wlan_prog_channel(pri_chnl_num,
+					 chnl_num1,
+					 chnl_num2,
+					 ch_width,
+#ifdef MULTI_CHAN_SUPPORT
+					 0,
+#endif
+					 freq_band);
 	}
 
 	/* Check for change in Power save state */
@@ -682,6 +726,7 @@ static void configure_filter(struct ieee80211_hw *hw,
 		u64 mc_count)
 {
 	struct mac80211_dev *dev = hw->priv;
+
 	mutex_lock(&dev->mutex);
 
 	changed_flags &= SUPPORTED_FILTERS;
@@ -728,7 +773,6 @@ out:
 	}
 
 	mutex_unlock(&dev->mutex);
-	return;
 }
 
 
@@ -742,9 +786,16 @@ static int conf_vif_tx(struct ieee80211_hw  *hw,
 	struct edca_params params;
 
 	for (vif_index = 0; vif_index < wifi->params.num_vifs; vif_index++)
-		if (dev->if_mac_addresses[vif_index].addr[5] == vif->addr[5])
+		if (memcmp(dev->if_mac_addresses[vif_index].addr,
+			   vif->addr,
+			   ETH_ALEN) == 0)
 			break;
 
+	if (vif_index == wifi->params.num_vifs) {
+		pr_err("Failed to lookup vif_index\n");
+		return -EINVAL;
+	}
+
 	vif_active = 0;
 
 	if ((dev->active_vifs & (1 << vif_index)))
@@ -780,6 +831,7 @@ static int set_key(struct ieee80211_hw *hw,
 	unsigned int cipher_type, key_type;
 	int vif_index;
 	struct umac_vif *uvif;
+
 	uvif = ((struct umac_vif *)&vif->drv_priv);
 
 	memset(&sec_key, 0, sizeof(struct umac_key));
@@ -996,8 +1048,9 @@ static void bss_info_changed(struct ieee80211_hw *hw,
 	mutex_lock(&dev->mutex);
 
 	if (wifi->params.production_test || wifi->params.disable_beacon_ibss) {
-		/*Disable beacon generation when running pktgen
-		 *for performance*/
+		/* Disable beacon generation when running pktgen
+		 * for performance
+		 */
 		changed &= ~BSS_CHANGED_BEACON_INT;
 		changed &= ~BSS_CHANGED_BEACON_ENABLED;
 	}
@@ -1006,14 +1059,13 @@ static void bss_info_changed(struct ieee80211_hw *hw,
 					 bss_conf,
 					 changed);
 	mutex_unlock(&dev->mutex);
-
-	return;
 }
 
 
 static void setup_ht_cap(struct ieee80211_sta_ht_cap *ht_info)
 {
 	int i;
+
 	memset(ht_info, 0, sizeof(*ht_info));
 	ht_info->ht_supported = true;
 	pr_info("SETUP HT CALLED\n");
@@ -1152,6 +1204,10 @@ static void init_hw(struct ieee80211_hw *hw)
 	/* Size */
 	hw->extra_tx_headroom = 0;
 	hw->vif_data_size = sizeof(struct umac_vif);
+	hw->sta_data_size = sizeof(struct umac_sta);
+#ifdef MULTI_CHAN_SUPPORT
+	hw->chanctx_data_size = sizeof(struct umac_chanctx);
+#endif
 
 	if (wifi->params.dot11g_support) {
 		hw->wiphy->bands[IEEE80211_BAND_2GHZ] = &band_2ghz;
@@ -1184,7 +1240,7 @@ static void init_hw(struct ieee80211_hw *hw)
 		/* SMPS Support both Static and Dynamic */
 		hw->wiphy->features |= NL80211_FEATURE_STATIC_SMPS;
 		hw->wiphy->features |= NL80211_FEATURE_DYNAMIC_SMPS;
-        }
+	}
 
 #ifdef CONFIG_PM
 	hw->wiphy->wowlan = &uccp_wowlan_support;
@@ -1319,6 +1375,9 @@ static void uccp420_roc_complete_work(struct work_struct *work)
 					 dev->cur_chan.chnl_num1,
 					 dev->cur_chan.chnl_num2,
 					 dev->cur_chan.ch_width,
+#ifdef MULTI_CHAN_SUPPORT
+					 0,
+#endif
 					 dev->cur_chan.freq_band);
 
 		if (wait_for_channel_prog_complete(dev)) {
@@ -1365,6 +1424,9 @@ static int remain_on_channel(struct ieee80211_hw *hw,
 	unsigned int chnl_num2 = 0;
 	unsigned int freq_band = channel->band;
 	unsigned int ch_width = 0; /* 20MHz */
+#ifdef MULTI_CHAN_SUPPORT
+	struct umac_vif *uvif = (struct umac_vif *)vif->drv_priv;
+#endif
 
 	pri_chnl_num = ieee80211_frequency_to_channel(channel->center_freq);
 	chnl_num1 = ieee80211_frequency_to_channel(channel->center_freq);
@@ -1408,7 +1470,11 @@ static int remain_on_channel(struct ieee80211_hw *hw,
 		uccp420wlan_prog_channel(pri_chnl_num,
 					 chnl_num1,
 					 chnl_num2,
-					 ch_width, freq_band);
+					 ch_width,
+#ifdef MULTI_CHAN_SUPPORT
+					 uvif->vif_index,
+#endif
+					 freq_band);
 
 		if (!wait_for_channel_prog_complete(dev)) {
 			dev->roc_params.roc_chan_changed = 1;
@@ -1666,8 +1732,9 @@ int scan(struct ieee80211_hw *hw,
 	struct scan_req scan_req = {0};
 	int i = 0;
 
-        struct cfg80211_scan_request *req;
-        req = &ireq->req;
+	struct cfg80211_scan_request *req;
+
+	req = &ireq->req;
 
 	scan_req.n_ssids = req->n_ssids;
 	scan_req.n_channels = req->n_channels;
@@ -1796,6 +1863,8 @@ int set_rts_threshold(struct ieee80211_hw *hw,
 	return 0;
 
 }
+
+
 int sta_add(struct ieee80211_hw *hw,
 	    struct ieee80211_vif *vif,
 	    struct ieee80211_sta *sta)
@@ -1803,9 +1872,28 @@ int sta_add(struct ieee80211_hw *hw,
 	struct umac_vif *uvif = (struct umac_vif *)vif->drv_priv;
 	struct peer_sta_info peer_st_info = {0};
 	int i;
+	int result = 0;
+	struct mac80211_dev *dev = hw->priv;
+	struct umac_sta *usta = (struct umac_sta *)sta->drv_priv;
+	unsigned int peer_id = 0;
+
+	for (i = 0; i < MAX_PEERS; i++) {
+		if (!dev->peers[i]) {
+			peer_id = i;
+			break;
+		}
+	}
+
+	if (i == MAX_PEERS) {
+		pr_err("Exceeded Max STA limit(%d)\n", MAX_PEERS);
+		return -1;
+	}
+
+
 	for (i = 0; i < STA_NUM_BANDS; i++)
 		peer_st_info.supp_rates[i] = sta->supp_rates[i];
-	/*HT info*/
+
+	/* HT info */
 	peer_st_info.ht_cap = sta->ht_cap.cap;
 	peer_st_info.ht_supported = sta->ht_cap.ht_supported;
 	peer_st_info.vht_supported = sta->vht_cap.vht_supported;
@@ -1816,7 +1904,7 @@ int sta_add(struct ieee80211_hw *hw,
 	peer_st_info.tx_params = sta->ht_cap.mcs.tx_params;
 	peer_st_info.uapsd_queues = sta->uapsd_queues;
 
-	/* will be used in enforcing rules during Aggregation*/
+	/* Will be used in enforcing rules during Aggregation */
 	uvif->peer_ampdu_factor = (1 << (13 + sta->ht_cap.ampdu_factor)) - 1;
 
 	if (sta->vht_cap.vht_supported) {
@@ -1824,14 +1912,29 @@ int sta_add(struct ieee80211_hw *hw,
 			uvif->dev->params->vht_beamform_support = 1;
 
 	}
+
 	for (i = 0; i < HT_MCS_MASK_LEN; i++)
 		peer_st_info.rx_mask[i] = sta->ht_cap.mcs.rx_mask[i];
 
 	for (i = 0; i < ETH_ALEN; i++)
 		peer_st_info.addr[i] = sta->addr[i];
 
-	return uccp420wlan_sta_add(uvif->vif_index, &peer_st_info);
+	result = uccp420wlan_sta_add(uvif->vif_index, &peer_st_info);
+
+	if (!result) {
+		rcu_assign_pointer(dev->peers[peer_id], sta);
+		synchronize_rcu();
+
+		usta->index = peer_id;
+#ifdef MULTI_CHAN_SUPPORT
+		usta->chanctx = uvif->chanctx;
+#endif
+	}
+
+	return result;
 }
+
+
 int sta_remove(struct ieee80211_hw *hw,
 	       struct ieee80211_vif *vif,
 	       struct ieee80211_sta *sta)
@@ -1839,12 +1942,26 @@ int sta_remove(struct ieee80211_hw *hw,
 	struct umac_vif *uvif = (struct umac_vif *)vif->drv_priv;
 	struct peer_sta_info peer_st_info = {0};
 	int i;
+	int result = 0;
+	struct mac80211_dev *dev = hw->priv;
+	struct umac_sta *usta = (struct umac_sta *)sta->drv_priv;
+
 	for (i = 0; i < ETH_ALEN; i++)
 		peer_st_info.addr[i] = sta->addr[i];
 
-	return uccp420wlan_sta_remove(uvif->vif_index, &peer_st_info);
+	result = uccp420wlan_sta_remove(uvif->vif_index, &peer_st_info);
+
+	if (!result) {
+		rcu_assign_pointer(dev->peers[usta->index], NULL);
+		synchronize_rcu();
+
+		usta->index = -1;
+	}
+
+	return result;
 }
 
+
 static int load_fw(struct ieee80211_hw *hw)
 {
 	int err = 0;
@@ -1881,6 +1998,222 @@ static int load_fw(struct ieee80211_hw *hw)
 }
 
 
+#ifdef MULTI_CHAN_SUPPORT
+static void umac_chanctx_set_channel(struct mac80211_dev *dev,
+				     struct umac_vif *uvif,
+				     struct cfg80211_chan_def *chandef)
+{
+	unsigned int pri_chan = 0;
+	unsigned int chan1 = 0;
+	unsigned int chan2 = 0;
+	unsigned int freq_band = 0;
+	unsigned int ch_width = 0;
+	int center_freq = 0;
+	int center_freq1 = 0;
+
+	center_freq = chandef->chan->center_freq;
+	center_freq1 = chandef->center_freq1;
+
+	pri_chan = ieee80211_frequency_to_channel(center_freq);
+	chan1 = ieee80211_frequency_to_channel(center_freq1);
+
+	freq_band = chandef->chan->band;
+	ch_width = chandef->width;
+
+	uccp420wlan_prog_channel(pri_chan,
+				 chan1,
+				 chan2,
+				 ch_width,
+				 uvif->vif_index,
+				 freq_band);
+}
+
+
+static int add_chanctx(struct ieee80211_hw *hw,
+		       struct ieee80211_chanctx_conf *conf)
+{
+	struct mac80211_dev *dev = NULL;
+	struct umac_chanctx *ctx = NULL;
+	int chanctx_id = 0;
+	int i = 0;
+
+	dev = hw->priv;
+
+
+	for (i = 0; i < MAX_CHANCTX; i++) {
+		if (!dev->chanctx[i]) {
+			chanctx_id = i;
+			break;
+		}
+	}
+
+	if (i == MAX_CHANCTX) {
+		pr_err("Exceeded Max chan contexts limit(%d)\n", MAX_CHANCTX);
+		return -1;
+	}
+
+	DEBUG_LOG("%s: %d MHz\n",
+			 __func__,
+			 conf->def.chan->center_freq);
+
+	mutex_lock(&dev->mutex);
+
+	ctx = (struct umac_chanctx *)conf->drv_priv;
+	ctx->index = chanctx_id;
+	INIT_LIST_HEAD(&ctx->vifs);
+	ctx->nvifs = 0;
+
+	rcu_assign_pointer(dev->chanctx[i], conf);
+	synchronize_rcu();
+
+	mutex_unlock(&dev->mutex);
+	return 0;
+}
+
+
+static void remove_chanctx(struct ieee80211_hw *hw,
+			   struct ieee80211_chanctx_conf *conf)
+{
+	struct mac80211_dev *dev = NULL;
+	struct umac_chanctx *ctx = NULL;
+
+	dev = hw->priv;
+	ctx = (struct umac_chanctx *)conf->drv_priv;
+
+	DEBUG_LOG("%s: %d MHz\n",
+			 __func__,
+			 conf->def.chan->center_freq);
+
+	mutex_lock(&dev->mutex);
+
+	/* Unassign_vif_chanctx should have been called to free all the assigned
+	 * vifs before this call is called, hence we dont need to specifically
+	 * free the vifs here
+	 */
+	rcu_assign_pointer(dev->chanctx[ctx->index], NULL);
+	synchronize_rcu();
+
+	ctx->index = -1;
+
+	mutex_unlock(&dev->mutex);
+}
+
+
+static void change_chanctx(struct ieee80211_hw *hw,
+			   struct ieee80211_chanctx_conf *conf,
+			   u32 changed)
+{
+#ifdef NOT_YET
+	struct umac_vif *uvif = NULL;
+	struct mac80211_dev *dev = NULL;
+	struct umac_chanctx *ctx = NULL;
+
+	dev = hw->priv;
+	ctx = (struct umac_chanctx *)conf->drv_priv;
+
+	DEBUG_LOG("%s: %d MHz\n",
+			 __func__,
+			 conf->def.chan->center_freq);
+
+	/* SDK: See why this is needed */
+	if (dev->curr_chanctx_idx != ctx->index) {
+		DEBUG_LOG("Current ctx differs from the new ctx\n");
+		return;
+	}
+
+	list_for_each_entry(uvif, &ctx->vifs, list)
+		umac_chanctx_set_channel(dev, uvif, &conf->def);
+#else
+	return;
+#endif
+}
+
+
+static int assign_vif_chanctx(struct ieee80211_hw *hw,
+			      struct ieee80211_vif *vif,
+			      struct ieee80211_chanctx_conf *conf)
+{
+	struct mac80211_dev *dev = NULL;
+	struct umac_vif *uvif = NULL;
+	struct umac_chanctx *ctx = NULL;
+	int prog_chanctx_time_info = 0;
+
+	dev = hw->priv;
+	uvif = (struct umac_vif *)vif->drv_priv;
+	ctx = (struct umac_chanctx *)conf->drv_priv;
+
+	DEBUG_LOG("%s: addr: %pM, type: %d, p2p: %d chan: %d MHz\n",
+			__func__,
+			vif->addr,
+			vif->type,
+			vif->p2p,
+			conf->def.chan->center_freq);
+
+	mutex_lock(&dev->mutex);
+
+	uvif->chanctx = ctx;
+	list_add_tail(&uvif->list, &ctx->vifs);
+
+	prog_chanctx_time_info = !(ctx->nvifs);
+	ctx->nvifs++;
+
+	/* If this is the first vif being assigned to the channel context then
+	 * increment our count of the active channel contexts
+	 */
+	if (prog_chanctx_time_info) {
+		if (!dev->num_active_chanctx)
+			dev->curr_chanctx_idx = ctx->index;
+
+		dev->num_active_chanctx++;
+		uccp420wlan_prog_chanctx_time_info();
+	}
+
+	umac_chanctx_set_channel(dev, uvif, &conf->def);
+
+	mutex_unlock(&dev->mutex);
+
+	return 0;
+}
+
+
+static void unassign_vif_chanctx(struct ieee80211_hw *hw,
+				 struct ieee80211_vif *vif,
+				 struct ieee80211_chanctx_conf *conf)
+{
+	struct mac80211_dev *dev = NULL;
+	struct umac_vif *uvif = NULL;
+	struct umac_chanctx *ctx = NULL;
+
+	dev = hw->priv;
+	uvif = (struct umac_vif *)vif->drv_priv;
+	ctx = (struct umac_chanctx *)conf->drv_priv;
+
+	DEBUG_LOG("%s: addr: %pM, type: %d, p2p: %d chan: %d MHz\n",
+			 __func__,
+			 vif->addr,
+			 vif->type,
+			 vif->p2p,
+			 conf->def.chan->center_freq);
+
+	mutex_lock(&dev->mutex);
+
+	uvif->chanctx = NULL;
+
+	list_del(&uvif->list);
+	ctx->nvifs--;
+
+	if (!ctx->nvifs) {
+		dev->num_active_chanctx--;
+
+		if (dev->num_active_chanctx)
+			uccp420wlan_prog_chanctx_time_info();
+	}
+
+	mutex_unlock(&dev->mutex);
+}
+#endif
+
+
 static struct ieee80211_ops ops = {
 	.tx                 = tx,
 	.start              = start,
@@ -1914,6 +2247,13 @@ static struct ieee80211_ops ops = {
 	.set_rts_threshold  = set_rts_threshold,
 	.sta_add	    = sta_add,
 	.sta_remove	    = sta_remove,
+#ifdef MULTI_CHAN_SUPPORT
+	.add_chanctx              = add_chanctx,
+	.remove_chanctx           = remove_chanctx,
+	.change_chanctx           = change_chanctx,
+	.assign_vif_chanctx       = assign_vif_chanctx,
+	.unassign_vif_chanctx     = unassign_vif_chanctx,
+#endif
 };
 
 static void uccp420wlan_exit(void)
@@ -1986,6 +2326,9 @@ static int uccp420wlan_init(void)
 
 	mutex_init(&dev->mutex);
 	spin_lock_init(&dev->bcast_lock);
+#ifdef MULTI_CHAN_SUPPORT
+	spin_lock_init(&dev->chanctx_lock);
+#endif
 
 	dev->state = STOPPED;
 	dev->active_vifs = 0;
@@ -2005,6 +2348,12 @@ static int uccp420wlan_init(void)
 	dev->stats = &wifi->stats;
 	dev->umac_proc_dir_entry = wifi->umac_proc_dir_entry;
 	dev->stats->system_rev = system_rev;
+#ifdef MULTI_CHAN_SUPPORT
+	dev->num_active_chanctx = 0;
+
+	for (i = 0; i < MAX_VIFS; i++)
+		dev->vifs[i] = NULL;
+#endif
 
 	/*Register hardware*/
 	error = ieee80211_register_hw(hw);
@@ -2015,6 +2364,7 @@ static int uccp420wlan_init(void)
 	if (wifi->params.production_test && !error) {
 		enum ieee80211_band band;
 		struct ieee80211_supported_band *sband;
+
 		for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
 			sband = hw->wiphy->bands[band];
 			if (sband)
@@ -2594,6 +2944,7 @@ static long param_get_sval(unsigned char *buf,
 {
 
 	unsigned char *temp;
+
 	if (strstr(buf, str)) {
 		temp = strstr(buf, "=") + 1;
 		/*To handle the fixed rate 5.5Mbps case*/
@@ -2619,6 +2970,7 @@ static long param_get_match(unsigned char *buf, unsigned char *str)
 	else
 		return 0;
 }
+
 static ssize_t proc_write_config(struct file *file,
 				 const char __user *buffer,
 				 size_t count,
@@ -2817,7 +3169,7 @@ static ssize_t proc_write_config(struct file *file,
 					uccp420wlan_exit();
 					wifi->hw = NULL;
 				}
-				pr_err("Re-initalizing UCCP420 with %ld antenna selection \n",
+				pr_err("Re-initalizing UCCP420 with %ld antenna selection\n",
 				       val);
 				uccp420wlan_init();
 			}
@@ -2865,6 +3217,7 @@ static ssize_t proc_write_config(struct file *file,
 	} else if (param_get_sval(buf, "mgd_mode_tx_fixed_rate=", &sval)) {
 		if (wifi->params.mgd_mode_tx_fixed_mcs_indx == -1) {
 			int tx_fixed_rate = wifi->params.mgd_mode_tx_fixed_rate;
+
 			if (wifi->params.dot11g_support == 1 &&
 			    ((sval == 1) ||
 			     (sval == 2) ||
@@ -3292,7 +3645,7 @@ static ssize_t proc_write_config(struct file *file,
 			pr_err("Invalid scan type value %d, should be 0 or 1\n",
 			       (unsigned int)val);
 	} else if (ftm && param_get_val(buf, "aux_adc_chain_id=", &val)) {
-		memset(wifi->params.pdout_voltage, 0 ,
+		memset(wifi->params.pdout_voltage, 0,
 		       sizeof(char) * MAX_AUX_ADC_SAMPLES);
 		if ((val == AUX_ADC_CHAIN1) || (val == AUX_ADC_CHAIN2)) {
 			wifi->params.aux_adc_chain_id = val;
@@ -3315,6 +3668,7 @@ static ssize_t proc_write_config(struct file *file,
 			int is_vht_bw80_sec_40minus = 0;
 			int is_vht_bw80_sec_40plus = 0;
 			struct mac80211_dev *dev = wifi->hw->priv;
+
 			pri_chnl_num = val;
 			wifi->params.start_prod_mode = val;
 			tasklet_init(&dev->proc_tx_tasklet, packet_generation,
@@ -3387,9 +3741,13 @@ static ssize_t proc_write_config(struct file *file,
 				proc_bss_info_changed(
 						dev->if_mac_addresses[0].addr,
 						val);
+
 				uccp420wlan_prog_channel(pri_chnl_num,
 							 chnl_num1,
 							 chnl_num2, ch_width,
+#ifdef MULTI_CHAN_SUPPORT
+							 0,
+#endif
 							 freq_band);
 				skb_queue_head_init(&dev->tx.proc_tx_list[0]);
 				wifi->params.init_prod = 1;
@@ -3401,15 +3759,17 @@ static ssize_t proc_write_config(struct file *file,
 	} else if ((wifi->params.production_test) && (wifi->params.init_prod)
 		   && param_get_sval(buf, "stop_prod_mode=", &sval)) {
 			struct mac80211_dev *dev = wifi->hw->priv;
+
 			tasklet_kill(&dev->proc_tx_tasklet);
-			#if 0
+#if 0
 			/* Todo: Enabling this causes RPU Lockup,
-			 * need to debug */
+			 * need to debug
+			 */
 			uccp420wlan_prog_vif_ctrl(0,
 						  dev->if_mac_addresses[0].addr,
 						  IF_MODE_STA_IBSS,
 						  IF_REM);
-			#endif
+#endif
 			uccp420wlan_core_deinit(dev, 0);
 			wifi->params.start_prod_mode = 0;
 			wifi->params.pkt_gen_val = 1;
@@ -3418,6 +3778,7 @@ static ssize_t proc_write_config(struct file *file,
 	} else if ((wifi->params.production_test) && (wifi->params.init_prod)
 		 &&   param_get_sval(buf, "start_packet_gen=", &sval)) {
 		struct mac80211_dev *dev = wifi->hw->priv;
+
 		wifi->params.pkt_gen_val = sval;
 		if (sval != 0)
 			tasklet_schedule(&dev->proc_tx_tasklet);
@@ -3425,14 +3786,15 @@ static ssize_t proc_write_config(struct file *file,
 	} else if ((wifi->params.production_test) && (wifi->params.init_prod)
 		 && param_get_sval(buf, "stop_packet_gen=", &sval)) {
 			struct mac80211_dev *dev = wifi->hw->priv;
+
 			wifi->params.pkt_gen_val = 1;
 			tasklet_kill(&dev->proc_tx_tasklet);
 	} else if ((wifi->params.production_test) &&
-		    param_get_sval(buf, "payload_length=", &sval)) {
+		    param_get_val(buf, "payload_length=", &val)) {
 			wifi->params.payload_length = val;
 	} else if ((ftm || wifi->params.production_test) &&
 		    param_get_sval(buf, "set_tx_power=", &sval)) {
-		memset(wifi->params.pdout_voltage, 0 ,
+		memset(wifi->params.pdout_voltage, 0,
 		       sizeof(char) * MAX_AUX_ADC_SAMPLES);
 		wifi->params.set_tx_power = sval;
 		uccp420wlan_prog_txpower(sval);
@@ -3611,8 +3973,8 @@ static int proc_init(void)
 	wifi->params.prod_mode_stbc_enabled = 0;
 	wifi->params.prod_mode_bcc_or_ldpc = 0;
 	wifi->params.bg_scan_enable = 0;
-	memset(wifi->params.bg_scan_channel_list, 0 , 50);
-	memset(wifi->params.bg_scan_channel_flags, 0 , 50);
+	memset(wifi->params.bg_scan_channel_list, 0, 50);
+	memset(wifi->params.bg_scan_channel_flags, 0, 50);
 
 	if (wifi->params.dot11g_support) {
 		wifi->params.bg_scan_num_channels = 3;
@@ -3684,6 +4046,7 @@ static void proc_exit(void)
 int _uccp420wlan_80211if_init(void)
 {
 	int error;
+
 	error = proc_init();
 	if (error)
 		return error;
diff --git a/drivers/net/wireless/uccp420wlan/src/core.c b/drivers/net/wireless/uccp420wlan/src/core.c
index 6c98af4..b123983 100644
--- a/drivers/net/wireless/uccp420wlan/src/core.c
+++ b/drivers/net/wireless/uccp420wlan/src/core.c
@@ -30,7 +30,7 @@
 
 spinlock_t tsf_lock;
 
-unsigned char bss_addr[6] = {72, 14, 29 , 35, 31, 52};
+unsigned char bss_addr[6] = {72, 14, 29, 35, 31, 52};
 static int is_robust_mgmt(struct sk_buff *skb)
 {
 	/*TODO: mmie struture not being used now. Uncomment once in use */
@@ -56,6 +56,7 @@ static int is_robust_mgmt(struct sk_buff *skb)
 		if (((hdr->frame_control & IEEE80211_FCTL_STYPE) ==
 			IEEE80211_STYPE_ACTION)) {
 			u8 *category;
+
 			category = ((u8 *) hdr) + 24;
 
 			if (*category == WLAN_CATEGORY_PUBLIC ||
@@ -90,6 +91,7 @@ static int is_robust_mgmt(struct sk_buff *skb)
 int wait_for_scan_abort(struct mac80211_dev *dev)
 {
 	int count;
+
 	count = 0;
 
 check_scan_abort_complete:
@@ -119,6 +121,7 @@ check_scan_abort_complete:
 int wait_for_channel_prog_complete(struct mac80211_dev *dev)
 {
 	int count;
+
 	count = 0;
 
 check_ch_prog_complete:
@@ -148,6 +151,7 @@ check_ch_prog_complete:
 int wait_for_reset_complete(struct mac80211_dev *dev)
 {
 	int count;
+
 	count = 0;
 
 check_reset_complete:
@@ -207,6 +211,7 @@ static void driver_tput_timer_expiry(unsigned long data)
 void proc_bss_info_changed(unsigned char *mac_addr, int value)
 {
 		int temp = 0, i = 0, j = 0;
+
 		get_random_bytes(&j, sizeof(j));
 		for (i = 5; i > 0; i--) {
 			j = j % (i+1);
@@ -224,7 +229,7 @@ void packet_generation(unsigned long data)
 		unsigned char *mac_addr = dev->if_mac_addresses[0].addr;
 		struct ieee80211_hdr hdr = {0};
 		struct sk_buff *skb;
-		unsigned char broad_addr[6] = {0xff, 0xff, 0xff ,
+		unsigned char broad_addr[6] = {0xff, 0xff, 0xff,
 					       0xff, 0xff, 0xff};
 		u16 hdrlen = 26;
 
@@ -239,7 +244,7 @@ void packet_generation(unsigned long data)
 		hdr.frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |
 						IEEE80211_STYPE_QOS_DATA);
 		memcpy(skb_put(skb, hdrlen), &hdr, hdrlen);
-		memset(skb_put(skb, dev->params->payload_length), 0xAB ,
+		memset(skb_put(skb, dev->params->payload_length), 0xAB,
 			dev->params->payload_length);
 
 		/*LOOP_END*/
@@ -254,6 +259,9 @@ static void vif_bcn_timer_expiry(unsigned long data)
 	struct sk_buff *skb, *temp;
 	struct sk_buff_head bcast_frames;
 	unsigned long flags;
+#ifdef MULTI_CHAN_SUPPORT
+	int curr_chanctx_idx = -1;
+#endif
 
 	if (uvif->vif->bss_conf.enable_beacon == false)
 		return;
@@ -288,8 +296,20 @@ static void vif_bcn_timer_expiry(unsigned long data)
 
 		spin_lock_irqsave(&uvif->dev->bcast_lock, flags);
 
+#ifdef MULTI_CHAN_SUPPORT
+		spin_lock(&uvif->dev->chanctx_lock);
+		curr_chanctx_idx = uvif->dev->curr_chanctx_idx;
+		spin_unlock(&uvif->dev->chanctx_lock);
+#endif
+
 		while ((skb = skb_dequeue(&bcast_frames)))
-			uccp420wlan_tx_frame(skb, NULL, uvif->dev, true);
+			uccp420wlan_tx_frame(skb,
+					     NULL,
+					     uvif->dev,
+#ifdef MULTI_CHAN_SUPPORT
+					     curr_chanctx_idx,
+#endif
+					     true);
 
 		spin_unlock_irqrestore(&uvif->dev->bcast_lock, flags);
 
@@ -299,7 +319,18 @@ static void vif_bcn_timer_expiry(unsigned long data)
 		if (!skb)
 			goto reschedule_timer;
 
-		uccp420wlan_tx_frame(skb, NULL, uvif->dev, true);
+#ifdef MULTI_CHAN_SUPPORT
+		spin_lock_bh(&uvif->dev->chanctx_lock);
+		curr_chanctx_idx = uvif->dev->curr_chanctx_idx;
+		spin_unlock_bh(&uvif->dev->chanctx_lock);
+#endif
+		uccp420wlan_tx_frame(skb,
+				     NULL,
+				     uvif->dev,
+#ifdef MULTI_CHAN_SUPPORT
+				     curr_chanctx_idx,
+#endif
+				     true);
 
 	}
 reschedule_timer:
@@ -380,8 +411,6 @@ void uccp420wlan_core_deinit(struct mac80211_dev *dev, unsigned int ftm)
 	hal_ops.deinit_bufs();
 
 	uccp420wlan_lmac_if_deinit();
-
-	return;
 }
 
 
@@ -782,6 +811,7 @@ void uccp420wlan_vif_bss_info_changed(struct umac_vif *uvif,
 void uccp420wlan_reset_complete(char *lmac_version, void *context)
 {
 	struct mac80211_dev *dev = (struct mac80211_dev *)context;
+
 	memcpy(dev->stats->uccp420_lmac_version, lmac_version, 5);
 	dev->stats->uccp420_lmac_version[5] = '\0';
 	dev->reset_complete = 1;
@@ -904,6 +934,9 @@ void uccp420wlan_noa_event(int event, struct umac_event_noa *noa, void *context,
 	struct umac_vif *uvif;
 	unsigned long flags;
 	bool transmit = false;
+#ifdef MULTI_CHAN_SUPPORT
+	int curr_chanctx_idx = -1;
+#endif
 
 	rcu_read_lock();
 
@@ -966,19 +999,28 @@ void uccp420wlan_noa_event(int event, struct umac_event_noa *noa, void *context,
 
 	rcu_read_unlock();
 
-	if (transmit)
-		uccp420wlan_tx_frame(skb, NULL, dev, false);
-
-	return;
+	if (transmit) {
+#ifdef MULTI_CHAN_SUPPORT
+		spin_lock_bh(&dev->chanctx_lock);
+		curr_chanctx_idx = dev->curr_chanctx_idx;
+		spin_unlock_bh(&dev->chanctx_lock);
+#endif
+		uccp420wlan_tx_frame(skb,
+				     NULL,
+				     dev,
+#ifdef MULTI_CHAN_SUPPORT
+				     curr_chanctx_idx,
+#endif
+				     false);
+	}
 }
 
+#if 0
 /* Beacon Time Stamp */
-static unsigned int get_real_ts2(unsigned int t2,
-					unsigned long long t1,
-					unsigned long long t3)
+static unsigned int get_real_ts2(unsigned int t2, unsigned int delta)
 {
-	unsigned long long t;
-	int td;
+	unsigned int td = 0;
+	unsigned int clocks = 0;
 	unsigned int clock_mask = 0, tck_num = 0, tck_denom = 0;
 
 	if (get_evt_timer_freq) {
@@ -989,22 +1031,177 @@ static unsigned int get_real_ts2(unsigned int t2,
 		tck_denom = TICK_DENOMINATOR;
 	}
 
-	if (t3 >= t1) {
-		t = t3 - t1;
-	} else {
-		t = t1 - t3;
-		t = ULLONG_MAX - t + 1;
+	clocks = delta * tck_num;
+	/* clocks = clocks / tck_denom; */
+	do_div(clocks, tck_denom);
+
+	if (t2 >= clocks)
+		td = t2 - clocks;
+	else
+		td = clock_mask + (t2 + 1) - clocks;
+
+	return td & clock_mask;
+}
+#endif
+
+
+#ifdef MULTI_CHAN_SUPPORT
+void uccp420wlan_proc_ch_sw_event(struct umac_event_ch_switch *ch_sw_info,
+				  void *context)
+{
+	struct mac80211_dev *dev = NULL;
+	int chan = 0;
+	int curr_freq = 0;
+	int chan_id = 0;
+	struct sk_buff_head *txq = NULL;
+	int txq_len = 0;
+	int i = 0;
+	int queue = 0;
+	unsigned long flags = 0;
+	int curr_bit = 0;
+	int pool_id = 0;
+	int ret = 0;
+	int peer_id = -1;
+	int ac = 0;
+	struct ieee80211_chanctx_conf *curr_chanctx = NULL;
+	struct tx_config *tx = NULL;
+
+	if (!ch_sw_info || !context) {
+		pr_err("%s: Invalid Parameters\n", __func__);
+		return;
 	}
 
-	t *= tck_num;
-	do_div(t, tck_denom);
-	td = t2 - (int32_t)t;
+	dev = (struct mac80211_dev *)context;
+	chan = ch_sw_info->chan;
+	tx = &dev->tx;
 
-	if (td < 0)
-		td = clock_mask + 1 + td;
+	rcu_read_lock();
 
-	return td & clock_mask;
+	for (i = 0; i < MAX_CHANCTX; i++) {
+		curr_chanctx = rcu_dereference(dev->chanctx[i]);
+
+		if (curr_chanctx) {
+			curr_freq = curr_chanctx->def.chan->center_freq;
+
+			if (ieee80211_frequency_to_channel(curr_freq) == chan) {
+				chan_id = i;
+				break;
+			}
+		}
+	}
+
+	rcu_read_unlock();
+
+	if (i == MAX_CHANCTX) {
+		pr_err("%s: Invalid Channel Context\n", __func__);
+		return;
+	}
+
+
+	/* Switch to the new channel context */
+	spin_lock(&dev->chanctx_lock);
+	dev->curr_chanctx_idx = chan_id;
+	spin_unlock(&dev->chanctx_lock);
+
+	/* We now try to xmit any frames whose xmission got cancelled due to a
+	 * previous channel switch
+	 */
+	for (i = 0; i < NUM_TX_DESCS; i++) {
+		spin_lock_irqsave(&tx->lock, flags);
+
+		curr_bit = (i % TX_DESC_BUCKET_BOUND);
+		pool_id = (i / TX_DESC_BUCKET_BOUND);
+
+		if (test_and_set_bit(curr_bit, &tx->buf_pool_bmp[pool_id])) {
+			spin_unlock_irqrestore(&tx->lock, flags);
+			continue;
+		}
+
+		txq = &tx->pkt_info[chan_id][i].pkt;
+		txq_len = skb_queue_len(txq);
+		queue = tx->pkt_info[chan_id][i].queue;
+
+		if (!txq_len) {
+			/* Reserved token */
+			if (i < (NUM_TX_DESCS_PER_AC * NUM_ACS)) {
+				queue = (i % NUM_ACS);
+				peer_id = get_curr_peer_opp(dev,
+							    chan_id,
+							    queue);
+
+				if (peer_id == -1) {
+					/* Mark the token as available */
+					__clear_bit(curr_bit,
+						    &tx->buf_pool_bmp[pool_id]);
+
+					spin_unlock_irqrestore(&tx->lock,
+							       flags);
+					continue;
+				}
+
+			/* Spare token */
+			} else {
+				for (ac = WLAN_AC_VO; ac >= 0; ac--) {
+					peer_id = get_curr_peer_opp(dev,
+								    chan_id,
+								    ac);
+
+					if (peer_id != -1) {
+						queue = ac;
+						break;
+					}
+				}
+
+				if (ac < 0) {
+					/* Mark the token as available */
+					__clear_bit(curr_bit,
+						    &tx->buf_pool_bmp[pool_id]);
+
+					spin_unlock_irqrestore(&tx->lock,
+							       flags);
+					continue;
+				}
+			}
+
+			uccp420wlan_tx_proc_pend_frms(dev,
+						      queue,
+						      chan_id,
+						      peer_id,
+						      i);
+
+			tx->outstanding_tokens[queue]++;
+
+		}
+
+		spin_unlock_irqrestore(&tx->lock, flags);
+
+		ret = __uccp420wlan_tx_frame(dev,
+					     queue,
+					     i,
+					     chan_id,
+					     0); /* TODO: Currently sending 0
+						    since this param is not used
+						    as expected in the orig
+						    code for multiple frames etc
+						    Need to set this
+						    properly when the orig code
+						    logic is corrected
+						  */
+		if (ret < 0) {
+			/* SDK: Check if we need to clear the TX bitmap and
+			 * desc_chan_map here
+			 */
+			pr_err("%s: Queueing of TX frame to FW failed\n",
+			       __func__);
+		} else {
+			spin_lock_irqsave(&tx->lock, flags);
+			tx->desc_chan_map[i] = chan_id;
+			spin_unlock_irqrestore(&tx->lock, flags);
+		}
+
+	}
 }
+#endif
 
 
 void uccp420wlan_rx_frame(struct sk_buff *skb, void *context)
@@ -1146,7 +1343,7 @@ void uccp420wlan_rx_frame(struct sk_buff *skb, void *context)
 		} else {
 #ifdef DRIVER_DEBUG
 			print_hex_dump(KERN_DEBUG, " ",
-				       DUMP_PREFIX_NONE, 16, 1, rx ,
+				       DUMP_PREFIX_NONE, 16, 1, rx,
 				       sizeof(struct wlan_rx_pkt), 1);
 #endif
 			dev_kfree_skb_any(skb);
@@ -1187,23 +1384,24 @@ void uccp420wlan_rx_frame(struct sk_buff *skb, void *context)
 			if (vif &&
 			ether_addr_equal(hdr->addr2, vif->bss_conf.bssid)) {
 				unsigned int ts2;
-				unsigned long long ts3;
+				unsigned int ldelta;
+
 				spin_lock(&tsf_lock);
 				dev->params->sync[i].status = 1;
 				memcpy(dev->params->sync[i].bssid,
 				       vif->bss_conf.bssid, 6);
 				memcpy(dev->params->sync[i].ts1,
-					(char *)hdr->addr4, 8);
-				memcpy(&ts3, &rx->reserved, 8);
+					&rx->reserved, 8);
 				memcpy(&ts2, &rx->reserved[8], 4);
 				memcpy(&dev->params->sync[i].ts2,
 						&rx->reserved[8], 4);
+				memcpy(&ldelta, &rx->reserved[12], 4);
 				dev->params->sync[i].atu = 0;
-				ts2 = get_real_ts2(ts2, get_unaligned_le64(
-					dev->params->sync[i].ts1), ts3);
+				/* ts2 = get_real_ts2(ts2, ldelta); */
 				if (frc_to_atu)
 					frc_to_atu(ts2,
 						&dev->params->sync[i].atu, 0);
+				dev->params->sync[i].atu -= ldelta * 1000;
 				spin_unlock(&tsf_lock);
 				break;
 			}
@@ -1220,6 +1418,7 @@ void uccp420wlan_ch_prog_complete(int event,
 				  void *context)
 {
 	struct mac80211_dev *dev = (struct mac80211_dev *)context;
+
 	dev->chan_prog_done = 1;
 }
 
diff --git a/drivers/net/wireless/uccp420wlan/src/fwldr.c b/drivers/net/wireless/uccp420wlan/src/fwldr.c
index 70522d5..643f76f 100644
--- a/drivers/net/wireless/uccp420wlan/src/fwldr.c
+++ b/drivers/net/wireless/uccp420wlan/src/fwldr.c
@@ -162,8 +162,6 @@ static void dir_mem_cpy(unsigned int addr,
 					      __func__, base);
 		}
 	}
-
-	return;
 }
 
 
@@ -228,8 +226,6 @@ static void dir_mem_set(unsigned int addr,
 				      __func__, base);
 		}
 	}
-
-	return;
 }
 
 /* Perform 'len' 32 bit reads from a UCCP memory location 'addr'
@@ -822,7 +818,6 @@ static int fwldr_parser(const unsigned char *fw_data)
 					 GFP_KERNEL);
 
 			if (l2_blk == NULL) {
-				fwldr_dbg_err("Not Enough Memory\n");
 				res = FWLDR_FAIL;
 				break;
 			}
@@ -949,9 +944,7 @@ static int fwldr_parser(const unsigned char *fw_data)
 
 			cfg_str = kmalloc(buf_len, GFP_KERNEL);
 
-			if (cfg_str == NULL) {
-				fwldr_dbg_err("Failed to allocate cfg_str\n");
-			} else {
+			if (cfg_str) {
 				str_curr = cfg_str;
 				str_end = cfg_str + buf_len;
 			}
diff --git a/drivers/net/wireless/uccp420wlan/src/hal_hostport.c b/drivers/net/wireless/uccp420wlan/src/hal_hostport.c
index c67f530..b00a6a9 100644
--- a/drivers/net/wireless/uccp420wlan/src/hal_hostport.c
+++ b/drivers/net/wireless/uccp420wlan/src/hal_hostport.c
@@ -34,6 +34,7 @@
 
 #include <linux/time.h>
 #include <linux/sort.h>
+#include <linux/etherdevice.h>
 
 #include "hal.h"
 #include "hal_hostport.h"
@@ -495,9 +496,6 @@ static void rx_tasklet_fn(unsigned long data)
 				new_skb = alloc_skb(max_data_size, GFP_ATOMIC);
 
 				if (!new_skb) {
-					pr_err("%s Failed to initialize RX buf %d\n",
-					       hal_name, pkt_desc);
-
 					/* If allocation fails, drop the packet,
 					 * continue
 					 */
@@ -545,10 +543,7 @@ static void rx_tasklet_fn(unsigned long data)
 				 */
 				nbuf = alloc_skb(sizeof(struct cmd_hal),
 						 GFP_ATOMIC);
-				if (!nbuf) {
-					pr_err("%s Out of memory\n", hal_name);
-				} else {
-
+				if (nbuf) {
 					cmd_data = skb_put(nbuf,
 						   sizeof(struct cmd_hal));
 
@@ -618,8 +613,6 @@ static void rx_tasklet_fn(unsigned long data)
 			priv->rcv_handler(skb, LMAC_MOD_ID);
 		}
 	}
-
-	return;
 }
 
 
@@ -708,8 +701,6 @@ static irqreturn_t hal_irq_handler(int    irq, void  *p)
 		skb = dev_alloc_skb(event_len);
 
 		if (!skb) {
-			pr_err("%s: Alloc SKB Failed for %ld\n",
-			       hal_name, event_len);
 			*((unsigned long *)event_status_addr) = 0;
 		} else {
 			*(unsigned long *)(skb->cb) = event_addr;
@@ -779,8 +770,6 @@ static void hal_enable_int(void  *p)
 	value |= BIT(UCCP_CORE_INT_EN_SHIFT);
 	writel(*((unsigned long *)&(value)),
 	       (void __iomem *)(UCCP_CORE_INT_ENABLE_ADDR));
-
-	return;
 }
 
 
@@ -799,8 +788,6 @@ static void hal_disable_int(void  *p)
 	value &= ~(BIT(UCCP_CORE_INT_EN_SHIFT));
 	writel(*((unsigned long *)&(value)),
 	       (void __iomem *)(UCCP_CORE_INT_ENABLE_ADDR));
-
-	return;
 }
 
 
@@ -1075,16 +1062,14 @@ static int cleanup_all_resources(void)
 			   hpriv->uccp_pkd_gram_len);
 
 	/* Unmap UCCP Host RAM */
-	if (hpriv->base_addr_uccp_host_ram) {
-		kfree (hpriv->base_addr_uccp_host_ram);
-		hpriv->base_addr_uccp_host_ram = NULL;
-	}
+	kfree(hpriv->base_addr_uccp_host_ram);
+	hpriv->base_addr_uccp_host_ram = NULL;
 
 	kfree(hpriv);
 	return 0;
 }
 
-static int uccp420_pltfr_probe (struct platform_device *pdev)
+static int uccp420_pltfr_probe(struct platform_device *pdev)
 {
 	struct resource *res;
 	int irq;
@@ -1155,7 +1140,8 @@ static int uccp420_pltfr_probe (struct platform_device *pdev)
 
 		conv_str_to_byte(vif_macs[0], mac_addr, ETH_ALEN);
 
-		memcpy(&vif_macs[1], &vif_macs[0], ETH_ALEN);
+		ether_addr_copy(vif_macs[1], vif_macs[0]);
+
 		vif_macs[1][5]++;
 	}
 
@@ -1192,19 +1178,19 @@ static int uccp420_pltfr_probe (struct platform_device *pdev)
 	return ret;
 }
 
-static int uccp420_pltfr_remove (struct platform_device *pdev)
+static int uccp420_pltfr_remove(struct platform_device *pdev)
 {
-	clk_disable_unprepare (devm_clk_get(&pdev->dev, "rpu_core"));
-	clk_disable_unprepare (devm_clk_get(&pdev->dev, "rpu_l"));
-	clk_disable_unprepare (devm_clk_get(&pdev->dev, "rpu_v"));
-	clk_disable_unprepare (devm_clk_get(&pdev->dev, "rpu_sleep"));
-	clk_disable_unprepare (devm_clk_get(&pdev->dev, "wifi_adc"));
-	clk_disable_unprepare (devm_clk_get(&pdev->dev, "wifi_dac"));
-
-	clk_disable_unprepare (devm_clk_get(&pdev->dev, "event_timer"));
-	clk_disable_unprepare (devm_clk_get(&pdev->dev, "sys_event_timer"));
-	clk_disable_unprepare (devm_clk_get(&pdev->dev, "aux_adc"));
-	clk_disable_unprepare (devm_clk_get(&pdev->dev, "aux_adc_internal"));
+	clk_disable_unprepare(devm_clk_get(&pdev->dev, "rpu_core"));
+	clk_disable_unprepare(devm_clk_get(&pdev->dev, "rpu_l"));
+	clk_disable_unprepare(devm_clk_get(&pdev->dev, "rpu_v"));
+	clk_disable_unprepare(devm_clk_get(&pdev->dev, "rpu_sleep"));
+	clk_disable_unprepare(devm_clk_get(&pdev->dev, "wifi_adc"));
+	clk_disable_unprepare(devm_clk_get(&pdev->dev, "wifi_dac"));
+
+	clk_disable_unprepare(devm_clk_get(&pdev->dev, "event_timer"));
+	clk_disable_unprepare(devm_clk_get(&pdev->dev, "sys_event_timer"));
+	clk_disable_unprepare(devm_clk_get(&pdev->dev, "aux_adc"));
+	clk_disable_unprepare(devm_clk_get(&pdev->dev, "aux_adc_internal"));
 
 	return 0;
 }
@@ -1366,9 +1352,6 @@ static int hal_init(void *dev)
 						 GFP_KERNEL);
 
 	if (!hpriv->base_addr_uccp_host_ram) {
-		pr_err("%s: Alloc for UCCP DMA area failed\n",
-		       __func__);
-
 		iounmap((void __iomem *)hpriv->uccp_base_addr);
 		release_mem_region(hpriv->uccp_core_base,
 				   hpriv->uccp_core_len);
@@ -1521,8 +1504,6 @@ static void hal_deinit_bufs(void)
 
 	hpriv->hal_disabled = 1;
 	tasklet_enable(&hpriv->rx_tasklet);
-
-	return;
 }
 
 
@@ -1612,10 +1593,8 @@ static int hal_init_bufs(unsigned int tx_bufs,
 
 		nbuf = alloc_skb(sizeof(struct cmd_hal), GFP_ATOMIC);
 
-		if (!nbuf) {
-			pr_err("%s out of memory\n", hal_name);
+		if (!nbuf)
 			goto err;
-		}
 
 		memcpy(skb_put(nbuf, sizeof(struct cmd_hal)),
 		       (unsigned char *)&cmd_rx, sizeof(struct cmd_hal));
@@ -1644,6 +1623,12 @@ int hal_map_tx_buf(int pkt_desc, int frame_id, unsigned char *data, int len)
 
 	dma_addr_t dma_buf = 0;
 
+	/* For QoS Null frames we dont try to map the frame since the data len
+	 * will be 0 and there is nothing for the FW to process
+	 */
+	if (len == 0)
+		return 0;
+
 	/* Sanity check */
 	dma_buf = ((struct buf_info)(hpriv->tx_buf_info[index])).dma_buf;
 
@@ -1665,7 +1650,7 @@ int hal_map_tx_buf(int pkt_desc, int frame_id, unsigned char *data, int len)
 		}
 		for (i = 0; i < 80; i++) {
 			pr_debug("%s: RX: descriptor: %d dma_buf: 0x%x\n",
-				 __func__, i , hpriv->rx_buf_info[i].dma_buf);
+				 __func__, i, hpriv->rx_buf_info[i].dma_buf);
 		}
 
 		return -1;
@@ -1703,6 +1688,13 @@ int hal_unmap_tx_buf(int pkt_desc, int frame_id)
 {
 	unsigned int index = (pkt_desc * NUM_FRAMES_IN_TX_DESC) + frame_id;
 
+	/* For QoS Null frames we did not map the frame (since the data len
+	 * will be 0 and there is nothing for the FW to process), hence no need
+	 * to try and unmap
+	 */
+	if (!hpriv->tx_buf_info[index].dma_buf_len)
+		return 0;
+
 	/* Sanity check */
 	if (!hpriv->tx_buf_info[index].dma_buf) {
 		pr_err("%s called for unmapped pkt desc: %d , frame: %d\n",
@@ -1825,7 +1817,6 @@ static int init_rx_buf(int pkt_desc,
 }
 void hal_set_mem_region(unsigned int addr)
 {
-	return;
 }
 void hal_request_mem_regions(unsigned char **gram_addr,
 			     unsigned char **slave_addr,
diff --git a/drivers/net/wireless/uccp420wlan/src/tx.c b/drivers/net/wireless/uccp420wlan/src/tx.c
index c3bab6e..f6db86a 100644
--- a/drivers/net/wireless/uccp420wlan/src/tx.c
+++ b/drivers/net/wireless/uccp420wlan/src/tx.c
@@ -216,355 +216,527 @@ static void tx_status(struct sk_buff *skb,
 						     msecs_to_jiffies(1));
 		}
 	}
+
 	dev->stats->tx_dones_to_stack++;
+
 	ieee80211_tx_status(dev->hw, skb);
 }
 
 
-static int get_token(struct tx_config *tx,
+static int get_token(struct mac80211_dev *dev,
+#ifdef MULTI_CHAN_SUPPORT
+		     int curr_chanctx_idx,
+#endif
 		     int queue)
 {
-	int cnt = 0, spare_tid = NUM_TX_DESCS;
+	int cnt = 0;
+	int curr_bit = 0;
+	int pool_id = 0;
+	int token_id = NUM_TX_DESCS;
+	struct tx_config *tx = &dev->tx;
 
+	/* First search for a reserved token */
 	for (cnt = 0; cnt < NUM_TX_DESCS_PER_AC; cnt++) {
-		if (!test_and_set_bit((queue + (NUM_ACS * cnt)),
-							&tx->buf_pool_bmp[0])) {
+		curr_bit = ((queue + (NUM_ACS * cnt)) % TX_DESC_BUCKET_BOUND);
+		pool_id = ((queue + (NUM_ACS * cnt)) / TX_DESC_BUCKET_BOUND);
 
-			spare_tid = queue + (NUM_ACS * cnt);
+		if (!test_and_set_bit(curr_bit, &tx->buf_pool_bmp[pool_id])) {
+			token_id = queue + (NUM_ACS * cnt);
 			break;
 		}
 	}
-	if (spare_tid == NUM_TX_DESCS) {
-		for (cnt = NUM_TX_DESCS_PER_AC * NUM_ACS;
-					cnt < NUM_TX_DESCS; cnt++) {
+
+	/* If reserved token is not found search for a spare token */
+	if (cnt == NUM_TX_DESCS_PER_AC) {
+		for (token_id = NUM_TX_DESCS_PER_AC * NUM_ACS;
+		     token_id < NUM_TX_DESCS;
+		     token_id++) {
+			curr_bit = (token_id % TX_DESC_BUCKET_BOUND);
+			pool_id = (token_id / TX_DESC_BUCKET_BOUND);
 			/* Do not set, we will queue to the same token */
-			if (!test_and_set_bit((cnt%TX_DESC_BUCKET_BOUND),
-					      &tx->buf_pool_bmp[
-					      (cnt/TX_DESC_BUCKET_BOUND)])) {
-				spare_tid = cnt;
+			if (!test_and_set_bit(curr_bit,
+					      &tx->buf_pool_bmp[pool_id])) {
 				break;
 			}
 		}
 	}
 
-	if (spare_tid != NUM_TX_DESCS)
+	if (token_id != NUM_TX_DESCS) {
 		tx->outstanding_tokens[queue]++;
+#ifdef MULTI_CHAN_SUPPORT
+		tx->desc_chan_map[token_id] = curr_chanctx_idx;
+#endif
+	}
 
-	return spare_tid;
+	return token_id;
 }
 
 
-int uccp420wlan_tx_alloc_buff_req(struct mac80211_dev *dev,
-				  int queue,
-				  unsigned int *id,
-				  struct sk_buff *skb)
+int get_curr_peer_opp(struct mac80211_dev *dev,
+#ifdef MULTI_CHAN_SUPPORT
+		      int curr_chanctx_idx,
+#endif
+		      int queue)
 {
-	int spare = 0;
-	struct tx_config *tx = &dev->tx;
-	unsigned long flags, ampdu_len = 0;
-	struct sk_buff *loop_skb;
-	struct sk_buff *tmp, *skb_first = NULL;
-	struct ieee80211_hdr *mac_hdr_first, *mac_hdr;
-	struct ieee80211_tx_info *tx_info_first, *tx_info;
-	unsigned int max_tx_cmds = dev->params->max_tx_cmds;
-	struct umac_vif *uvif;
-	struct ieee80211_vif *ivif;
-	unsigned char *data = NULL;
+	unsigned int curr_peer_opp = 0;
+	unsigned int i = 0;
+	struct tx_config *tx = NULL;
+#ifdef MULTI_CHAN_SUPPORT
+	struct ieee80211_sta *sta = NULL;
+	struct ieee80211_vif *vif = NULL;
+	struct umac_sta *usta = NULL;
+	struct umac_vif *uvif = NULL;
+	int vif_index = -1;
+#endif
+	unsigned int init_peer_opp = 0;
 
-	spin_lock_irqsave(&tx->lock, flags);
+	tx = &dev->tx;
 
-	DEBUG_LOG("%s-UMACTX:Alloc buf Req q = %d,\n", dev->name, queue);
+#ifdef MULTI_CHAN_SUPPORT
+	init_peer_opp = tx->curr_peer_opp[curr_chanctx_idx][queue];
+#else
+	init_peer_opp = tx->curr_peer_opp[queue];
+#endif
 
-	*id = NUM_TX_DESCS;
+	for (i = 0; i < MAX_PEND_Q_PER_AC; i++) {
+		curr_peer_opp = (init_peer_opp + i) % MAX_PEND_Q_PER_AC;
 
-	if ((tx->outstanding_tokens[queue] < NUM_TX_DESCS_PER_AC)
-	     || (queue == WLAN_AC_BCN)) {
-		/* Reserved Full and Outstanding < 2*/
-		spare = get_token(tx, queue);
+#ifdef MULTI_CHAN_SUPPORT
+		rcu_read_lock();
 
-		if (spare != NUM_TX_DESCS) {
-			DEBUG_LOG("%s-UMACTX:Reserved Token, Sending single\n",
-				dev->name);
-			skb_queue_tail(&dev->tx.tx_pkt[spare], skb);
+		if (curr_peer_opp < MAX_PEERS) {
+			sta = rcu_dereference(dev->peers[curr_peer_opp]);
+
+			if (!sta) {
+				rcu_read_unlock();
+				continue;
+			}
+
+			usta = (struct umac_sta *)(sta->drv_priv);
+
+			if (!usta->chanctx) {
+				rcu_read_unlock();
+				continue;
+			}
+
+			if (usta->chanctx->index != curr_chanctx_idx) {
+				rcu_read_unlock();
+				continue;
+			}
+
+		} else {
+			vif_index = (curr_peer_opp - MAX_PEERS);
+
+			vif = rcu_dereference(dev->vifs[vif_index]);
+
+			if (!vif) {
+				rcu_read_unlock();
+				continue;
+			}
+
+			uvif = (struct umac_vif *)(vif->drv_priv);
+
+			if (!uvif->chanctx) {
+				rcu_read_unlock();
+				continue;
+			}
+
+			if (uvif->chanctx->index != curr_chanctx_idx) {
+				rcu_read_unlock();
+				continue;
+			}
 		}
 
-		*id = spare;
+		rcu_read_unlock();
+#endif
 
-		goto out;
+		if (skb_queue_len(&tx->pending_pkt[curr_peer_opp][queue])) {
+#ifdef MULTI_CHAN_SUPPORT
+			tx->curr_peer_opp[curr_chanctx_idx][queue] =
+				(curr_peer_opp + 1) % MAX_PEND_Q_PER_AC;
+#else
+			tx->curr_peer_opp[queue] =
+				(curr_peer_opp + 1) % MAX_PEND_Q_PER_AC;
+#endif
+			break;
+		}
 	}
 
-	skb_queue_tail(&tx->pending_pkt[queue], skb);
+	if (i == MAX_PEND_Q_PER_AC)
+		return -1;
 
-	if (skb_queue_len(&tx->pending_pkt[queue]) < max_tx_cmds) {
-		*id = NUM_TX_DESCS;
-		goto out;
-	}
+	return curr_peer_opp;
+}
 
-	/* Check Spare Token */
-	spare = get_token(tx, queue);
 
-	if (spare != NUM_TX_DESCS) {
-		skb_first = skb_peek(&tx->pending_pkt[queue]);
+void uccp420wlan_tx_proc_pend_frms(struct mac80211_dev *dev,
+				   int queue,
+#ifdef MULTI_CHAN_SUPPORT
+				   int curr_chanctx_idx,
+#endif
+				   int peer_id,
+				   int token_id)
+{
+	struct tx_config *tx = &dev->tx;
+	unsigned long ampdu_len = 0;
+	struct sk_buff *loop_skb = NULL;
+	struct sk_buff *tmp = NULL;
+	struct sk_buff *skb_first = NULL;
+	struct ieee80211_hdr *mac_hdr_first = NULL;
+	struct ieee80211_hdr *mac_hdr = NULL;
+	struct ieee80211_tx_info *tx_info_first = NULL;
+	struct ieee80211_tx_info *tx_info = NULL;
+	struct umac_vif *uvif = NULL;
+	struct ieee80211_vif *ivif = NULL;
+	unsigned char *data = NULL;
+	unsigned int max_tx_cmds = dev->params->max_tx_cmds;
+	struct sk_buff_head *txq = NULL;
+	struct sk_buff_head *pend_pkt_q = NULL;
 
-		mac_hdr_first = (struct ieee80211_hdr *)skb_first->data;
+	pend_pkt_q = &tx->pending_pkt[peer_id][queue];
 
-		tx_info_first = IEEE80211_SKB_CB(skb_first);
+#ifdef MULTI_CHAN_SUPPORT
+	txq = &dev->tx.pkt_info[curr_chanctx_idx][token_id].pkt;
+#else
+	txq = &dev->tx.pkt_info[token_id].pkt;
+#endif
 
-		/* Temp Checks for Aggregation: Will be removed later*/
-		if ((tx_info_first->control.rates[0].flags &
-		     IEEE80211_TX_RC_VHT_MCS) && max_tx_cmds > 24)
-			max_tx_cmds = 24;
-		else if ((tx_info_first->control.rates[0].flags &
-			  IEEE80211_TX_RC_MCS) && max_tx_cmds > 16)
-			max_tx_cmds = 16;
+	skb_first = skb_peek(pend_pkt_q);
 
-		/* Aggregate Only MPDU's with same RA, same Rate,
-		 * same Rate flags, same Tx Info flags
-		 */
-		skb_queue_walk_safe(&tx->pending_pkt[queue],
-				    loop_skb,
-				    tmp) {
-			data = loop_skb->data;
-			mac_hdr = (struct ieee80211_hdr *)data;
+	mac_hdr_first = (struct ieee80211_hdr *)skb_first->data;
 
-			tx_info = IEEE80211_SKB_CB(loop_skb);
+	tx_info_first = IEEE80211_SKB_CB(skb_first);
 
-			ivif = tx_info->control.vif;
-			uvif = (struct umac_vif *)(ivif->drv_priv);
+	/* Temp Checks for Aggregation: Will be removed later*/
+	if ((tx_info_first->control.rates[0].flags &
+	     IEEE80211_TX_RC_VHT_MCS) && max_tx_cmds > 24)
+		max_tx_cmds = 24;
+	else if ((tx_info_first->control.rates[0].flags &
+		  IEEE80211_TX_RC_MCS) && max_tx_cmds > 16)
+		max_tx_cmds = 16;
+
+	/* Aggregate Only MPDU's with same RA, same Rate,
+	 * same Rate flags, same Tx Info flags
+	 */
+	skb_queue_walk_safe(pend_pkt_q,
+			    loop_skb,
+			    tmp) {
+		data = loop_skb->data;
+		mac_hdr = (struct ieee80211_hdr *)data;
+
+		tx_info = IEEE80211_SKB_CB(loop_skb);
+
+		ivif = tx_info->control.vif;
+		uvif = (struct umac_vif *)(ivif->drv_priv);
 
-			ampdu_len += loop_skb->len;
+		ampdu_len += loop_skb->len;
 
-			if (!ieee80211_is_data(mac_hdr->frame_control) ||
-			    !(tx_info->flags & IEEE80211_TX_CTL_AMPDU) ||
-			    (skb_queue_len(&dev->tx.tx_pkt[spare]) >=
-			     max_tx_cmds) ||
+		if (!ieee80211_is_data(mac_hdr->frame_control) ||
+		    !(tx_info->flags & IEEE80211_TX_CTL_AMPDU) ||
+		    (skb_queue_len(txq) >= max_tx_cmds) ||
 #if 0
-			    (memcmp(&tx_info_first->control.rates[0],
-				    &tx_info->control.rates[0],
-				    sizeof(struct ieee80211_tx_rate) *
-				    IEEE80211_TX_MAX_RATES) != 0) ||
-			    (tx_info_first->flags != tx_info->flags) ||
-#endif
-			    (memcmp(mac_hdr->addr1,
-				    mac_hdr_first->addr1,
-				    ETH_ALEN) == 0))
-				break;
+		    (memcmp(&tx_info_first->control.rates[0],
+			    &tx_info->control.rates[0],
+			    sizeof(struct ieee80211_tx_rate) *
+			    IEEE80211_TX_MAX_RATES) != 0) ||
+		    (tx_info_first->flags != tx_info->flags) ||
+#endif
+		    (memcmp(mac_hdr->addr1,
+			    mac_hdr_first->addr1,
+			    ETH_ALEN) != 0))
+			break;
 
-			__skb_unlink(loop_skb, &tx->pending_pkt[queue]);
+		__skb_unlink(loop_skb, pend_pkt_q);
 
-			skb_queue_tail(&dev->tx.tx_pkt[spare], loop_skb);
-		}
+		skb_queue_tail(txq, loop_skb);
+	}
+
+	/* If our criterion rejects all pending frames, send only 1 */
+	if (!skb_queue_len(txq))
+		skb_queue_tail(txq, skb_dequeue(pend_pkt_q));
 
-		/* If our criterion rejects all pending frames, send only 1 */
-		if (!skb_queue_len(&dev->tx.tx_pkt[spare]))
-			skb_queue_tail(&dev->tx.tx_pkt[spare],
-				       skb_dequeue(&tx->pending_pkt[queue]));
+	DEBUG_LOG("%s-UMACTX:Max_pkt_thresh: send spare: %d with %d\n",
+		  dev->name,
+		  token_id,
+		  skb_queue_len(txq));
+}
 
-		DEBUG_LOG("%s-UMACTX:Max_pkt_thresh: send spare: %d with %d\n",
-		       dev->name,
-		       spare,
-		       skb_queue_len(&dev->tx.tx_pkt[spare]));
 
-		/* We can send only list here, but when the count
-		 * reaches 32 again we send another
+int uccp420wlan_tx_alloc_buff_req(struct mac80211_dev *dev,
+				  int queue,
+#ifdef MULTI_CHAN_SUPPORT
+				  struct umac_vif *uvif,
+				  int curr_chanctx_idx,
+#endif
+				  int peer_id,
+				  struct sk_buff *skb)
+{
+	int token_id = NUM_TX_DESCS;
+	struct tx_config *tx = &dev->tx;
+	struct sk_buff_head *txq = NULL;
+	unsigned long flags = 0;
+	struct sk_buff_head *pend_pkt_q = NULL;
+	int tx_peer_id = 0;
+	struct ieee80211_hdr *mac_hdr = NULL;
+
+	spin_lock_irqsave(&tx->lock, flags);
+
+	pend_pkt_q = &tx->pending_pkt[peer_id][queue];
+
+	DEBUG_LOG("%s-UMACTX:Alloc buf Req q = %d,\n", dev->name, queue);
+
+#ifdef MULTI_CHAN_SUPPORT
+	if (uvif->chanctx->index == curr_chanctx_idx)
+#endif
+		token_id = get_token(dev,
+#ifdef MULTI_CHAN_SUPPORT
+				     curr_chanctx_idx,
+#endif
+				     queue);
+
+	/* If we got a reserved token, then queue frame to the Xmit queue */
+	if (token_id < NUM_TX_DESCS_PER_AC * NUM_ACS) {
+		DEBUG_LOG("%s-UMACTX:Reserved Token, Sending single\n",
+			  dev->name);
+#ifdef MULTI_CHAN_SUPPORT
+		txq = &dev->tx.pkt_info[curr_chanctx_idx][token_id].pkt;
+#else
+		txq = &dev->tx.pkt_info[token_id].pkt;
+#endif
+		skb_queue_tail(txq, skb);
+	} else {
+		/* The probability of a beacon frame not getting a reserved
+		 * token is very low due since we request a beacon frame only
+		 * when a reserved token is freed up.
 		 */
-	}
+#ifdef MULTI_CHAN_SUPPORT
+		if (uvif->chanctx->index == curr_chanctx_idx) {
+#endif
+			mac_hdr = (struct ieee80211_hdr *)(skb->data);
+
+			if ((queue == WLAN_AC_BCN) &&
+			    (ieee80211_is_beacon(mac_hdr->frame_control))) {
+				/* TODO: Need to see how to handle the beacon
+				 * frame in such a case i.e. whether it is worth
+				 * queuing it
+				 */
+				pr_err("Did not get rsvd token for beacon\n");
+			}
 
-	/* No spare token, so make sure queue is not overflowing */
-	if ((queue != WLAN_AC_BCN) &&
-	    (skb_queue_len(&tx->pending_pkt[queue]) >= MAX_TX_QUEUE_LEN)) {
-		ieee80211_stop_queue(dev->hw,
-				     skb->queue_mapping);
-		tx->queue_stopped_bmp |= (1 << queue);
-	}
+#ifdef MULTI_CHAN_SUPPORT
+		}
+#endif
 
-	*id = spare;
+		/* Queue the frame to the pending frames queue */
+		skb_queue_tail(pend_pkt_q, skb);
 
-out:
-	DEBUG_LOG("%s-UMACTX:Alloc buf Result *id = %d\n", dev->name, *id);
+		/* Take steps to stop the TX traffic if we have reached the
+		 * queueing limit
+		 */
+		if (skb_queue_len(pend_pkt_q) >= MAX_TX_QUEUE_LEN) {
+			ieee80211_stop_queue(dev->hw,
+					     skb->queue_mapping);
+			tx->queue_stopped_bmp |= (1 << queue);
+		}
+
+		/* If we got a spare token, try sending out pending frames */
+		if (token_id < NUM_TX_DESCS) {
+			tx_peer_id = get_curr_peer_opp(dev,
+#ifdef MULTI_CHAN_SUPPORT
+						       curr_chanctx_idx,
+#endif
+						       queue);
+
+			uccp420wlan_tx_proc_pend_frms(dev,
+						      queue,
+#ifdef MULTI_CHAN_SUPPORT
+						      curr_chanctx_idx,
+#endif
+						      tx_peer_id,
+						      token_id);
+		}
+	}
+
+	DEBUG_LOG("%s-UMACTX:Alloc buf Result *id = %d\n", dev->name, token_id);
 
 	spin_unlock_irqrestore(&tx->lock, flags);
 
 	/* If token is available, just return tokenid, list will be sent*/
-	return *id;
+	return token_id;
 }
 
 
 int uccp420wlan_tx_free_buff_req(struct mac80211_dev *dev,
 				 struct umac_event_tx_done *tx_done,
 				 unsigned char *queue,
+#ifdef MULTI_CHAN_SUPPORT
+				 int curr_chanctx_idx,
+#endif
 				 int *vif_index_bitmap)
 {
-	int i;
-	unsigned long flags, ampdu_len;
+	int i = 0;
+	unsigned long flags;
 	unsigned int pkts_pend = 0;
 	struct tx_config *tx = &dev->tx;
-	struct ieee80211_hdr *mac_hdr_first, *mac_hdr;
-	struct ieee80211_tx_info *tx_info_first, *tx_info, *tx_info_bcn;
+	struct ieee80211_hdr *mac_hdr;
+	struct ieee80211_tx_info *tx_info_bcn;
 	struct ieee80211_tx_info tx_info_1st_mpdu;
 	struct sk_buff *skb, *tmp, *skb_first = NULL;
 	struct sk_buff_head *skb_list, tx_done_list;
 	int vif_index;
-	unsigned int pkt = 0, cnt = 0;
-	unsigned int descriptor_id = tx_done->descriptor_id;
+	unsigned int pkt = 0;
+	int cnt = 0;
+	int bit = 0;
+	int pool_id = 0;
+	unsigned int desc_id = tx_done->descriptor_id;
 	unsigned int max_tx_cmds = dev->params->max_tx_cmds;
 	struct umac_vif *uvif;
 	struct ieee80211_vif *ivif;
 	unsigned long bcn_int = 0;
+	int pend_pkt_q_len = 0;
+	int peer_id = 0;
+#ifdef MULTI_CHAN_SUPPORT
+	int chanctx_idx = 0;
+#endif
 
 	skb_queue_head_init(&tx_done_list);
 
 	DEBUG_LOG("%s-UMACTX:Free buf Req q = %d, desc_id: %d\n",
 	       dev->name,
 	       tx_done->queue,
-	       descriptor_id);
+	       desc_id);
 
 	spin_lock_irqsave(&tx->lock, flags);
+
 	tx->outstanding_tokens[tx_done->queue]--;
 
-	for (i = 0; i < NUM_ACS; i++) {
-		if (skb_peek(&tx->pending_pkt[i]))
-			break;
-	}
+#ifdef MULTI_CHAN_SUPPORT
+	chanctx_idx = tx->desc_chan_map[desc_id];
+#endif
+
+	bit = (desc_id % TX_DESC_BUCKET_BOUND);
+	pool_id = (desc_id / TX_DESC_BUCKET_BOUND);
 
-	if (i == NUM_ACS) {
-		/* No pending packets */
-		__clear_bit((descriptor_id % TX_DESC_BUCKET_BOUND),
-			    &tx->buf_pool_bmp[(descriptor_id /
-					       TX_DESC_BUCKET_BOUND)]);
-	} else if (descriptor_id < (NUM_TX_DESCS_PER_AC * NUM_ACS)) {
+	if (desc_id < (NUM_TX_DESCS_PER_AC * NUM_ACS)) {
 		/* Reserved token */
 		*queue = tx_done->queue;
+
 		if (*queue != WLAN_AC_BCN) {
-			pkts_pend = skb_queue_len(&tx->pending_pkt[*queue]);
+			peer_id = get_curr_peer_opp(dev,
+#ifdef MULTI_CHAN_SUPPORT
+						    curr_chanctx_idx,
+#endif
+						    *queue);
 
-			if (!pkts_pend)
-				__clear_bit(descriptor_id,
-					    &tx->buf_pool_bmp[0]);
+			if (peer_id == -1) {
+				__clear_bit(bit, &tx->buf_pool_bmp[pool_id]);
+#ifdef MULTI_CHAN_SUPPORT
+				tx->desc_chan_map[desc_id] = -1;
+#endif
+			}
 		} else {
-			__clear_bit(descriptor_id, &tx->buf_pool_bmp[0]);
+			__clear_bit(bit, &tx->buf_pool_bmp[pool_id]);
+#ifdef MULTI_CHAN_SUPPORT
+			tx->desc_chan_map[desc_id] = -1;
+#endif
 		}
-	} else if (descriptor_id >= (NUM_TX_DESCS_PER_AC * NUM_ACS)) {
-		/* Spare token */
+	} else {
+			/* Spare token */
 		for (cnt = WLAN_AC_VO; cnt >= 0; cnt--) {
-			pkts_pend = skb_queue_len(&tx->pending_pkt[cnt]);
+			peer_id = get_curr_peer_opp(dev,
+#ifdef MULTI_CHAN_SUPPORT
+						    curr_chanctx_idx,
+#endif
+						    cnt);
 
-			if (pkts_pend) {
+			if (peer_id != -1) {
 				*queue = cnt;
 				break;
 			}
 		}
 
-		/* If beacon queue has pending and
-		 * no other AC has pending
+		/* If beacon queue has pending and no other AC
+		 *  has pending
 		 */
-		if (!pkts_pend) {
-			__clear_bit((descriptor_id %
-				     TX_DESC_BUCKET_BOUND),
-				    &tx->buf_pool_bmp[(descriptor_id /
-						       TX_DESC_BUCKET_BOUND)]);
-			}
+		if (peer_id == -1) {
+			__clear_bit(bit, &tx->buf_pool_bmp[pool_id]);
+#ifdef MULTI_CHAN_SUPPORT
+			tx->desc_chan_map[desc_id] = -1;
+#endif
+		}
 	}
 
-	DEBUG_LOG("%s-UMACTX:%spending_q = %d, desc_id: %d pending:%d\n",
-	       dev->name,
-	       __func__,
-	       *queue,
-	       descriptor_id,
-	       pkts_pend);
+	if (peer_id != -1)
+		pkts_pend = skb_queue_len(&tx->pending_pkt[peer_id][*queue]);
+
+	DEBUG_LOG("%s-UMACTX:%s pend_q = %d, sta_id = %d desc_id: %d pend:%d\n",
+		  dev->name,
+		  __func__,
+		  *queue,
+		  peer_id,
+		  desc_id,
+		  pkts_pend);
 
 	/* Defer Tx Done Processsing */
-	skb_list = &dev->tx.tx_pkt[descriptor_id];
+#ifdef MULTI_CHAN_SUPPORT
+	skb_list = &dev->tx.pkt_info[chanctx_idx][desc_id].pkt;
+#else
+	skb_list = &dev->tx.pkt_info[desc_id].pkt;
+#endif
 
 	if (skb_queue_len(skb_list)) {
 		/* Cut the list to new one, tx_pkt will be re-initialized */
 		skb_queue_splice_tail_init(skb_list, &tx_done_list);
 	} else {
 		DEBUG_LOG("%s-UMACTX:Got Empty List: list_addr: %p\n",
-			dev->name, skb_list);
+			  dev->name, skb_list);
 	}
 
 	if (pkts_pend > 0) {
-		skb_first = skb_peek(&tx->pending_pkt[*queue]);
-		mac_hdr_first = (struct ieee80211_hdr *)skb_first->data;
-		tx_info_first = IEEE80211_SKB_CB(skb_first);
-
-		/* Temp Checks for Aggregation: Will be removed later */
-		if ((tx_info_first->control.rates[0].flags &
-		     IEEE80211_TX_RC_VHT_MCS) && max_tx_cmds > 24)
-			max_tx_cmds = 24;
-		else if ((tx_info_first->control.rates[0].flags &
-			  IEEE80211_TX_RC_MCS) && max_tx_cmds > 16)
-			max_tx_cmds = 16;
-
-		skb_queue_walk_safe(&tx->pending_pkt[*queue], skb, tmp) {
-			mac_hdr = (struct ieee80211_hdr *)skb->data;
-			tx_info =
-			     (struct ieee80211_tx_info *)IEEE80211_SKB_CB(skb);
-
-			ivif = tx_info->control.vif;
-			uvif = (struct umac_vif *)(ivif->drv_priv);
-			ampdu_len += skb->len;
-
-			/* Aggregate Only AMPDU's with same RA, same Rate,
-			 * same Rate Falgs, same Tx info flags
-			 */
-			if (!ieee80211_is_data(mac_hdr->frame_control) ||
-			    !(tx_info->flags & IEEE80211_TX_CTL_AMPDU) ||
-			    skb_queue_len(skb_list) >= max_tx_cmds ||
-#if 0
-			    (memcmp(&tx_info_first->control.rates[0],
-				    &tx_info->control.rates[0],
-				    sizeof(struct ieee80211_tx_rate) *
-				    IEEE80211_TX_MAX_RATES) != 0) ||
-			    tx_info_first->flags != tx_info->flags ||
-#endif
-			    (memcmp(mac_hdr->addr1,
-				    mac_hdr_first->addr1,
-				    ETH_ALEN) != 0))
-					break;
-
-			/*Always queue the first skb*/
-			__skb_unlink(skb, &tx->pending_pkt[*queue]);
-			skb_queue_tail(skb_list, skb);
-		}
-
-		/* If our criterion rejects all pending frames, send only 1 */
-		if (!skb_queue_len(skb_list)) {
-			skb_queue_tail(skb_list,
-				       skb_dequeue(&tx->pending_pkt[*queue]));
-		}
+		uccp420wlan_tx_proc_pend_frms(dev,
+					      *queue,
+#ifdef MULTI_CHAN_SUPPORT
+					      curr_chanctx_idx,
+#endif
+					      peer_id,
+					      desc_id);
 
 		tx->outstanding_tokens[*queue]++;
 
 		DEBUG_LOG("%s-UMACTX:Pending packets: %d, Total: %d\n",
-		       dev->name,
-		       pkts_pend,
-		       skb_queue_len(skb_list));
+			  dev->name,
+			  pkts_pend,
+			  skb_queue_len(skb_list));
 	} else {
 		DEBUG_LOG("%s-UMACTX:No Pending Packets\n", dev->name);
 	}
 
+	pend_pkt_q_len = skb_queue_len(&tx->pending_pkt[peer_id][*queue]);
+
 	if ((*queue != WLAN_AC_BCN) &&
 	    (tx->queue_stopped_bmp & (1 << *queue)) &&
-	    skb_queue_len(&tx->pending_pkt[*queue]) < (MAX_TX_QUEUE_LEN / 2)) {
+	    pend_pkt_q_len < (MAX_TX_QUEUE_LEN / 2)) {
 		ieee80211_wake_queue(dev->hw, tx_queue_unmap(*queue));
 		tx->queue_stopped_bmp &= ~(1 << (*queue));
 	}
-	/*Unmap here before release lock to avoid race*/
+
+	/* Unmap here before release lock to avoid race */
 	if (skb_queue_len(&tx_done_list)) {
 		skb_queue_walk_safe(&tx_done_list, skb, tmp) {
 			hal_ops.unmap_tx_buf(tx_done->descriptor_id, pkt);
+
 			DEBUG_LOG("%s-UMACTX:TXDONE: ID=%d, Stat=%d (%d, %d)\n",
 				dev->name,
 				tx_done->descriptor_id,
 				tx_done->frm_status[pkt],
 				tx_done->rate[pkt],
 				tx_done->retries_num[pkt]);
+
 			pkt++;
 		}
 	}
-	/*Unlock: Give a chance for Tx to add to pending lists*/
+
+	/* Unlock: Give a chance for Tx to add to pending lists */
 	spin_unlock_irqrestore(&tx->lock, flags);
 
 	/* Protection from mac80211 _ops especially stop */
@@ -579,7 +751,9 @@ int uccp420wlan_tx_free_buff_req(struct mac80211_dev *dev,
 	memcpy(&tx_info_1st_mpdu,
 	       (struct ieee80211_tx_info *)IEEE80211_SKB_CB(skb_first),
 	       sizeof(struct ieee80211_tx_info));
+
 	pkt = 0;
+
 	skb_queue_walk_safe(&tx_done_list, skb, tmp) {
 		__skb_unlink(skb, &tx_done_list);
 
@@ -588,8 +762,13 @@ int uccp420wlan_tx_free_buff_req(struct mac80211_dev *dev,
 		/* In the Tx path we move the .11hdr from skb to CMD_TX
 		 * Hence pushing it here, not required for loopback case
 		 */
+#ifdef MULTI_CHAN_SUPPORT
 		skb_push(skb,
-			 dev->tx.tx_pkt_hdr_len[tx_done->descriptor_id]);
+			 dev->tx.pkt_info[chanctx_idx][desc_id].hdr_len);
+#else
+		skb_push(skb,
+			 dev->tx.pkt_info[tx_done->descriptor_id].hdr_len);
+#endif
 		mac_hdr = (struct ieee80211_hdr *)(skb->data);
 
 		if (!ieee80211_is_beacon(mac_hdr->frame_control)) {
@@ -608,11 +787,11 @@ int uccp420wlan_tx_free_buff_req(struct mac80211_dev *dev,
 
 			if (tx_done->frm_status[pkt] ==
 			    TX_DONE_STAT_DISCARD_BCN) {
-				/*We did not send beacon*/
+				/* We did not send beacon */
 				dev->tx_last_beacon = 0;
 			} else if (tx_done->frm_status[pkt] ==
 				   TX_DONE_STAT_SUCCESS) {
-				/*We did send beacon*/
+				/* We did send beacon */
 				dev->tx_last_beacon = 1;
 			}
 
@@ -626,6 +805,7 @@ int uccp420wlan_tx_free_buff_req(struct mac80211_dev *dev,
 			if (tx_done->frm_status[pkt] == TX_DONE_STAT_SUCCESS) {
 				unsigned int ts2;
 				int bts_vif = uvif->vif_index;
+
 				spin_lock(&tsf_lock);
 				dev->params->sync[bts_vif].status = 1;
 				memcpy(dev->params->sync[bts_vif].bssid,
@@ -661,6 +841,188 @@ out:
 }
 
 
+#ifdef MULTI_CHAN_SUPPORT
+void uccp420wlan_proc_tx_discard_chsw(struct mac80211_dev *dev,
+				      int curr_chanctx_idx,
+				      struct umac_event_tx_done *tx_done)
+{
+	struct tx_config *tx = &dev->tx;
+	struct sk_buff_head *txq = NULL;
+	int chanctx_idx = -1;
+	int pkt = 0;
+	unsigned long flags;
+	int txq_len = 0;
+	struct sk_buff *skb = NULL;
+	struct sk_buff *tmp = NULL;
+	int curr_bit = 0;
+	int pool_id = 0;
+	int queue = 0;
+	int ret = 0;
+	unsigned int desc_id = 0;
+	int peer_id = -1;
+	int ac = -1;
+
+	spin_lock_irqsave(&tx->lock, flags);
+
+	desc_id = tx_done->descriptor_id;
+
+	/* We keep the frames which were not consumed by the FW in the
+	 * tx_pkt queue. These frames will then be requeued to the FW when this
+	 * channel context is scheduled again
+	 */
+	chanctx_idx = tx->desc_chan_map[desc_id];
+
+	if (chanctx_idx == -1) {
+		pr_err("%s: Unexpected channel context\n", __func__);
+		goto out;
+	}
+
+	txq = &tx->pkt_info[chanctx_idx][desc_id].pkt;
+	txq_len = skb_queue_len(txq);
+
+	if (!txq_len) {
+		pr_err("%s: TX_DONE received for empty queue\n", __func__);
+		goto out;
+	}
+
+	pkt = 0;
+
+	skb_queue_walk_safe(txq, skb, tmp) {
+		if (!skb)
+			continue;
+
+		hal_ops.unmap_tx_buf(desc_id, pkt);
+
+		/* In the Tx path we move the .11hdr from skb to CMD_TX
+		 * Hence pushing it here
+		 */
+		skb_push(skb,
+			 tx->pkt_info[chanctx_idx][desc_id].hdr_len);
+
+		pkt++;
+	}
+
+	if (chanctx_idx != curr_chanctx_idx) {
+		/* First check if there is a packet in the txq of the current
+		 * chanctx that needs to be transmitted
+		 */
+		txq = &tx->pkt_info[curr_chanctx_idx][desc_id].pkt;
+		txq_len = skb_queue_len(txq);
+		queue = tx->pkt_info[curr_chanctx_idx][desc_id].queue;
+
+		if (txq_len) {
+			spin_unlock_irqrestore(&tx->lock, flags);
+
+			/* TODO: Currently sending 0 since this param is not
+			 * used as expected in the orig code for multiple
+			 * frames etc Need to set this properly when the orig
+			 * code logic is corrected
+			 */
+			ret = __uccp420wlan_tx_frame(dev,
+						     queue,
+						     desc_id,
+						     curr_chanctx_idx,
+						     0);
+			if (ret < 0) {
+				/* TODO: Check if we need to clear the TX bitmap
+				 * and desc_chan_map here
+				 */
+				pr_err("%s: Queueing of TX frame to FW failed\n",
+				       __func__);
+			} else {
+				spin_lock_irqsave(&tx->lock, flags);
+				tx->desc_chan_map[desc_id] = curr_chanctx_idx;
+				spin_unlock_irqrestore(&tx->lock, flags);
+			}
+
+			return;
+		} else {
+			/* Check pending queue */
+			/* Reserved token */
+			if (desc_id < (NUM_TX_DESCS_PER_AC * NUM_ACS)) {
+				queue = (desc_id % NUM_ACS);
+
+				peer_id = get_curr_peer_opp(dev,
+							    curr_chanctx_idx,
+							    queue);
+
+				if (peer_id == -1)
+					goto done;
+
+			/* Spare token */
+			} else {
+				for (ac = WLAN_AC_VO; ac >= 0; ac--) {
+					peer_id = get_curr_peer_opp(dev,
+							   curr_chanctx_idx,
+							   ac);
+
+					if (peer_id != -1) {
+						queue = ac;
+						break;
+					}
+				}
+
+				if (ac < 0)
+					goto done;
+			}
+
+			uccp420wlan_tx_proc_pend_frms(dev,
+						      queue,
+						      curr_chanctx_idx,
+						      peer_id,
+						      desc_id);
+
+			spin_unlock_irqrestore(&tx->lock, flags);
+
+			/* TODO: Currently sending 0 since this param is not
+			 * used as expected in the orig code for multiple
+			 * frames etc. Need to set this properly when the orig
+			 * code logic is corrected
+			 */
+			ret = __uccp420wlan_tx_frame(dev,
+						     queue,
+						     desc_id,
+						     curr_chanctx_idx,
+						     0);
+
+			if (ret < 0) {
+				/* SDK: Check if we need to clear the TX bitmap
+				 * and desc_chan_map here
+				 */
+				pr_err("%s: Queueing of TX frame to FW failed\n",
+				       __func__);
+			} else {
+				spin_lock_irqsave(&tx->lock, flags);
+				tx->desc_chan_map[desc_id] = curr_chanctx_idx;
+				spin_unlock_irqrestore(&tx->lock, flags);
+			}
+
+			return;
+		}
+	}
+
+done:
+	curr_bit = (desc_id % TX_DESC_BUCKET_BOUND);
+	pool_id = (desc_id / TX_DESC_BUCKET_BOUND);
+
+	/* Mark the token as available */
+	__clear_bit(curr_bit, &tx->buf_pool_bmp[pool_id]);
+
+	tx->desc_chan_map[desc_id] = -1;
+
+	tx->outstanding_tokens[tx_done->queue]--;
+
+	if (txq_len == 1)
+		dev->stats->tx_cmd_send_count_single--;
+	else
+		dev->stats->tx_cmd_send_count_multi--;
+
+out:
+	spin_unlock_irqrestore(&tx->lock, flags);
+}
+#endif
+
+
 #ifdef PERF_PROFILING
 static void print_persec_stats(unsigned long data)
 {
@@ -688,7 +1050,8 @@ static void print_persec_stats(unsigned long data)
 
 void uccp420wlan_tx_init(struct mac80211_dev *dev)
 {
-	int cnt = 0;
+	int i = 0;
+	int j = 0;
 	struct tx_config *tx = &dev->tx;
 
 	memset(&tx->buf_pool_bmp,
@@ -698,13 +1061,31 @@ void uccp420wlan_tx_init(struct mac80211_dev *dev)
 	tx->queue_stopped_bmp = 0;
 	tx->next_spare_token_ac = WLAN_AC_BE;
 
-	for (cnt = 0; cnt < NUM_ACS; cnt++) {
-		skb_queue_head_init(&tx->pending_pkt[cnt]);
-		tx->outstanding_tokens[cnt] = 0;
+	for (i = 0; i < NUM_ACS; i++) {
+		for (j = 0; j < MAX_PEND_Q_PER_AC; j++)
+			skb_queue_head_init(&tx->pending_pkt[j][i]);
+
+		tx->outstanding_tokens[i] = 0;
+	}
+
+	for (i = 0; i < NUM_TX_DESCS; i++) {
+#ifdef MULTI_CHAN_SUPPORT
+		tx->desc_chan_map[i] = -1;
+
+		for (j = 0; j < MAX_CHANCTX; j++)
+			skb_queue_head_init(&tx->pkt_info[j][i].pkt);
+#else
+		skb_queue_head_init(&tx->pkt_info[i].pkt);
+#endif
 	}
 
-	for (cnt = 0; cnt < NUM_TX_DESCS; cnt++)
-		skb_queue_head_init(&tx->tx_pkt[cnt]);
+	for (j = 0; j < NUM_ACS; j++)
+#ifdef MULTI_CHAN_SUPPORT
+		for (i = 0; i < MAX_CHANCTX; i++)
+			tx->curr_peer_opp[i][j] = 0;
+#else
+		tx->curr_peer_opp[j] = 0;
+#endif
 
 #ifdef PERF_PROFILING
 	init_timer(&tx->persec_timer);
@@ -721,24 +1102,37 @@ void uccp420wlan_tx_init(struct mac80211_dev *dev)
 
 void uccp420wlan_tx_deinit(struct mac80211_dev *dev)
 {
-	int cnt = 0;
+	int i = 0;
+	int j = 0;
 	unsigned long flags = 0;
 	struct tx_config *tx = &dev->tx;
 	struct sk_buff *skb;
+
 	ieee80211_stop_queues(dev->hw);
 
 	wait_for_tx_complete(tx);
 
 	spin_lock_irqsave(&tx->lock, flags);
 
-	for (cnt = 0; cnt < NUM_TX_DESCS; cnt++) {
-		while ((skb = skb_dequeue(&tx->tx_pkt[cnt])) != NULL)
+	for (i = 0; i < NUM_TX_DESCS; i++) {
+#ifdef MULTI_CHAN_SUPPORT
+		for (j = 0; j < MAX_CHANCTX; j++)
+			while ((skb = skb_dequeue(&tx->pkt_info[j][i].pkt)) !=
+			       NULL)
+				dev_kfree_skb_any(skb);
+#else
+		while ((skb = skb_dequeue(&tx->pkt_info[i].pkt)) != NULL)
 			dev_kfree_skb_any(skb);
+#endif
 	}
 
-	for (cnt = 0; cnt < NUM_ACS; cnt++) {
-		while ((skb = skb_dequeue(&tx->pending_pkt[cnt])) != NULL)
-			dev_kfree_skb_any(skb);
+	for (i = 0; i < NUM_ACS; i++) {
+		for (j = 0; j < MAX_PEND_Q_PER_AC; j++) {
+			while ((skb =
+				skb_dequeue(&tx->pending_pkt[j][i])) !=
+			       NULL)
+				dev_kfree_skb_any(skb);
+		}
 	}
 
 	spin_unlock_irqrestore(&tx->lock, flags);
@@ -747,24 +1141,80 @@ void uccp420wlan_tx_deinit(struct mac80211_dev *dev)
 }
 
 
-int __uccp420wlan_tx_frame(struct ieee80211_sta *sta,
+int __uccp420wlan_tx_frame(struct mac80211_dev *dev,
 			   unsigned int queue,
-			   unsigned int buff_pool_id,
-			   unsigned int more_frames,
-			   struct mac80211_dev *dev)
+			   unsigned int token_id,
+#ifdef MULTI_CHAN_SUPPORT
+			   int curr_chanctx_idx,
+#endif
+			   unsigned int more_frames)
 {
-	return uccp420wlan_prog_tx(queue, more_frames, buff_pool_id);
+	struct umac_event_tx_done tx_done;
+	struct sk_buff_head *txq = NULL;
+	int ret = 0;
+	int pkt = 0;
+
+	ret = uccp420wlan_prog_tx(queue,
+				  more_frames,
+#ifdef MULTI_CHAN_SUPPORT
+				  curr_chanctx_idx,
+#endif
+				  token_id);
+
+	if (ret < 0) {
+		pr_err("%s-UMACTX: Unable to send frame, dropping ..%d\n",
+		       dev->name, ret);
+
+		tx_done.descriptor_id = token_id;
+		tx_done.queue = queue;
+
+#ifdef MULTI_CHAN_SUPPORT
+		txq = &dev->tx.pkt_info[curr_chanctx_idx][token_id].pkt;
+#else
+		txq = &dev->tx.pkt_info[token_id].pkt;
+#endif
+
+		for (pkt = 0; pkt < skb_queue_len(txq); pkt++) {
+			tx_done.frm_status[pkt] = TX_DONE_STAT_ERR_RETRY_LIM;
+			tx_done.rate[pkt] = 0;
+		}
+
+		uccp420wlan_tx_complete(&tx_done,
+#ifdef MULTI_CHAN_SUPPORT
+					curr_chanctx_idx,
+#endif
+					dev);
+	}
+
+	return ret;
 }
 
 
 int uccp420wlan_tx_frame(struct sk_buff *skb,
 			 struct ieee80211_sta *sta,
 			 struct mac80211_dev *dev,
+#ifdef MULTI_CHAN_SUPPORT
+			 int curr_chanctx_idx,
+#endif
 			 bool bcast)
 {
-	unsigned int queue, descriptor_id, pkt, more_frames;
+	unsigned int queue = 0;
+	unsigned int token_id = 0;
+	unsigned int more_frames = 0;
 	int ret = 0;
 	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
+	struct umac_vif *uvif = NULL;
+	struct umac_sta *usta = NULL;
+	int peer_id = -1;
+
+	uvif = (struct umac_vif *)(tx_info->control.vif->drv_priv);
+
+	if (sta) {
+		usta = (struct umac_sta *)sta->drv_priv;
+		peer_id = usta->index;
+	} else {
+		peer_id = MAX_PEERS + uvif->vif_index;
+	}
 
 	if (bcast == false) {
 		queue = tx_queue_map(skb->queue_mapping);
@@ -781,7 +1231,7 @@ int uccp420wlan_tx_frame(struct sk_buff *skb,
 		tx_info->flags |= IEEE80211_TX_CTL_AMPDU;
 
 	if (tx_info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) {
-		/*These are high priority frames, send them in VO*/
+		/* These are high priority frames, send them in VO */
 		queue = WLAN_AC_VO;
 		atomic_inc(&dev->roc_params.roc_mgmt_tx_count);
 	}
@@ -790,33 +1240,30 @@ int uccp420wlan_tx_frame(struct sk_buff *skb,
 		dev->name,
 		__func__, __LINE__, queue, skb->queue_mapping);
 
-	uccp420wlan_tx_alloc_buff_req(dev, queue, &descriptor_id, skb);
+	token_id = uccp420wlan_tx_alloc_buff_req(dev,
+						 queue,
+#ifdef MULTI_CHAN_SUPPORT
+						 uvif,
+						 curr_chanctx_idx,
+#endif
+						 peer_id,
+						 skb);
 
-	if (descriptor_id == NUM_TX_DESCS) {
+	/* The frame was unable to find a reserved token */
+	if (token_id == NUM_TX_DESCS) {
 		DEBUG_LOG("%s-UMACTX:%s:%d Token Busy Queued:\n",
 			dev->name, __func__, __LINE__);
 		return NETDEV_TX_OK;
 	}
-	ret = __uccp420wlan_tx_frame(sta, queue, descriptor_id, more_frames,
-				     dev);
-	if (ret < 0) {
-		struct umac_event_tx_done tx_done;
-
-		pr_err("%s-UMACTX: Unable to send frame, dropping ..%d\n",
-		       dev->name, ret);
 
-		tx_done.descriptor_id = descriptor_id;
-		tx_done.queue = queue;
-
-		for (pkt = 0; pkt <
-		     skb_queue_len(&dev->tx.tx_pkt[descriptor_id]); pkt++) {
-			tx_done.frm_status[pkt] =
-				TX_DONE_STAT_ERR_RETRY_LIM;
-			tx_done.rate[pkt] = 0;
-		}
+	ret = __uccp420wlan_tx_frame(dev,
+				     queue,
+				     token_id,
+#ifdef MULTI_CHAN_SUPPORT
+				     curr_chanctx_idx,
+#endif
+				     more_frames);
 
-		uccp420wlan_tx_complete(&tx_done, dev);
-	}
 
 	return NETDEV_TX_OK;
 }
@@ -850,72 +1297,75 @@ void uccp420wlan_proc_tx_complete(struct umac_event_tx_done *tx_done,
 }
 
 void uccp420wlan_tx_complete(struct umac_event_tx_done *tx_done,
+#ifdef MULTI_CHAN_SUPPORT
+			     int curr_chanctx_idx,
+#endif
 			     void *context)
 {
 	struct mac80211_dev *dev = (struct mac80211_dev *)context;
 	unsigned int  more_frames;
 	int vif_index = 0, vif_index_bitmap = 0, ret = 0;
-	unsigned int pkt = 0, pkts_pending = 0;
+	unsigned int pkts_pending = 0;
 	unsigned char queue = 0;
 	struct umac_event_noa noa_event;
+	int token_id = 0;
+	int qlen = 0;
 
-	/*for (i = 0; i < 32; i++)*/
-	{
-		/* increment tx_done_recv_count to keep track of number of
-		 * tx_done received do not count tx dones from host.
-		 */
-		dev->stats->tx_done_recv_count++;
-tx_complete:
-
-		DEBUG_LOG("%s-UMACTX:TX Done Rx for desc_id: %d qlen: %d\n",
-		       dev->name,
-		       tx_done->descriptor_id,
-		       skb_queue_len(&dev->tx.tx_pkt[
-				     tx_done->descriptor_id]));
-		update_aux_adc_voltage(dev, tx_done->pdout_voltage);
-		pkts_pending = uccp420wlan_tx_free_buff_req(dev,
-							    tx_done,
-							    &queue,
-							    &vif_index_bitmap);
-
-
-		if (pkts_pending) {
-			/*TODO..Do we need to check each skb for more_frames??*/
-#if 0
-			if ((queue == WLAN_AC_BCN) && (skb->priority == 1))
-				more_frames = 1;
-			else
-				more_frames = 0;
+	token_id = tx_done->descriptor_id;
+
+#ifdef MULTI_CHAN_SUPPORT
+	qlen = skb_queue_len(&dev->tx.pkt_info[curr_chanctx_idx][token_id].pkt);
+#else
+	qlen = skb_queue_len(&dev->tx.pkt_info[token_id].pkt);
+#endif
+
+	DEBUG_LOG("%s-UMACTX:TX Done Rx for desc_id: %d qlen: %d\n",
+		  dev->name,
+		  tx_done->descriptor_id,
+		  qlen);
+
+	update_aux_adc_voltage(dev, tx_done->pdout_voltage);
+
+#ifdef MULTI_CHAN_SUPPORT
+	if (tx_done->frm_status[0] == TX_DONE_STAT_DISCARD_CHSW) {
+		uccp420wlan_proc_tx_discard_chsw(dev,
+						 curr_chanctx_idx,
+						 tx_done);
+		return;
+	}
 #endif
+	pkts_pending = uccp420wlan_tx_free_buff_req(dev,
+						    tx_done,
+						    &queue,
+#ifdef MULTI_CHAN_SUPPORT
+						    curr_chanctx_idx,
+#endif
+						    &vif_index_bitmap);
+
+	if (pkts_pending) {
+		/*TODO..Do we need to check each skb for more_frames??*/
+#if 0
+		if ((queue == WLAN_AC_BCN) && (skb->priority == 1))
+			more_frames = 1;
+		else
 			more_frames = 0;
+#endif
+		more_frames = 0;
 
 			DEBUG_LOG("%s-UMACTX:%s:%d Transfer Pending Frames:\n",
 			       dev->name,
 			       __func__, __LINE__);
 
-			ret = __uccp420wlan_tx_frame(NULL,
-						     queue,
-						     tx_done->descriptor_id,
-						     more_frames, dev);
-
-			if (ret < 0) {
-				DEBUG_LOG("%s-UMACTX:TX (pending) failed %d\n",
-				       dev->name,
-				       ret);
-
-				tx_done->queue = queue;
-
-				for (pkt = 0; pkt < pkts_pending; pkt++) {
-					tx_done->frm_status[pkt] =
-						TX_DONE_STAT_ERR_RETRY_LIM;
-					tx_done->rate[pkt] = 0;
-				}
+		ret = __uccp420wlan_tx_frame(dev,
+					     queue,
+					     token_id,
+#ifdef MULTI_CHAN_SUPPORT
+					     curr_chanctx_idx,
+#endif
+					     more_frames);
 
-				goto tx_complete;
-			}
-		} else {
-			DEBUG_LOG("%s-UMACTX:No Pending Packets\n", dev->name);
-		}
+	} else {
+		DEBUG_LOG("%s-UMACTX:No Pending Packets\n", dev->name);
 	}
 
 	for (vif_index = 0; vif_index < MAX_VIFS; vif_index++) {
diff --git a/drivers/net/wireless/uccp420wlan/src/umac_if.c b/drivers/net/wireless/uccp420wlan/src/umac_if.c
index b02f782..5493acd 100644
--- a/drivers/net/wireless/uccp420wlan/src/umac_if.c
+++ b/drivers/net/wireless/uccp420wlan/src/umac_if.c
@@ -324,7 +324,7 @@ static void get_rate(struct sk_buff *skb,
 				dev->params->prod_mode_stbc_enabled;
 
 			update_mcs_packet_stat(mcs_indx,
-					       txcmd->rate_flags[index] ,
+					       txcmd->rate_flags[index],
 					       dev);
 		} else if (ieee80211_is_data(hdr->frame_control) &&
 			   mgd_rate != -1) {
@@ -346,7 +346,7 @@ static void get_rate(struct sk_buff *skb,
 			txcmd->rate[index] = 0x80;
 			txcmd->rate[index] |= mcs_rate_num;
 			update_mcs_packet_stat(mcs_rate_num,
-					      txcmd->rate_flags[index] ,
+					      txcmd->rate_flags[index],
 					      dev);
 		} else if (!is_mcs) { /* idx is RATE...*/
 			rate = &dev->hw->wiphy->bands[
@@ -465,7 +465,6 @@ static void get_rate(struct sk_buff *skb,
 
 		txcmd->num_rates++;
 	}
-	return;
 }
 
 
@@ -607,6 +606,7 @@ int uccp420wlan_proc_tx(void)
 	struct ieee80211_hdr *mac_hdr;
 	unsigned int index = 0, descriptor_id = 0, queue = WLAN_AC_BE, pkt = 0;
 	u16 hdrlen = 26;
+
 	rcu_read_lock();
 	p = (struct lmac_if_data *)(rcu_dereference(lmac_if));
 
@@ -740,6 +740,7 @@ int uccp420wlan_prog_txpower(unsigned int txpower)
 int uccp420wlan_prog_btinfo(unsigned int bt_state)
 {
 	struct cmd_bt_info bt_info;
+
 	memset(&bt_info, 0, sizeof(struct cmd_bt_info));
 	bt_info.bt_state = bt_state;
 
@@ -818,6 +819,7 @@ int uccp420wlan_prog_roc(unsigned int roc_status,
 			 unsigned int roc_duration)
 {
 	struct cmd_roc cmd_roc;
+
 	memset(&cmd_roc, 0, sizeof(struct cmd_roc));
 
 	cmd_roc.roc_status	= roc_status;
@@ -927,7 +929,7 @@ int uccp420wlan_prog_peer_key(int vif_index,
 		peer_key.key_len += TKIP_MIC_LEN;
 	}
 	if (key->rx_mic) {
-		memcpy(peer_key.key + MAX_KEY_LEN + TKIP_MIC_LEN , key->rx_mic,
+		memcpy(peer_key.key + MAX_KEY_LEN + TKIP_MIC_LEN, key->rx_mic,
 		       TKIP_MIC_LEN);
 		peer_key.key_len += TKIP_MIC_LEN;
 	}
@@ -1171,6 +1173,9 @@ int uccp420wlan_prog_channel(unsigned int prim_ch,
 			     unsigned int ch_no1,
 			     unsigned int ch_no2,
 			     unsigned int ch_width,
+#ifdef MULTI_CHAN_SUPPORT
+			     unsigned int vif_index,
+#endif
 			     unsigned int freq_band)
 {
 	struct cmd_channel channel;
@@ -1200,6 +1205,9 @@ int uccp420wlan_prog_channel(unsigned int prim_ch,
 	}
 
 	channel.freq_band = freq_band;
+#ifdef MULTI_CHAN_SUPPORT
+	channel.vif_index = vif_index;
+#endif
 
 	return uccp420wlan_send_cmd((unsigned char *) &channel,
 				    sizeof(struct cmd_channel),
@@ -1207,6 +1215,63 @@ int uccp420wlan_prog_channel(unsigned int prim_ch,
 }
 
 
+#ifdef MULTI_CHAN_SUPPORT
+int uccp420wlan_prog_chanctx_time_info(void)
+{
+	struct cmd_chanctx_time_config time_cfg;
+	int i = 0;
+	int j = 0;
+	struct mac80211_dev *dev = NULL;
+	struct lmac_if_data *p = NULL;
+	struct ieee80211_chanctx_conf *curr_conf = NULL;
+	struct umac_chanctx *curr_ctx = NULL;
+	int freq = 0;
+
+	rcu_read_lock();
+
+	p = (struct lmac_if_data *)(rcu_dereference(lmac_if));
+
+	if (!p) {
+		WARN_ON(1);
+		rcu_read_unlock();
+		return -1;
+	}
+
+	rcu_read_unlock();
+
+	dev = p->context;
+
+	memset(&time_cfg, 0, sizeof(struct cmd_chanctx_time_config));
+
+	rcu_read_lock();
+
+	for (i = 0; i < MAX_CHANCTX; i++) {
+		curr_conf = rcu_dereference(dev->chanctx[i]);
+
+		if (curr_conf) {
+			curr_ctx = (struct umac_chanctx *)curr_conf->drv_priv;
+
+			if (curr_ctx->nvifs) {
+				freq = curr_conf->def.chan->center_freq;
+
+				time_cfg.info[j].chan =
+					ieee80211_frequency_to_channel(freq);
+				time_cfg.info[j].percentage =
+					(100 / dev->num_active_chanctx);
+				j++;
+			}
+		}
+	}
+
+	rcu_read_unlock();
+
+	return uccp420wlan_send_cmd((unsigned char *)&time_cfg,
+				    sizeof(struct cmd_chanctx_time_config),
+				    UMAC_CMD_CHANCTX_TIME_INFO);
+}
+#endif
+
+
 int uccp420wlan_prog_ps_state(int index,
 			      unsigned char *vif_addr,
 			      unsigned int powersave_state)
@@ -1224,6 +1289,9 @@ int uccp420wlan_prog_ps_state(int index,
 
 int uccp420wlan_prog_tx(unsigned int queue,
 			unsigned int more_frms,
+#ifdef MULTI_CHAN_SUPPORT
+			int curr_chanctx_idx,
+#endif
 			unsigned int descriptor_id)
 {
 	struct cmd_tx_ctrl tx_cmd;
@@ -1233,7 +1301,7 @@ int uccp420wlan_prog_tx(unsigned int queue,
 	struct mac80211_dev *dev;
 	struct umac_vif *uvif;
 	struct sk_buff *skb, *skb_first, *tmp;
-	struct sk_buff_head *tx_skb_list;
+	struct sk_buff_head *txq = NULL;
 	struct ieee80211_hdr *mac_hdr;
 	struct ieee80211_tx_info *tx_info_first;
 	unsigned int hdrlen, pkt = 0;
@@ -1254,8 +1322,12 @@ int uccp420wlan_prog_tx(unsigned int queue,
 
 	dev = p->context;
 	spin_lock_irqsave(&dev->tx.lock, tx_irq_flags);
-	tx_skb_list = &dev->tx.tx_pkt[descriptor_id];
-	skb_first = skb_peek(tx_skb_list);
+#ifdef MULTI_CHAN_SUPPORT
+	txq = &dev->tx.pkt_info[curr_chanctx_idx][descriptor_id].pkt;
+#else
+	txq = &dev->tx.pkt_info[descriptor_id].pkt;
+#endif
+	skb_first = skb_peek(txq);
 
 	if (!skb_first) {
 		spin_unlock_irqrestore(&dev->tx.lock, tx_irq_flags);
@@ -1318,7 +1390,7 @@ int uccp420wlan_prog_tx(unsigned int queue,
 	tx_cmd.queue_num = queue;
 	tx_cmd.more_frms = more_frms;
 	tx_cmd.descriptor_id = descriptor_id;
-	tx_cmd.num_frames_per_desc = skb_queue_len(tx_skb_list);
+	tx_cmd.num_frames_per_desc = skb_queue_len(txq);
 	tx_cmd.pkt_gram_payload_len = hdrlen;
 	tx_cmd.aggregate_mpdu = AMPDU_AGGR_DISABLED;
 
@@ -1347,7 +1419,7 @@ int uccp420wlan_prog_tx(unsigned int queue,
 		     dev->name,
 		     tx_cmd.queue_num, tx_cmd.descriptor_id);
 	DEBUG_LOG("		num_frames= %d qlen: %d len = %d\n",
-		     tx_cmd.num_frames_per_desc, skb_queue_len(tx_skb_list),
+		     tx_cmd.num_frames_per_desc, skb_queue_len(txq),
 		     nbuf->len);
 
 	DEBUG_LOG("%s-UMACTX: Num rates = %d, %x, %x, %x, %x\n",
@@ -1358,7 +1430,7 @@ int uccp420wlan_prog_tx(unsigned int queue,
 		     tx_cmd.rate[2],
 		     tx_cmd.rate[3]);
 
-	skb_queue_walk_safe(tx_skb_list, skb, tmp) {
+	skb_queue_walk_safe(txq, skb, tmp) {
 		if (!skb || (pkt > tx_cmd.num_frames_per_desc))
 			break;
 
@@ -1379,9 +1451,17 @@ int uccp420wlan_prog_tx(unsigned int queue,
 		}
 
 		/* Need it for tx_status later */
-		dev->tx.tx_pkt_hdr_len[descriptor_id] = hdrlen;
+#ifdef MULTI_CHAN_SUPPORT
+		dev->tx.pkt_info[curr_chanctx_idx][descriptor_id].hdr_len =
+			hdrlen;
+		dev->tx.pkt_info[curr_chanctx_idx][descriptor_id].queue =
+			queue;
+#else
+		dev->tx.pkt_info[descriptor_id].hdr_len = hdrlen;
+		dev->tx.pkt_info[descriptor_id].queue = queue;
+#endif
 
-		/* Complete packet length*/
+		/* Complete packet length */
 		((struct cmd_tx_ctrl *)nbuf_start)->pkt_length[pkt] = skb->len;
 
 		/* We move the 11hdr from skb to UMAC_CMD_TX, this is part of
@@ -1410,17 +1490,31 @@ int uccp420wlan_prog_tx(unsigned int queue,
 #ifdef PERF_PROFILING
 	if (dev->params->driver_tput == 0) {
 #endif
+
+		/* SDK: Check if we can use the same txq initialized before in
+		 * the function here
+		 */
+#ifdef MULTI_CHAN_SUPPORT
+		txq = &dev->tx.pkt_info[curr_chanctx_idx][descriptor_id].pkt;
+#else
+		txq = &dev->tx.pkt_info[descriptor_id].pkt;
+#endif
+
 		spin_lock_irqsave(&cmd_info.control_path_lock, irq_flags);
-		hal_ops.send((void *)nbuf, HOST_MOD_ID, UMAC_MOD_ID,
-			     (void *)&dev->tx.tx_pkt[descriptor_id]);
+
+		hal_ops.send((void *)nbuf,
+			     HOST_MOD_ID,
+			     UMAC_MOD_ID,
+			     (void *)txq);
+
 		spin_unlock_irqrestore(&cmd_info.control_path_lock, irq_flags);
 
 		/* increment tx_cmd_send_count to keep track of number of
 		 * tx_cmd send
 		 */
-		if (skb_queue_len(&dev->tx.tx_pkt[descriptor_id]) == 1)
+		if (skb_queue_len(txq) == 1)
 			dev->stats->tx_cmd_send_count_single++;
-		else if (skb_queue_len(&dev->tx.tx_pkt[descriptor_id]) > 1)
+		else if (skb_queue_len(txq) > 1)
 			dev->stats->tx_cmd_send_count_multi++;
 #ifdef PERF_PROFILING
 	}
@@ -1703,7 +1797,7 @@ int uccp420wlan_sta_add(int index, struct peer_sta_info *st)
 	for (i = 0; i < STA_NUM_BANDS; i++)
 		sta.supp_rates[i] = st->supp_rates[i];
 
-	/*HT info*/
+	/* HT info */
 	sta.if_index = index;
 	sta.ht_cap = st->ht_cap;
 	sta.ht_supported = st->ht_supported;
@@ -1714,7 +1808,7 @@ int uccp420wlan_sta_add(int index, struct peer_sta_info *st)
 	sta.rx_highest = st->rx_highest;
 	sta.tx_params = st->tx_params;
 
-	/*Enable it when FW supports it*/
+	/* Enable it when FW supports it */
 	/* sta.uapsd_queues = st->uapsd_queues; */
 	for (i = 0; i < HT_MCS_MASK_LEN; i++)
 		sta.rx_mask[i] = st->rx_mask[i];
@@ -1775,6 +1869,7 @@ int uccp420wlan_prog_txq_params(int index,
 int uccp420wlan_set_rate(int rate, int mcs)
 {
 	struct cmd_rate cmd_rate;
+
 	memset(&cmd_rate, 0, (sizeof(struct cmd_rate)));
 	DEBUG_LOG("mcs = %d rate = %d\n", mcs, rate);
 	cmd_rate.is_mcs = mcs;
@@ -1802,7 +1897,8 @@ int uccp420wlan_prog_rcv_bcn_mode(unsigned int bcn_rcv_mode)
 int uccp420wlan_prog_aux_adc_chain(unsigned int chain_id)
 {
 	struct cmd_aux_adc_chain_sel aadc_chain_sel;
-	memset(&aadc_chain_sel, 0 , sizeof(struct cmd_aux_adc_chain_sel));
+
+	memset(&aadc_chain_sel, 0, sizeof(struct cmd_aux_adc_chain_sel));
 	aadc_chain_sel.chain_id = chain_id;
 
 	return uccp420wlan_send_cmd((unsigned char *)&aadc_chain_sel,
@@ -1878,8 +1974,8 @@ int uccp420wlan_prog_econ_ps_state(int if_index,
 #endif
 
 
-int uccp420wlan_msg_handler (void *nbuff,
-			     unsigned char sender_id)
+int uccp420wlan_msg_handler(void *nbuff,
+			    unsigned char sender_id)
 {
 	unsigned int event;
 	unsigned char *buff;
@@ -1889,6 +1985,9 @@ int uccp420wlan_msg_handler (void *nbuff,
 	struct sk_buff *pending_cmd;
 	unsigned long irq_flags;
 	struct mac80211_dev *dev;
+#ifdef MULTI_CHAN_SUPPORT
+	int curr_chanctx_idx = -1;
+#endif
 
 	rcu_read_lock();
 
@@ -1968,9 +2067,23 @@ int uccp420wlan_msg_handler (void *nbuff,
 		    dev->params->start_prod_mode)
 			uccp420wlan_proc_tx_complete((void *)buff,
 						     p->context);
-		else
+		else {
+			/* Increment tx_done_recv_count to keep track of number
+			 * of tx_done received do not count tx dones from host.
+			 */
+			dev->stats->tx_done_recv_count++;
+
+#ifdef MULTI_CHAN_SUPPORT
+			spin_lock(&dev->chanctx_lock);
+			curr_chanctx_idx = dev->curr_chanctx_idx;
+			spin_unlock(&dev->chanctx_lock);
+#endif
 			uccp420wlan_tx_complete((void *)buff,
+#ifdef MULTI_CHAN_SUPPORT
+						curr_chanctx_idx,
+#endif
 						p->context);
+		}
 
 		cmd_info.tx_done_recv_count++;
 
@@ -2056,7 +2169,17 @@ int uccp420wlan_msg_handler (void *nbuff,
 			(struct umac_event_ch_prog_complete *)buff, p->context);
 	} else if (event == UMAC_EVENT_RF_CALIB_DATA) {
 		struct umac_event_rf_calib_data  *rf_data = (void *) buff;
+
 		uccp420wlan_rf_calib_data(rf_data, p->context);
+#ifdef MULTI_CHAN_SUPPORT
+	/* SDK: Need to see if this will work in tasklet context (due to
+	 * scheduling latencies)
+	 */
+	} else if (event == UMAC_EVENT_CHAN_SWITCH) {
+		uccp420wlan_proc_ch_sw_event((void *)buff,
+					     p->context);
+
+#endif
 	} else {
 		pr_warn("%s: Unknown event received %d\n", __func__, event);
 	}
-- 
1.9.1

